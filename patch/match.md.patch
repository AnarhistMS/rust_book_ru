diff --git a/rust/master:src/doc/trpl/match.md b/fix_current_version:match.md
index 73bc775..0f1ec2a 100644
--- a/rust/master:src/doc/trpl/match.md
+++ b/fix_current_version:match.md
@@ -1,47 +1,50 @@
-% Match
+% Сопоставление с образцом (Match)
 
-Often, a simple `if`/`else` isn't enough, because you have more than two
-possible options. Also, `else` conditions can get incredibly complicated, so
-what's the solution?
+Простого `if`/`else` часто недостаточно, потому что нужно проверить больше,
+чем два возможных варианта. Да и к тому же условия в `else` часто становятся
+очень сложными. Как же решить эту проблему?
 
-Rust has a keyword, `match`, that allows you to replace complicated `if`/`else`
-groupings with something more powerful. Check it out:
+В Rust есть ключевое слово `match`, позволяющее заменить группы операторов
+`if`/`else` чем-то более удобным. Смотрите:
 
 ```{rust}
 let x = 5;
 
 match x {
-    1 => println!("one"),
-    2 => println!("two"),
-    3 => println!("three"),
-    4 => println!("four"),
-    5 => println!("five"),
-    _ => println!("something else"),
+    1 => println!("один"),
+    2 => println!("два"),
+    3 => println!("три"),
+    4 => println!("четыре"),
+    5 => println!("пять"),
+    _ => println!("что-то ещё"),
 }
 ```
 
-`match` takes an expression and then branches based on its value. Each *arm* of
-the branch is of the form `val => expression`. When the value matches, that arm's
-expression will be evaluated. It's called `match` because of the term 'pattern
-matching', which `match` is an implementation of.
+`match` принимает выражение и выбирает одну из ветвей исполнения согласно его
+значению. Каждая *ветвь* имеет форму `значение => выражение`. Выражение
+ветви вычисляется, когда значение данной ветви совпадает со значением, принятым
+оператором `match` (в данном случае, `x`). Эта конструкция называется `match`
+(сопоставление), потому что она выполняет сопоставление значения неким
+"образцам".
 
-So what's the big advantage here? Well, there are a few. First of all, `match`
-enforces *exhaustiveness checking*. Do you see that last arm, the one with the
-underscore (`_`)? If we remove that arm, Rust will give us an error:
+Так в чём же преимущества данной конструкции? Их несколько. Во-первых, ветви
+`match` *проверяются на полноту*. Видите последнюю ветвь, со знаком
+подчёркивания (`_`)? Если мы удалим её, Rust выдаст ошибку:
 
 ```text
 error: non-exhaustive patterns: `_` not covered
 ```
 
-In other words, Rust is trying to tell us we forgot a value. Because `x` is an
-integer, Rust knows that it can have a number of different values – for example,
-`6`. Without the `_`, however, there is no arm that could match, and so Rust refuses
-to compile. `_` acts like a *catch-all arm*. If none of the other arms match,
-the arm with `_` will, and since we have this catch-all arm, we now have an arm
-for every possible value of `x`, and so our program will compile successfully.
+Другими словами, компилятор сообщает нам, что мы забыли сопоставить какие-то
+значения. Поскольку `x` - это целое число, оно может принимать разные значения -
+например, `6`. Однако, если мы убираем ветвь `_`, ни одна ветвь не совпадёт,
+поэтому такой код не скомпилируется. `_` - это *совпадение с любым значением*.
+Если ни одна другая ветвь не совпала, совпадёт ветвь с `_`. Поскольку в примере
+выше есть ветвь с `_`, мы покрываем всё множество значений `x`, и наша программа
+скомпилируется.
 
-`match` statements also destructure enums, as well. Remember this code from the
-section on enums?
+Оператор `match` также осуществляет разбор перечислений. Помните этот код из
+раздела про перечисления?
 
 ```{rust}
 use std::cmp::Ordering;
@@ -59,16 +62,16 @@ fn main() {
     let ordering = cmp(x, y);
 
     if ordering == Ordering::Less {
-        println!("less");
+        println!("меньше");
     } else if ordering == Ordering::Greater {
-        println!("greater");
+        println!("больше");
     } else if ordering == Ordering::Equal {
-        println!("equal");
+        println!("равно");
     }
 }
 ```
 
-We can re-write this as a `match`:
+Мы можем переписать его с использованием `match`:
 
 ```{rust}
 use std::cmp::Ordering;
@@ -84,21 +87,22 @@ fn main() {
     let y = 10;
 
     match cmp(x, y) {
-        Ordering::Less => println!("less"),
-        Ordering::Greater => println!("greater"),
-        Ordering::Equal => println!("equal"),
+        Ordering::Less => println!("меньше"),
+        Ordering::Greater => println!("больше"),
+        Ordering::Equal => println!("равно"),
     }
 }
 ```
 
-This version has way less noise, and it also checks exhaustively to make sure
-that we have covered all possible variants of `Ordering`. With our `if`/`else`
-version, if we had forgotten the `Greater` case, for example, our program would
-have happily compiled. If we forget in the `match`, it will not. Rust helps us
-make sure to cover all of our bases.
+Такой код не только чище, но и проверяет полноту сопоставления вариантов
+перечисления `Ordering`. Если бы мы забыли случай `Greater` в примере
+с `if`/`else`, наша программа всё равно скомпилировалась бы. А вот если мы
+забудем сопоставить вариант перечисления в операторе `match`, то компилятор
+выдаст ошибку. Rust помогает нам удостовериться, что перечисление обрабатывается
+верно.
 
-`match` expressions also allow us to get the values contained in an `enum`
-(also known as destructuring) as follows:
+Оператор `match` также позволяет извлекать значения, содержащихся в
+перечислении. Это по-другому называется "деконструкцией" или "разбором".
 
 ```{rust}
 enum OptionalInt {
@@ -111,26 +115,27 @@ fn main() {
     let y = OptionalInt::Missing;
 
     match x {
-        OptionalInt::Value(n) => println!("x is {}", n),
-        OptionalInt::Missing => println!("x is missing!"),
+        OptionalInt::Value(n) => println!("x равен {}", n),
+        OptionalInt::Missing => println!("x отсутствует!"),
     }
 
     match y {
-        OptionalInt::Value(n) => println!("y is {}", n),
-        OptionalInt::Missing => println!("y is missing!"),
+        OptionalInt::Value(n) => println!("y равен {}", n),
+        OptionalInt::Missing => println!("y отсутствует!"),
     }
 }
 ```
 
-That is how you can get and use the values contained in `enum`s.
-It can also allow us to handle errors or unexpected computations; for example, a
-function that is not guaranteed to be able to compute a result (an `i32` here)
-could return an `OptionalInt`, and we would handle that value with a `match`.
-As you can see, `enum` and `match` used together are quite useful!
+Вот так вы можете получить и использовать значения из перечислений.
+Это также позволяет нам организовать обработку ошибок или непредвиденных
+ситуаций. Например, функция, которая не всегда может вычислить результат
+(в данном случае типа `i32`), может возвращать `OptionalInt`. Такое значение
+затем можно обработать с помощью `match`. Как вы можете видеть, `enum` и
+`match` отлично дополняют друг друга!
 
-`match` is also an expression, which means we can use it on the right-hand
-side of a `let` binding or directly where an expression is used. We could
-also implement the previous example like this:
+`match` также является выражением. Это значит, что мы можем использовать его
+в правой части оператора `let` или прямо как результат. Мы могли бы реализовать
+предыдущий пример так:
 
 ```{rust}
 use std::cmp::Ordering;
@@ -146,11 +151,11 @@ fn main() {
     let y = 10;
 
     println!("{}", match cmp(x, y) {
-        Ordering::Less => "less",
-        Ordering::Greater => "greater",
-        Ordering::Equal => "equal",
+        Ordering::Less => "меньше",
+        Ordering::Greater => "больше",
+        Ordering::Equal => "равно",
     });
 }
 ```
 
-Sometimes, it's a nice pattern.
+Иногда это очень удобно.
