diff --git a/rust/master:src/doc/trpl/match.md b/HEAD:match.md
index 33d603f..65b6c41 100644
--- a/rust/master:src/doc/trpl/match.md
+++ b/HEAD:match.md
@@ -1,62 +1,160 @@
-% Match
+% Конструкция `match` (Сопоставление с шаблоном (образцом))
 
-Often, a simple `if`/`else` isn’t enough, because you have more than two
-possible options. Also, `else` conditions can get incredibly complicated, so
-what’s the solution?
+Простого `if`/`else` часто недостаточно, потому что нужно проверить больше, чем
+два возможных варианта. Да и к тому же условия в `else` часто становятся очень
+сложными. Как же решить эту проблему?
 
-Rust has a keyword, `match`, that allows you to replace complicated `if`/`else`
-groupings with something more powerful. Check it out:
+В Rust есть ключевое слово `match`, позволяющее заменить группы операторов
+`if`/`else` чем-то более удобным. Смотрите:
 
-```rust
+```{rust}
 let x = 5;
 
 match x {
-    1 => println!("one"),
-    2 => println!("two"),
-    3 => println!("three"),
-    4 => println!("four"),
-    5 => println!("five"),
-    _ => println!("something else"),
+    1 => println!("один"),
+    2 => println!("два"),
+    3 => println!("три"),
+    4 => println!("четыре"),
+    5 => println!("пять"),
+    _ => println!("что-то ещё"),
 }
 ```
 
-`match` takes an expression and then branches based on its value. Each *arm* of
-the branch is of the form `val => expression`. When the value matches, that arm’s
-expression will be evaluated. It’s called `match` because of the term ‘pattern
-matching’, which `match` is an implementation of. There’s an [entire section on
-patterns][patterns] coming up next, that covers all the options that fit here.
+`match` принимает выражение и выбирает одну из ветвей исполнения согласно его
+значению. Каждая *ветвь* имеет форму `значение => выражение`. Выражение ветви
+вычисляется, когда значение данной ветви совпадает со значением, принятым
+оператором `match` (в данном случае, `x`). Эта конструкция называется `match`
+(сопоставление), потому что она выполняет сопоставление значения неким
+"образцам".
 
-[patterns]: patterns.html
-
-So what’s the big advantage here? Well, there are a few. First of all, `match`
-enforces *exhaustiveness checking*. Do you see that last arm, the one with the
-underscore (`_`)? If we remove that arm, Rust will give us an error:
+Так в чём же преимущества данной конструкции? Их несколько. Во-первых, ветви
+`match` *проверяются на полноту*. Видите последнюю ветвь, со знаком
+подчёркивания (`_`)? Если мы удалим её, Rust выдаст ошибку:
 
 ```text
 error: non-exhaustive patterns: `_` not covered
 ```
 
-In other words, Rust is trying to tell us we forgot a value. Because `x` is an
-integer, Rust knows that it can have a number of different values – for example,
-`6`. Without the `_`, however, there is no arm that could match, and so Rust refuses
-to compile. `_` acts like a ‘catch-all arm’. If none of the other arms match,
-the arm with `_` will, and since we have this catch-all arm, we now have an arm
-for every possible value of `x`, and so our program will compile successfully.
+Другими словами, компилятор сообщает нам, что мы забыли сопоставить какие-то
+значения. Поскольку `x` - это целое число, оно может принимать разные значения -
+например, `6`. Однако, если мы убираем ветвь `_`, ни одна ветвь не совпадёт,
+поэтому такой код не скомпилируется. `_` - это *совпадение с любым значением*.
+Если ни одна другая ветвь не совпала, совпадёт ветвь с `_`. Поскольку в примере
+выше есть ветвь с `_`, мы покрываем всё множество значений `x`, и наша программа
+скомпилируется.
 
-`match` is also an expression, which means we can use it on the right-hand
-side of a `let` binding or directly where an expression is used:
+Оператор `match` также осуществляет разбор перечислений. Помните этот код из
+раздела про перечисления?
 
-```rust
-let x = 5;
+```{rust}
+use std::cmp::Ordering;
 
-let numer = match x {
-    1 => "one",
-    2 => "two",
-    3 => "three",
-    4 => "four",
-    5 => "five",
-    _ => "something else",
-};
+fn cmp(a: i32, b: i32) -> Ordering {
+    if a < b { Ordering::Less }
+    else if a > b { Ordering::Greater }
+    else { Ordering::Equal }
+}
+
+fn main() {
+    let x = 5;
+    let y = 10;
+
+    let ordering = cmp(x, y);
+
+    if ordering == Ordering::Less {
+        println!("меньше");
+    } else if ordering == Ordering::Greater {
+        println!("больше");
+    } else if ordering == Ordering::Equal {
+        println!("равно");
+    }
+}
 ```
 
-Sometimes, it’s a nice way of converting things.
+Мы можем переписать его с использованием `match`:
+
+```{rust}
+use std::cmp::Ordering;
+
+fn cmp(a: i32, b: i32) -> Ordering {
+    if a < b { Ordering::Less }
+    else if a > b { Ordering::Greater }
+    else { Ordering::Equal }
+}
+
+fn main() {
+    let x = 5;
+    let y = 10;
+
+    match cmp(x, y) {
+        Ordering::Less => println!("меньше"),
+        Ordering::Greater => println!("больше"),
+        Ordering::Equal => println!("равно"),
+    }
+}
+```
+
+Такой код не только чище, но и проверяет полноту сопоставления вариантов
+перечисления `Ordering`. Если бы мы забыли случай `Greater` в примере с
+`if`/`else`, наша программа всё равно скомпилировалась бы. А вот если мы забудем
+сопоставить вариант перечисления в операторе `match`, то компилятор выдаст
+ошибку. Rust помогает нам удостовериться, что перечисление обрабатывается верно.
+
+Оператор `match` также позволяет извлекать значения, содержащихся в
+перечислении. Это по-другому называется "деконструкцией" или "разбором".
+
+```{rust}
+enum OptionalInt {
+    Value(i32),
+    Missing,
+}
+
+fn main() {
+    let x = OptionalInt::Value(5);
+    let y = OptionalInt::Missing;
+
+    match x {
+        OptionalInt::Value(n) => println!("x равен {}", n),
+        OptionalInt::Missing => println!("x отсутствует!"),
+    }
+
+    match y {
+        OptionalInt::Value(n) => println!("y равен {}", n),
+        OptionalInt::Missing => println!("y отсутствует!"),
+    }
+}
+```
+
+Вот так вы можете получить и использовать значения из перечислений. Это также
+позволяет нам организовать обработку ошибок или непредвиденных ситуаций.
+Например, функция, которая не всегда может вычислить результат (в данном случае
+типа `i32`), может возвращать `OptionalInt`. Такое значение затем можно
+обработать с помощью `match`. Как вы можете видеть, `enum` и `match` отлично
+дополняют друг друга!
+
+`match` также является выражением. Это значит, что мы можем использовать его в
+правой части оператора `let` или прямо как результат. Мы могли бы реализовать
+предыдущий пример так:
+
+```{rust}
+use std::cmp::Ordering;
+
+fn cmp(a: i32, b: i32) -> Ordering {
+    if a < b { Ordering::Less }
+    else if a > b { Ordering::Greater }
+    else { Ordering::Equal }
+}
+
+fn main() {
+    let x = 5;
+    let y = 10;
+
+    println!("{}", match cmp(x, y) {
+        Ordering::Less => "меньше",
+        Ordering::Greater => "больше",
+        Ordering::Equal => "равно",
+    });
+}
+```
+
+Иногда это очень удобно.
