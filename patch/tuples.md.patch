diff --git a/rust/master:src/doc/trpl/tuples.md b/HEAD:tuples.md
index dd526d0..e293168 100644
--- a/rust/master:src/doc/trpl/tuples.md
+++ b/HEAD:tuples.md
@@ -1,97 +1,102 @@
-% Tuples
+% Кортежи
 
-The first compound data type we're going to talk about is called the *tuple*.
-A tuple is an ordered list of fixed size. Like this:
+Первый агрегатный тип данных, о котором мы поговорим - это *кортеж*. Кортеж -
+это упорядоченный список фиксированного размера. Вроде такого:
 
 ```rust
-let x = (1, "hello");
+let x = (1, "привет");
 ```
 
-The parentheses and commas form this two-length tuple. Here's the same code, but
-with the type annotated:
+Этот кортеж из двух элементов создан с помощью скобок и запятой между
+элементами. Вот тот же код, но с аннотациями типов:
 
 ```rust
-let x: (i32, &str) = (1, "hello");
+let x: (i32, &str) = (1, "привет");
 ```
 
-As you can see, the type of a tuple looks just like the tuple, but with each
-position having a type name rather than the value. Careful readers will also
-note that tuples are heterogeneous: we have an `i32` and a `&str` in this tuple.
-You have briefly seen `&str` used as a type before, and we'll discuss the
-details of strings later. In systems programming languages, strings are a bit
-more complex than in other languages. For now, just read `&str` as a *string
-slice*, and we'll learn more soon.
+Как вы можете видеть, тип кортежа выглядит как сам кортеж, но места элементов
+занимают типы. Внимательные читатели также отметят, что кортежи гетерогенны: в
+этом кортеже одновременно хранятся значения типов `i32` и `&str`. Мы уже
+встречали тип `&str` ранее, и мы обсудим строки подробнее далее. В языках
+системного программирования строки немного более сложны, чем в других языках.
+Пока вы можете читать `&str` как *срез строки*. Мы вскоре узнаем об этом больше.
 
-You can access the fields in a tuple through a *destructuring let*. Here's
-an example:
+Доступ к полям кортежа можно получить с помощью *деконструирующего let*. Вот
+пример:
 
 ```rust
 let (x, y, z) = (1, 2, 3);
 
-println!("x is {}", x);
+println!("x это {}", x);
 ```
 
-Remember before when I said the left-hand side of a `let` statement was more
-powerful than just assigning a binding? Here we are. We can put a pattern on
-the left-hand side of the `let`, and if it matches up to the right-hand side,
-we can assign multiple bindings at once. In this case, `let` "destructures,"
-or "breaks up," the tuple, and assigns the bits to three bindings.
+Помните, я говорил, что левая часть оператора `let` более полезна, чем просто
+присваивание имени? Об этом я и говорил. Мы можем написать слева от `let`
+образец, и, если он совпадает со значением справа, произойдёт присваивание имён
+сразу нескольким значениям. В данном случае, `let` "деконструирует" или
+"разбивает" кортеж, и присваивает его части трём именам.
 
-This pattern is very powerful, and we'll see it repeated more later.
+Это очень удобный шаблон программирования, и мы ещё не раз увидим его.
 
-There are also a few things you can do with a tuple as a whole, without
-destructuring. You can assign one tuple into another, if they have the same
-contained types and [arity]. Tuples have the same arity when they have the same
-length.
+Некоторые вещи можно делать с кортежами как с единым целым, без разбиения. Можно
+присваивать один кортеж другому, если они содержат значения одинаковых типов и
+имеют одинаковую [арность][arity]. Арность кортежей одинакова, когда их длина
+совпадает.
 
 ```rust
 let mut x = (1, 2); // x: (i32, i32)
 let y = (2, 3); // y: (i32, i32)
 
 x = y;
 ```
 
-You can also check for equality with `==`. Again, this will only compile if the
-tuples have the same type.
+Вы также можете проверять кортежи на равенство с помощью операции `==`. Опять-
+таки, это скомпилируется только если кортежи имеют одинаковые типы.
 
 ```rust
 let x = (1, 2, 3);
 let y = (2, 2, 4);
 
 if x == y {
-    println!("yes");
+    println!("да");
 } else {
-    println!("no");
+    println!("нет");
 }
 ```
 
-This will print `no`, because some of the values aren't equal.
+Этот код напечатает `нет`, потому что некоторые элементы не равны.
 
-Note that the order of the values is considered when checking for equality,
-so the following example will also print `no`.
+Заметьте, что порядок элементов важен при сравнении кортежей, поэтому в
+следующем примере код также напечатает `нет`.
 
 ```rust
 let x = (1, 2, 3);
 let y = (2, 1, 3);
 
 if x == y {
-    println!("yes");
+    println!("да");
 } else {
-    println!("no");
+    println!("нет");
 }
 ```
 
-One other use of tuples is to return multiple values from a function:
+Другой способ использовать кортежи - это возврат множества значений из функции:
 
 ```rust
 fn next_two(x: i32) -> (i32, i32) { (x + 1, x + 2) }
 
 fn main() {
     let (x, y) = next_two(5);
     println!("x, y = {}, {}", x, y);
 }
 ```
 
-Even though Rust functions can only return one value, a tuple *is* one value,
-that happens to be made up of more than one value. You can also see in this
-example how you can destructure a pattern returned by a function, as well.
+Несмотря на то, что функции в Rust могут возвращать только одно значение, в
+данном случае это не помеха. Кортеж - это *одно* значение, которое состоит из
+нескольких. В этом примере вы также можете видеть пример разбиения кортежа,
+возвращаемого функцией.
+
+Кортежи - это очень простая структура данных, и часто они вам не подойдут.
+Давайте рассмотрим их старшего брата, структуры.
+
+[arity]: ./glossary.html#arity
