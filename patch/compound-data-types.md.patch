diff --git a/rust/master:src/doc/trpl/compound-data-types.md b/fix_current_version:compound-data-types.md
index e44d2ed..5c0d826 100644
--- a/rust/master:src/doc/trpl/compound-data-types.md
+++ b/fix_current_version:compound-data-types.md
@@ -1,54 +1,53 @@
-% Compound Data Types
+% Агрегатные типы данных
 
-Rust, like many programming languages, has a number of different data types
-that are built-in. You've already done some simple work with integers and
-strings, but next, let's talk about some more complicated ways of storing data.
+Как и во многих других языках программирования, в Rust есть несколько встроенных
+типов данных. Вы уже работали с целыми числами и строками, а теперь мы поговорим
+о более сложных способах хранения данных.
 
-## Tuples
+## Кортежи
 
-The first compound data type we're going to talk about is called the *tuple*.
-A tuple is an ordered list of fixed size. Like this:
+Первый агрегатный тип данных, о котором мы поговорим - это *кортеж*. Кортеж -
+это упорядоченный список фиксированного размера. Вроде такого:
 
 ```rust
-let x = (1, "hello");
+let x = (1, "привет");
 ```
 
-The parentheses and commas form this two-length tuple. Here's the same code, but
-with the type annotated:
+Этот кортеж из двух элементов создан с помощью скобок и запятой между элементами.
+Вот тот же код, но с аннотациями типов:
 
 ```rust
-let x: (i32, &str) = (1, "hello");
+let x: (i32, &str) = (1, "привет");
 ```
 
-As you can see, the type of a tuple looks just like the tuple, but with each
-position having a type name rather than the value. Careful readers will also
-note that tuples are heterogeneous: we have an `i32` and a `&str` in this tuple.
-You have briefly seen `&str` used as a type before, and we'll discuss the
-details of strings later. In systems programming languages, strings are a bit
-more complex than in other languages. For now, just read `&str` as a *string
-slice*, and we'll learn more soon.
+Как вы можете видеть, тип кортежа выглядит как сам кортеж, но места элементов
+занимают типы. Внимательные читатели также отметят, что кортежи гетерогенны:
+в этом кортеже одновременно хранятся значения типов `i32` и `&str`. Мы уже
+встречали тип `&str` ранее, и мы обсудим строки подробнее далее. В языках
+системного программирования строки немного более сложны, чем в других языках.
+Пока вы можете читать `&str` как *срез строки*. Мы вскоре узнаем об этом больше.
 
-You can access the fields in a tuple through a *destructuring let*. Here's
-an example:
+Доступ к полям кортежа можно получить с помощью *деконструирующего let*.
+Вот пример:
 
 ```rust
 let (x, y, z) = (1, 2, 3);
 
-println!("x is {}", x);
+println!("x это {}", x);
 ```
 
-Remember before when I said the left-hand side of a `let` statement was more
-powerful than just assigning a binding? Here we are. We can put a pattern on
-the left-hand side of the `let`, and if it matches up to the right-hand side,
-we can assign multiple bindings at once. In this case, `let` "destructures,"
-or "breaks up," the tuple, and assigns the bits to three bindings.
+Помните, я говорил, что левая часть оператора `let` более полезна, чем
+просто присваивание имени? Об этом я и говорил. Мы можем написать слева от `let`
+образец, и, если он совпадает со значением справа, произойдёт присваивание
+имён сразу нескольким значениям. В данном случае, `let` "деконструирует" или
+"разбивает" кортеж, и присваивает его части трём именам.
 
-This pattern is very powerful, and we'll see it repeated more later.
+Это очень удобный шаблон программирования, и мы ещё не раз увидим его.
 
-There are also a few things you can do with a tuple as a whole, without
-destructuring. You can assign one tuple into another, if they have the same
-contained types and [arity]. Tuples have the same arity when they have the same
-length.
+Некоторые вещи можно делать с кортежами как с единым целым, без разбиения.
+Можно присваивать один кортеж другому, если они содержат значения одинаковых
+типов и имеют одинаковую [арность][arity]. Арность кортежей одинакова, когда их длина
+совпадает.
 
 ```rust
 let mut x = (1, 2); // x: (i32, i32)
@@ -57,37 +56,37 @@ let y = (2, 3); // y: (i32, i32)
 x = y;
 ```
 
-You can also check for equality with `==`. Again, this will only compile if the
-tuples have the same type.
+Вы также можете проверять кортежи на равенство с помощью операции `==`.
+Опять-таки, это скомпилируется только если кортежи имеют одинаковые типы.
 
 ```rust
 let x = (1, 2, 3);
 let y = (2, 2, 4);
 
 if x == y {
-    println!("yes");
+    println!("да");
 } else {
-    println!("no");
+    println!("нет");
 }
 ```
 
-This will print `no`, because some of the values aren't equal.
+Этот код напечатает `нет`, потому что некоторые элементы не равны.
 
-Note that the order of the values is considered when checking for equality,
-so the following example will also print `no`.
+Заметьте, что порядок элементов важен при сравнении кортежей, поэтому
+в следующем примере код также напечатает `нет`.
 
 ```rust
 let x = (1, 2, 3);
 let y = (2, 1, 3);
 
 if x == y {
-    println!("yes");
+    println!("да");
 } else {
-    println!("no");
+    println!("нет");
 }
 ```
 
-One other use of tuples is to return multiple values from a function:
+Другой способ использовать кортежи - это возврат множества значений из функции:
 
 ```rust
 fn next_two(x: i32) -> (i32, i32) { (x + 1, x + 2) }
@@ -98,18 +97,19 @@ fn main() {
 }
 ```
 
-Even though Rust functions can only return one value, a tuple *is* one value,
-that happens to be made up of more than one value. You can also see in this
-example how you can destructure a pattern returned by a function, as well.
+Несмотря на то, что функции в Rust могут возвращать только одно значение,
+в данном случае это не помеха. Кортеж - это *одно* значение, которое состоит
+из нескольких. В этом примере вы также можете видеть пример разбиения кортежа,
+возвращаемого функцией.
 
-Tuples are a very simple data structure, and so are not often what you want.
-Let's move on to their bigger sibling, structs.
+Кортежи - это очень простая структура данных, и часто они вам не подойдут.
+Давайте рассмотрим их старшего брата, структуры.
 
-## Structs
+## Структуры
 
-A struct is another form of a *record type*, just like a tuple. There's a
-difference: structs give each element that they contain a name, called a
-*field* or a *member*. Check it out:
+Структура - это другой вид *агрегатного типа*, как и кортеж. Разница в том, что
+в структурах у каждого элемента есть имя. Элемент структуры называется *полем*
+или *членом структуры*. Смотрите:
 
 ```rust
 struct Point {
@@ -120,23 +120,27 @@ struct Point {
 fn main() {
     let origin = Point { x: 0, y: 0 }; // origin: Point
 
-    println!("The origin is at ({}, {})", origin.x, origin.y);
+    println!("Начало координат находится в ({}, {})", origin.x, origin.y);
 }
 ```
 
-There's a lot going on here, so let's break it down. We declare a struct with
-the `struct` keyword, and then with a name. By convention, structs begin with a
-capital letter and are also camel cased: `PointInSpace`, not `Point_In_Space`.
+Этот код делает много разных вещей, поэтому давайте разберём его по порядку.
+Мы объявляем структуру с помощью ключевого слова `struct`, за которым следует
+имя объявляемой структуры. Обычно, имена типов-структур начинаются с
+заглавной буквы и используют чередующийся регистр букв: название `PointInSpace`
+выглядит привычно, а `Point_In_Space` - нет.
 
-We can create an instance of our struct via `let`, as usual, but we use a `key:
-value` style syntax to set each field. The order doesn't need to be the same as
-in the original declaration.
+Как всегда, мы можем создать экземпляр нашей структуры с помощью оператора `let`.
+Однако в данном случае мы используем синтаксис вида `ключ: значение` для
+установки значения каждого поля. Порядок инициализации полей не обязательно
+должен совпадать с порядком их объявления.
 
-Finally, because fields have names, we can access the field through dot
-notation: `origin.x`.
+Наконец, поскольку у полей есть имена, мы можем получить поле с помощью операции
+`точка`: `origin.x`.
 
-The values in structs are immutable by default, like other bindings in Rust.
-Use `mut` to make them mutable:
+Значения, хранимые в структурах, неизменяемы по умолчанию. В этом плане они не
+отличаются от других именованных сущностей. Чтобы они стали изменяемы,
+используйте ключевое слово `mut`:
 
 ```{rust}
 struct Point {
@@ -149,16 +153,17 @@ fn main() {
 
     point.x = 5;
 
-    println!("The point is at ({}, {})", point.x, point.y);
+    println!("Точка находится в ({}, {})", point.x, point.y);
 }
 ```
 
-This will print `The point is at (5, 0)`.
+Этот код напечатает `Точка находится в (5, 0)`.
 
-## Tuple Structs and Newtypes
+## Кортежные структуры и новые типы
 
-Rust has another data type that's like a hybrid between a tuple and a struct,
-called a *tuple struct*. Tuple structs do have a name, but their fields don't:
+В Rust есть ещё один тип данных, который представляет собой нечто среднее
+между кортежем и структурой. Он называется *кортежной структурой*. Кортежные
+структуры именуются, а вот у их полей имён нет:
 
 
 ```{rust}
@@ -166,7 +171,7 @@ struct Color(i32, i32, i32);
 struct Point(i32, i32, i32);
 ```
 
-These two will not be equal, even if they have the same values:
+Эти два объекта различны, несмотря на то, что у них одинаковые значения:
 
 ```{rust}
 # struct Color(i32, i32, i32);
@@ -175,8 +180,8 @@ let black = Color(0, 0, 0);
 let origin = Point(0, 0, 0);
 ```
 
-It is almost always better to use a struct than a tuple struct. We would write
-`Color` and `Point` like this instead:
+Почти всегда, вместо кортежной структуры лучше использовать обычную структуру.
+Мы бы скорее объявили типы `Color` и `Point` вот так:
 
 ```{rust}
 struct Color {
@@ -192,13 +197,14 @@ struct Point {
 }
 ```
 
-Now, we have actual names, rather than positions. Good names are important,
-and with a struct, we have actual names.
+Теперь у нас есть настоящие имена, а не только позиции. Хорошие имена важны,
+и при использовании структуры у нас есть эти имена.
 
-There _is_ one case when a tuple struct is very useful, though, and that's a
-tuple struct with only one element. We call this the *newtype* pattern, because
-it allows you to create a new type, distinct from that of its contained value
-and expressing its own semantic meaning:
+Однако, _есть_ один случай, когда кортежные структуры очень полезны. Это
+кортежная структура с всего одним элементом. Такое использование называется
+*новым типом*, потому что оно позволяет создать новый тип, отличный от типа
+значения, содержащегося в кортежной структуре. При этом новый тип обозначает
+что-то другое:
 
 ```{rust}
 struct Inches(i32);
@@ -206,21 +212,25 @@ struct Inches(i32);
 let length = Inches(10);
 
 let Inches(integer_length) = length;
-println!("length is {} inches", integer_length);
+println!("Длина в дюймах: {}", integer_length);
 ```
 
-As you can see here, you can extract the inner integer type through a
-destructuring `let`, as we discussed previously in 'tuples.' In this case, the
-`let Inches(integer_length)` assigns `10` to `integer_length`.
+Как вы можете видеть в данном примере, извлечь вложенный целый тип можно
+с помощью деконструирующего `let`. Мы обсуждали это выше, в разделе "кортежи".
+В данном случае, оператор `let Inches(integer_length)` присваивает `10`
+имени `integer_length`.
 
-## Enums
+## Перечисления
 
-Finally, Rust has a "sum type", an *enum*. Enums are an incredibly useful
-feature of Rust, and are used throughout the standard library. An `enum` is
-a type which relates a set of alternates to a specific name. For example, below
-we define `Character` to be either a `Digit` or something else. These
-can be used via their fully scoped names: `Character::Other` (more about `::`
-below).
+Наконец, в Rust есть "типы-суммы", или *перечисления* (тип-сумма - это термин
+из теории типов). Перечисления - это очень
+полезная возможность Rust, и они очень много используются в стандартной
+библиотеке языка. Они объявляются с помощью ключевого слова `enum`. `enum` - это
+тип, который соотносит набор неких вариантов одному имени. Например, ниже мы
+определяем перечисление `Character` (символ), представляющее собой или цифру
+(`Digit`), или что-то другое. Объявленные варианты можно использовать с помощью
+полностью квалифицированных имён, таких, как `Character::Other` (мы поговорим
+об операции `::` ниже).
 
 ```rust
 enum Character {
@@ -229,8 +239,8 @@ enum Character {
 }
 ```
 
-Most normal types are allowed as the variant components of an `enum`. Here are
-some examples:
+Б'ольшая часть обычных типов могут быть вариантами перечисления. Вот несколько
+примеров:
 
 ```rust
 struct Empty;
@@ -240,18 +250,21 @@ struct Status { Health: i32, Mana: i32, Attack: i32, Defense: i32 }
 struct HeightDatabase(Vec<i32>);
 ```
 
-You see that, depending on its type, an `enum` variant may or may not hold data.
-In `Character`, for instance, `Digit` gives a meaningful name for an `i32`
-value, where `Other` is only a name. However, the fact that they represent
-distinct categories of `Character` is a very useful property.
+Здесь мы видим, что, в зависимости от типа, вариант перечисления может
+содержать вложенные данные, а может и не иметь таковых. Например, в перечислении
+`Character` (символ), вариант `Digit` (цифра) даёт значимое имя числу типа
+`i32`. А вот вариант `Other` представляет собой лишь имя, без значения. Однако
+наиболее полезно именно то, что отдельные варианты представляют собой отдельные
+виды символов (`Character`).
 
-As with structures, the variants of an enum by default are not comparable with
-equality operators (`==`, `!=`), have no ordering (`<`, `>=`, etc.), and do not
-support other binary operations such as `*` and `+`. As such, the following code
-is invalid for the example `Character` type:
+Как и структуры, варианты перечислений по умолчанию не сравнимы операциями
+сравнения (`==`, `!=`), не упорядочены (не реализуют `<`, `>=` и другие) и не
+поддерживают другие двухместные операции, такие как умножение (`*`) и сложение
+(`+`). Нижеследующий код, как таковой, не верен (если мы используем приведённый
+выше тип-перечисление `Character`):
 
 ```{rust,ignore}
-// These assignments both succeed
+// Оба этих присваивания успешны
 let ten  = Character::Digit(10);
 let four = Character::Digit(4);
 
@@ -265,11 +278,13 @@ let four_is_smaller = four <= ten;
 let four_equals_ten = four == ten;
 ```
 
-This may seem rather limiting, but it's a limitation which we can overcome.
-There are two ways: by implementing equality ourselves, or by pattern matching
-variants with [`match`][match] expressions, which you'll learn in the next
-chapter. We don't know enough about Rust to implement equality yet, but we can
-use the `Ordering` enum from the standard library, which does:
+Наверное, это выглядит неудобным. Но мы можем преодолеть данное
+ограничение. Есть два способа сделать это: реализовать сравнение самим, или
+использовать сопоставление вариантов с образцом с помощью выражений
+[`match`][match]. Мы узнаем о них в следующей главе. Пока мы не имеем
+достаточных знаний Rust для реализации сравнения. Но мы можем использовать
+перечисление `Ordering` (порядок) из стандартной библиотеки, которое выглядит
+так:
 
 ```
 enum Ordering {
@@ -279,8 +294,8 @@ enum Ordering {
 }
 ```
 
-Because `Ordering` has already been defined for us, we will import it with the
-`use` keyword. Here's an example of how it is used:
+Поскольку перечисление `Ordering` уже определено, мы импортируем его с помощью
+ключевого слова `use`. Вот пример его использования:
 
 ```{rust}
 use std::cmp::Ordering;
@@ -298,33 +313,35 @@ fn main() {
     let ordering = cmp(x, y); // ordering: Ordering
 
     if ordering == Ordering::Less {
-        println!("less");
+        println!("меньше");
     } else if ordering == Ordering::Greater {
-        println!("greater");
+        println!("больше");
     } else if ordering == Ordering::Equal {
-        println!("equal");
+        println!("равно");
     }
 }
 ```
 
-The `::` symbol is used to indicate a namespace. In this case, `Ordering` lives
-in the `cmp` submodule of the `std` module. We'll talk more about modules later
-in the guide. For now, all you need to know is that you can `use` things from
-the standard library if you need them.
+Мы используем символ `::` для обозначения пространства имён. В данном случае,
+перечисление `Ordering` находится в под-модуле модуля `std`. Мы подробнее
+поговорим о модулях позже. Пока же достаточно знать, что вы можете использовать
+(`use`) вещи из стандартной библиотеки, если они вам понадобятся.
 
-Okay, let's talk about the actual code in the example. `cmp` is a function that
-compares two things, and returns an `Ordering`. We return either
-`Ordering::Less`, `Ordering::Greater`, or `Ordering::Equal`, depending on
-whether the first value is less than, greater than, or equal to the second. Note
-that each variant of the `enum` is namespaced under the `enum` itself: it's
-`Ordering::Greater`, not `Greater`.
+Отлично, теперь давайте поговорим о самом коде примера. `cmp` - это функция,
+которая сравнивает два объекта, и возвращает значение типа "порядок"
+(`Ordering`). Мы возвращаем одно из значений `Ordering::Less`,
+`Ordering::Greater` или `Ordering::Equal`, когда первое значение меньше,
+больше или равно второму, соответственно. Заметьте, что варианты перечисления
+находятся в пространстве имён самого перечисления: к нему нужно обращаться
+`Ordering::Greater`, а не `Greater`.
 
-The `ordering` variable has the type `Ordering`, and so contains one of the
-three values. We then do a bunch of `if`/`else` comparisons to check which
-one it is.
+Переменная `ordering` имеет тип `Ordering`, и содержит одно из трёх значений.
+Затем мы делаем несколько сравнений с помощью `if`/`else`, чтобы проверить,
+какое из значений мы получили.
 
-This `Ordering::Greater` notation is too long. Let's use another form of `use`
-to import the `enum` variants instead. This will avoid full scoping:
+Запись `Ordering::Greater` неудобна из-за своей длины. Давайте используем другой
+вид оператора `use` и импортируем сами варианты перечисления. В таком коде
+не нужно полностью специфицировать имена вариантов:
 
 ```{rust}
 use std::cmp::Ordering::{self, Equal, Less, Greater};
@@ -341,22 +358,23 @@ fn main() {
 
     let ordering = cmp(x, y); // ordering: Ordering
 
-    if ordering == Less { println!("less"); }
-    else if ordering == Greater { println!("greater"); }
-    else if ordering == Equal { println!("equal"); }
+    if ordering == Less { println!("меньше"); }
+    else if ordering == Greater { println!("больше"); }
+    else if ordering == Equal { println!("равно"); }
 }
 ```
 
-Importing variants is convenient and compact, but can also cause name conflicts,
-so do this with caution. For this reason, it's normally considered better style
-to `use` an enum rather than its variants directly.
-
-As you can see, `enum`s are quite a powerful tool for data representation, and
-are even more useful when they're [generic][generics] across types. Before we
-get to generics, though, let's talk about how to use enums with pattern
-matching, a tool that will let us deconstruct sum types (the type theory term
-for enums) like `Ordering` in a very elegant way that avoids all these messy
-and brittle `if`/`else`s.
+Импорт вариантов удобен и компактен, но он может вызывать конфликты имён,
+поэтому будьте осторожны при его использовании. Обычно стилистически лучше
+импортировать перечисление, а не его варианты.
+
+Как видите, перечисления довольно удобны, и особенно полезны когда они
+[обобщены][generics] относительно вложенных в них типов. Однако, прежде чем
+мы перейдём к рассмотрению обобщённых типов, давайте поговорим об использовании
+перечислений при сопоставлении с образцом. Сопоставление с образцом - это
+инструмент, позволяющий нам элегантно разбирать типы-суммы вроде `Ordering`.
+Данная техника позволит нам избежать всех этих хрупких сравнений с помощью
+`if`/`else`.
 
 
 [arity]: ./glossary.html#arity
