diff --git a/rust/master:src/doc/trpl/macros.md b/fix_current_version:macros.md
index 7da3604..d877b14 100644
--- a/rust/master:src/doc/trpl/macros.md
+++ b/fix_current_version:macros.md
@@ -1,37 +1,18 @@
-% Macros
+% Макросы (ВНИМАНИЕ перевод в черновом варианте!)
 
-By now you've learned about many of the tools Rust provides for abstracting and
-reusing code. These units of code reuse have a rich semantic structure. For
-example, functions have a type signature, type parameters have trait bounds,
-and overloaded functions must belong to a particular trait.
+К этому моменту вы узнали о многих инструментах Rust, которые нацелены на абстрагирование и повторное использование кода. Эти единицы повторно использованного кода имеют богатую смысловую структуру. Например, функции имеют сигнатуры типа, типы параметров могут имеют ограничения по трейтам, перегруженные функции также могут принадлежать к определенному трейту.
 
-This structure means that Rust's core abstractions have powerful compile-time
-correctness checking. But this comes at the price of reduced flexibility. If
-you visually identify a pattern of repeated code, you may find it's difficult
-or cumbersome to express that pattern as a generic function, a trait, or
-anything else within Rust's semantics.
+Эта структура означает, что ключевые абстракции Rust имеют мощный механизм проверки времени компиляции. Но это достигается за счет снижения гибкости. Если вы визуально определите структуру повторно используемого кода, то вы можете найти трудным или громоздким выражение этой схемы в виде дженерик функции, трейта, или чего-то еще в семантике Rust.
 
-Macros allow us to abstract at a *syntactic* level. A macro invocation is
-shorthand for an "expanded" syntactic form. This expansion happens early in
-compilation, before any static checking. As a result, macros can capture many
-patterns of code reuse that Rust's core abstractions cannot.
+Макросы позволяют абстрагироваться на *синтаксическом* уровне. Вызов макроса является сокращением для "расширенной" синтаксической формы. Это расширение происходит в начале компиляции, до начала статической проверки. В результате, макросы могут охватить много шаблонов повторного использования кода, которые невозможны при использовании лишь ключевых абстракций Rust.
 
-The drawback is that macro-based code can be harder to understand, because
-fewer of the built-in rules apply. Like an ordinary function, a well-behaved
-macro can be used without understanding its implementation. However, it can be
-difficult to design a well-behaved macro!  Additionally, compiler errors in
-macro code are harder to interpret, because they describe problems in the
-expanded code, not the source-level form that developers use.
+Недостатком является то, что код, основанный на макросах, может быть трудным для понимания, потому что к нему применяется меньше встроенных правил. Подобно обычной функции, качественный макрос может быть использован без понимания его реализации. Тем не менее, может быть трудно разработать качественный макрос! Кроме того, ошибки компилятора в макро коде сложнее интерпретировать, потому что они описывают проблемы в расширенной форме кода, а не в исходной сокращенной форме кода, которую используют разработчики.
 
-These drawbacks make macros something of a "feature of last resort". That's not
-to say that macros are bad; they are part of Rust because sometimes they're
-needed for truly concise, well-abstracted code. Just keep this tradeoff in
-mind.
+Эти недостатки делают макросы чем-то вроде "фичи последней инстанции". Это не означает, что макросы это плохо; они являются частью Rust, потому что иногда они все же нужны для по-настоящему краткой записи хорошо абстрагированной части кода. Просто имейте этот компромисс в виду.
 
-# Defining a macro
+# Определение макросов
 
-You may have seen the `vec!` macro, used to initialize a [vector][] with any
-number of elements.
+Вы, возможно, видели макрос `vec!`, который используется для инициализации [вектора][vector] с произвольным количеством элементов.
 
 [vector]: arrays-vectors-and-slices.html
 
@@ -40,8 +21,7 @@ let x: Vec<u32> = vec![1, 2, 3];
 # assert_eq!(&[1,2,3], &x);
 ```
 
-This can't be an ordinary function, because it takes any number of arguments.
-But we can imagine it as syntactic shorthand for
+Его нельзя реализовать в виде обычной функциии, так как он принимает любое количество аргументов. Но мы можем представить его в виде синтаксического сокращения для следующего кода
 
 ```rust
 let x: Vec<u32> = {
@@ -54,11 +34,9 @@ let x: Vec<u32> = {
 # assert_eq!(&[1,2,3], &x);
 ```
 
-We can implement this shorthand, using a macro: [^actual]
+Мы можем реализовать это сокращение, используя макрос: [^actual]
 
-[^actual]: The actual definition of `vec!` in libcollections differs from the
-           one presented here, for reasons of efficiency and reusability. Some
-           of these are mentioned in the [advanced macros chapter][].
+[^actual]: Фактическое определение `vec!` в libcollections отличается от представленной здесь по соображениям эффективности и повторного использования. Некоторые из них упомянуты в главе [продвинутые макросы][advanced macros chapter].
 
 ```rust
 macro_rules! vec {
@@ -77,41 +55,29 @@ macro_rules! vec {
 # }
 ```
 
-Whoa, that's a lot of new syntax! Let's break it down.
+Вау, тут много нового синтаксиса! Давайте разберем его.
 
 ```ignore
 macro_rules! vec { ... }
 ```
 
-This says we're defining a macro named `vec`, much as `fn vec` would define a
-function named `vec`. In prose, we informally write a macro's name with an
-exclamation point, e.g. `vec!`. The exclamation point is part of the invocation
-syntax and serves to distinguish a macro from an ordinary function.
+Тут мы определяем макрос с именем `vec`, аналогично тому, как `fn vec` определяло бы функцию с именем `vec`. При вызове мы неформально пишем имя макроса с восклицательным знаком, например, `vec!`. Восклицательный знак является частью синтаксиса вызова и служит для того, чтобы отличать макрос от обычной функции.
 
 ## Matching
 
-The macro is defined through a series of *rules*, which are pattern-matching
-cases. Above, we had
+Макрос определяется с помощью ряда *правил*, которые представляют собой варианты сопоставления с образцом. Выше у нас было
 
 ```ignore
 ( $( $x:expr ),* ) => { ... };
 ```
 
-This is like a `match` expression arm, but the matching happens on Rust syntax
-trees, at compile time. The semicolon is optional on the last (here, only)
-case. The "pattern" on the left-hand side of `=>` is known as a *matcher*.
-These have [their own little grammar] within the language.
+Это как вариант выражения `match`, но сопоставление происходит на уровне синтаксических деревьев Rust, на этапе компиляции. Точка с запятой не является обязательной для последнего (только здесь) варианта. "Шаблон" слева от `=>` известен как *шаблон совпадений* (*matcher*). Он имеет [свою собственную грамматику][their own little grammar] в рамках языка.
 
 [their own little grammar]: ../reference.html#macros
 
-The matcher `$x:expr` will match any Rust expression, binding that syntax tree
-to the *metavariable* `$x`. The identifier `expr` is a *fragment specifier*;
-the full possibilities are enumerated in the [advanced macros chapter][].
-Surrounding the matcher with `$(...),*` will match zero or more expressions,
-separated by commas.
+Шаблон `$x:expr` будет соответствовать любому выражению Rust, связывая его дерево синтаксиса с *метапеременной* `$x`. Идентификатор `expr` является *спецификатором фрагмента*; полные возможности перечислены в главе [продвинутые макросы][advanced macros chapter]. Шаблон, окруженный `$(...),*`, будет соответствовать нулю или более выражениям, разделенным запятыми.
 
-Aside from the special matcher syntax, any Rust tokens that appear in a matcher
-must match exactly. For example,
+Помимо специального синтаксиса шаблона совпадений, любые токены Rust, которые появляются в шаблоне должны в точности совпадать. Например,
 
 ```rust
 macro_rules! foo {
@@ -124,29 +90,30 @@ fn main() {
 }
 ```
 
-will print
+выведет
 
 ```text
 mode Y: 3
 ```
 
-With
+А с
 
 ```rust,ignore
 foo!(z => 3);
 ```
 
-we get the compiler error
+мы получим ошибку компиляции
 
 ```text
 error: no rules expected the token `z`
 ```
 
-## Expansion
+## Раскрытие
 
 The right-hand side of a macro rule is ordinary Rust syntax, for the most part.
 But we can splice in bits of syntax captured by the matcher. From the original
 example:
+С правой стороны макро правил используется, по большей части, обычный синтаксис Rust. Но мы можем соединить кусочки синтаксиса, захваченные шаблоном. Из предыдущего примера:
 
 ```ignore
 $(
@@ -157,14 +124,15 @@ $(
 Each matched expression `$x` will produce a single `push` statement in the
 macro expansion. The repetition in the expansion proceeds in "lockstep" with
 repetition in the matcher (more on this in a moment).
+Каждое соответствие выражению `$x` будет производить одиночный оператор `push` в раскрытой форме макроса. Повторение в расширение происходит в "ногу" с повторением в шаблоне совпадений (более подробно об этом чуть позже).
 
 Because `$x` was already declared as matching an expression, we don't repeat
 `:expr` on the right-hand side. Also, we don't include a separating comma as
 part of the repetition operator. Instead, we have a terminating semicolon
 within the repeated block.
+Поскольку `$x` уже объявлен как шаблонное выражение, мы не повторяем `:expr` с правой стороны. Кроме того, мы не включаем разделительную запятую в качестве части оператора повторения. Вместо этого, у нас есть точка с запятой в пределах повторяемого блока.
 
-Another detail: the `vec!` macro has *two* pairs of braces on the right-hand
-side. They are often combined like so:
+Еще одна деталь: макрос `vec!` имеет *две* пары фигурных скобках правой части. Они часто сочетаются таким образом:
 
 ```ignore
 macro_rules! foo {
@@ -174,30 +142,30 @@ macro_rules! foo {
 }
 ```
 
-The outer braces are part of the syntax of `macro_rules!`. In fact, you can use
-`()` or `[]` instead. They simply delimit the right-hand side as a whole.
+Внешние скобки являются частью синтаксиса `macro_rules!`. На самом деле, вы можете использовать `()` или `[]` вместо них. Они просто разграничивают правую часть в целом.
 
-The inner braces are part of the expanded syntax. Remember, the `vec!` macro is
-used in an expression context. To write an expression with multiple statements,
-including `let`-bindings, we use a block. If your macro expands to a single
-expression, you don't need this extra layer of braces.
+Внутренние скобки являются частью расширенного синтаксиса. Помните, что макрос `vec!` используется в контексте выражения. Мы используем блок, чтобы записать выражение с множественными состояниями, в том числе включающее `let` привязки. Если ваш макрос раскрывается в одно единственное выражение, то дополнительной слой скобок не нужен.
 
 Note that we never *declared* that the macro produces an expression. In fact,
 this is not determined until we use the macro as an expression. With care, you
 can write a macro whose expansion works in several contexts. For example,
 shorthand for a data type could be valid as either an expression or a pattern.
+Обратите внимание, что мы никогда не *говорили*, что макрос создает выражения. На самом деле, это не определяется, пока мы не использовать макрос как выражение. С осторожностью, вы можете написать макрос, разложение которого работает в нескольких контекстах. Например, сокращение для типа данных может быть действительным или как выражение или рисунком.
 
 ## Repetition
 
-The repetition operator follows two principal rules:
+Оператору повтора всегда сопутствуют два основных правила:
 
 1. `$(...)*` walks through one "layer" of repetitions, for all of the `$name`s
    it contains, in lockstep, and
 2. each `$name` must be under at least as many `$(...)*`s as it was matched
    against. If it is under more, it'll be duplicated, as appropriate.
+1. `$(...)*` проходит через один "слой" повторений, для всех `$name`, которые он содержит, в ногу, и
+2. каждое `$name` должно быть под крайней мере, столько `$(...)*`, как это было сопоставляется. Если это в более, это будет дублироваться, при необходимости.
 
 This baroque macro illustrates the duplication of variables from outer
 repetition levels.
+Этот причудливый макрос иллюстрирует дублирования переменных из внешних уровней повторения.
 
 ```rust
 macro_rules! o_O {
@@ -226,13 +194,11 @@ except `+` or `*`.
 
 This system is based on
 "[Macro-by-Example](http://www.cs.indiana.edu/ftp/techreports/TR206.pdf)"
-(PDF link).
+(PDF ссылка).
 
-# Hygiene
+# Гигиена (Hygiene)
 
-Some languages implement macros using simple text substitution, which leads to
-various problems. For example, this C program prints `13` instead of the
-expected `25`.
+Некоторые языки реализуют макросы с помощью простой текстовой замены, что приводит к различным проблемам. Например, нижеприведенная C программа напечатает `13` вместо ожидаемого `25`.
 
 ```text
 #define FIVE_TIMES(x) 5 * x
@@ -243,10 +209,7 @@ int main() {
 }
 ```
 
-After expansion we have `5 * 2 + 3`, and multiplication has greater precedence
-than addition. If you've used C macros a lot, you probably know the standard
-idioms for avoiding this problem, as well as five or six others. In Rust, we
-don't have to worry about it.
+После раскрытия мы получаем `5 * 2 + 3`, но умножение имеет больший приоритет чем сложение. Если вы часто использовали C макросы, вы, наверное, знаете стандартные идиомы для устранения этой проблемы, а также пять или шесть других проблем. В Rust мы не должны беспокоиться об этом.
 
 ```rust
 macro_rules! five_times {
@@ -258,11 +221,9 @@ fn main() {
 }
 ```
 
-The metavariable `$x` is parsed as a single expression node, and keeps its
-place in the syntax tree even after substitution.
+Метапеременная `$x` обрабатывается как единый узел выражения, и сохраняет свое место в дереве синтаксиса даже после замены.
 
-Another common problem in macro systems is *variable capture*. Here's a C
-macro, using [a GNU C extension] to emulate Rust's expression blocks.
+Другой распространенной проблемой в системе макросов является *захват переменной*. Вот C макрос, использующий [GNU C расширение], который эмулирует блоки выражениий в Rust.
 
 [a GNU C extension]: https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html
 
@@ -275,6 +236,7 @@ macro, using [a GNU C extension] to emulate Rust's expression blocks.
 })
 ```
 
+Вот простой случай использования, что идет ужасно неправильно:
 Here's a simple use case that goes terribly wrong:
 
 ```text
@@ -282,7 +244,7 @@ const char *state = "reticulating splines";
 LOG(state)
 ```
 
-This expands to
+Он раскрывается в
 
 ```text
 const char *state = "reticulating splines";
@@ -292,10 +254,9 @@ if (state > 0) {
 }
 ```
 
-The second variable named `state` shadows the first one.  This is a problem
-because the print statement should refer to both of them.
+Вторая переменная с именем `state` затеняет первую. Это проблема, потому что команде печати требуется обращаться к ним обоим.
 
-The equivalent Rust macro has the desired behavior.
+Эквивалентный макрос в Rust обладает требуемым поведением.
 
 ```rust
 # fn get_log_state() -> i32 { 3 }
@@ -314,13 +275,11 @@ fn main() {
 }
 ```
 
-This works because Rust has a [hygienic macro system][]. Each macro expansion
-happens in a distinct *syntax context*, and each variable is tagged with the
-syntax context where it was introduced. It's as though the variable `state`
-inside `main` is painted a different "color" from the variable `state` inside
-the macro, and therefore they don't conflict.
+Это работает, потому что Rust имеет [систему макросов с соблюдением гигиены]. Раскрытие каждого макроса происходит в отдельном *контексте синтаксиса*, и каждая переменная обладает меткой контекста синтаксиса, где она была введена. Это как если бы переменная `state` внутри `main` была бы окрашена в другой "цвет" в отличае от переменной `state` внутри макроса, из-за чего они бы не конфликтовали.
 
-[hygienic macro system]: http://en.wikipedia.org/wiki/Hygienic_macro
+[систему макросов с соблюдением гигиены]: http://en.wikipedia.org/wiki/Hygienic_macro
+
+Это также ограничивает возможности макросов для внедрения новых привязок на вызова сайте. Код, приведенный ниже, не будет работать:
 
 This also restricts the ability of macros to introduce new bindings at the
 invocation site. Code such as the following will not work:
@@ -336,8 +295,7 @@ fn main() {
 }
 ```
 
-Instead you need to pass the variable name into the invocation, so it's tagged
-with the right syntax context.
+Вместо этого вы должны передавать имя переменной при вызове, тогда она будет обладать меткой правильного контекста синтаксиса.
 
 ```rust
 macro_rules! foo {
@@ -350,8 +308,7 @@ fn main() {
 }
 ```
 
-This holds for `let` bindings and loop labels, but not for [items][].
-So the following code does compile:
+Это справедливо для `let` привязок и меток loop, но не для [элементов][]. Код, приведенный ниже, компилируется:
 
 ```rust
 macro_rules! foo {
@@ -364,14 +321,15 @@ fn main() {
 }
 ```
 
-[items]: ../reference.html#items
+[элементов]: ../reference.html#items
 
-# Recursive macros
+# Рекурсия макросов
 
 A macro's expansion can include more macro invocations, including invocations
 of the very same macro being expanded.  These recursive macros are useful for
 processing tree-structured input, as illustrated by this (simplistic) HTML
 shorthand:
+Раскрытие макроса также может включать в себя вызовы макросов, в том числе вызовы того макроса, который раскрывается. Эти рекурсивные макросы могут быть использованы для обработки древовидного ввода, как показано на этом (упрощенном) HTML сокращение:
 
 ```rust
 # #![allow(unused_must_use)]
