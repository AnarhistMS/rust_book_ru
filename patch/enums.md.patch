diff --git a/rust/master:./src/doc/trpl/enums.md b/HEAD:./syntax-and-semantics/enums.md
index 01905ca..63c00a6 100644
--- a/rust/master:./src/doc/trpl/enums.md
+++ b/HEAD:./syntax-and-semantics/enums.md
@@ -1,66 +1,77 @@
-% Enums
+% Перечисления
 
-An `enum` in Rust is a type that represents data that could be one of
-several possible variants:
+В Rust есть "типы-суммы", или *перечисления* (тип-сумма - это термин из теории
+типов). Перечисления - это очень полезная возможность Rust, и они очень много
+используются в стандартной библиотеке языка. Они объявляются с помощью ключевого
+слова `enum`. `enum` - это тип, который соотносит набор неких вариантов одному
+имени. Например, ниже мы определяем перечисление `Character` (символ),
+представляющее собой или цифру (`Digit`), или что-то другое.
 
 ```rust
-enum Message {
-    Quit,
-    ChangeColor(i32, i32, i32),
-    Move { x: i32, y: i32 },
-    Write(String),
+enum Character {
+    Digit(i32),
+    Other,
 }
 ```
 
-Each variant can optionally have data associated with it. The syntax for
-defining variants resembles the syntaxes used to define structs: you can
-have variants with no data (like unit-like structs), variants with named
-data, and variants with unnamed data (like tuple structs). Unlike
-separate struct definitions, however, an `enum` is a single type. A
-value of the enum can match any of the variants. For this reason, an
-enum is sometimes called a ‘sum type’: the set of possible values of the
-enum is the sum of the sets of possible values for each variant.
-
-We use the `::` syntax to use the name of each variant: they’re scoped by the name
-of the `enum` itself. This allows both of these to work:
+Большая часть обычных типов могут быть вариантами перечисления. Вот несколько
+примеров:
 
 ```rust
-# enum Message {
-#     Move { x: i32, y: i32 },
-# }
-let x: Message = Message::Move { x: 3, y: 4 };
-
-enum BoardGameTurn {
-    Move { squares: i32 },
-    Pass,
-}
-
-let y: BoardGameTurn = BoardGameTurn::Move { squares: 1 };
+struct Empty;
+struct Color(i32, i32, i32);
+struct Length(i32);
+struct Stats { Health: i32, Mana: i32, Attack: i32, Defense: i32 }
+struct HeightDatabase(Vec<i32>);
 ```
 
-Both variants are named `Move`, but since they’re scoped to the name of
-the enum, they can both be used without conflict.
+Здесь мы видим, что, в зависимости от типа, вариант перечисления может
+содержать, а может и не содержать вложенные данные. Например, в перечислении
+`Character`, вариант `Digit` даёт значимое имя числу типа `i32`. А вот вариант
+`Other` представляет собой лишь имя, без значения. Однако наиболее полезно
+именно то, что отдельные варианты представляют собой различные виды символов
+(`Character`).
 
-A value of an enum type contains information about which variant it is,
-in addition to any data associated with that variant. This is sometimes
-referred to as a ‘tagged union’, since the data includes a ‘tag’
-indicating what type it is. The compiler uses this information to
-enforce that you’re accessing the data in the enum safely. For instance,
-you can’t simply try to destructure a value as if it were one of the
-possible variants:
+Как и структуры, варианты перечислений по умолчанию не сравнимы операциями
+сравнения (`==`, `!=`), не упорядочены (не реализуют `<`, `>=` и другие) и не
+поддерживают другие двухместные операции, такие как умножение (`*`) и сложение
+(`+`). Нижеследующий код, как таковой, не верен (если мы используем приведённый
+выше тип-перечисление `Character`):
 
 ```rust,ignore
-fn process_color_change(msg: Message) {
-    let Message::ChangeColor(r, g, b) = msg; // compile-time error
-}
+// Оба этих присваивания успешны
+let ten  = Character::Digit(10);
+let four = Character::Digit(4);
+
+// Error: `*` is not implemented for type `Character`
+let forty = ten * four;
+
+// Error: `<=` is not implemented for type `Character`
+let four_is_smaller = four <= ten;
+
+// Error: `==` is not implemented for type `Character`
+let four_equals_ten = four == ten;
 ```
 
-Not supporting these operations may seem rather limiting, but it’s a limitation
-which we can overcome. There are two ways: by implementing equality ourselves,
-or by pattern matching variants with [`match`][match] expressions, which you’ll
-learn in the next section. We don’t know enough about Rust to implement
-equality yet, but we’ll find out in the [`traits`][traits] section.
+Мы используем `::` синтаксис чтобы использовать имя каждого из вариантов. Их
+область видимости ограничена именем самого перечисления `enum`. Это позволяет
+использовать оба варианта из примера ниже совместно:
+
+```rust,ignore
+Character::Digit(10);
+Hand::Digit;
+```
+
+Оба варианта имеют одинаковые имена, `Digit`, но область видимости каждого из
+них ограничена соответствующим именем `enum`.
+
+То, что эти операции не поддерживаются, может показаться достаточно
+ограничивающим, но это ограничение, которое мы всегда можем преодолеть. Есть два
+способа: посредством реализация равенства самостоятельно, или посредством
+сопоставления вариантов с шаблонами с помощью выражений конструкции
+[`match`][match], о котором вы узнаете в следующем разделе. Пока мы еще не знаем
+достаточно о Rust для реализации равенства, но мы узнаем об этом в разделе
+[`traits`][traits].
 
 [match]: match.html
-[if-let]: if-let.html
 [traits]: traits.html
