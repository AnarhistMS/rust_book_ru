diff --git a/rust/master:src/doc/trpl/arrays-vectors-and-slices.md b/fix_current_version:arrays-vectors-and-slices.md
index 2916dca..0a5b16b 100644
--- a/rust/master:src/doc/trpl/arrays-vectors-and-slices.md
+++ b/fix_current_version:arrays-vectors-and-slices.md
@@ -1,102 +1,107 @@
-% Arrays, Vectors, and Slices
+% Массивы, вектора, срезы
 
-Like many programming languages, Rust has list types to represent a sequence of
-things. The most basic is the *array*, a fixed-size list of elements of the
-same type. By default, arrays are immutable.
+В Rust, как и во многих других языках программирования, есть типы-списки для
+представления последовательностей неких вещей. Самый простой из них - это
+*массив*, то есть список элементов одного и того же типа, имеющий фиксированный
+размер. Массивы неизменяемы по умолчанию.
 
 ```{rust}
 let a = [1, 2, 3]; // a: [i32; 3]
 let mut m = [1, 2, 3]; // mut m: [i32; 3]
 ```
 
-There's a shorthand for initializing each element of an array to the same
-value. In this example, each element of `a` will be initialized to `0`:
+Для инициализации всех элементов массива одним и тем же значением есть
+специальный синтаксис. В этом примере каждый элемент `a` будет инициализирован
+значением `0`:
 
 ```{rust}
 let a = [0; 20]; // a: [i32; 20]
 ```
 
-Arrays have type `[T; N]`. We'll talk about this `T` notation later, when we
-cover generics.
+Тип массивов - `[T; N]`. Мы поговорим об этих обозначениях позже, когда будем
+рассматривать обобщенные типы.
 
-You can get the number of elements in an array `a` with `a.len()`, and use
-`a.iter()` to iterate over them with a for loop. This code will print each
-number in order:
+Вы можете получить число элементов массива `a` с помощью вызова `a.len()`, и
+использовать `a.iter()` для перебора элементов в цикле. Этот код напечатает все
+числа по порядку:
 
 ```{rust}
 let a = [1, 2, 3];
 
-println!("a has {} elements", a.len());
+println!("Число элементов в a: {}", a.len());
 for e in a.iter() {
     println!("{}", e);
 }
 ```
 
-You can access a particular element of an array with *subscript notation*:
+Вы можете получить определённый элемент массива с помощью *индекса*:
 
 ```{rust}
 let names = ["Graydon", "Brian", "Niko"]; // names: [&str; 3]
 
-println!("The second name is: {}", names[1]);
+println!("Второе имя: {}", names[1]);
 ```
 
-Subscripts start at zero, like in most programming languages, so the first name
-is `names[0]` and the second name is `names[1]`. The above example prints
-`The second name is: Brian`. If you try to use a subscript that is not in the
-array, you will get an error: array access is bounds-checked at run-time. Such
-errant access is the source of many bugs in other systems programming
-languages.
+Индексы нумеруются с нуля, как и в большинстве языков программирования, поэтому
+мы получаем первое имя с помощью `names[0]`, а второе - с помощью `names[1]`.
+Пример выше печатает `Второе имя: Brian`. Если вы попытаетесь использовать
+индекс, который не входит в массив, вы получите ошибку: при доступе к массивам
+происходит проверка границ во время исполнения программы. Такая ошибочная
+попытка доступа - источник многих проблем в других языках системного
+программирования.
 
-A *vector* is a dynamic or "growable" array, implemented as the standard
-library type [`Vec<T>`](../std/vec/) (we'll talk about what the `<T>` means
-later). Vectors always allocate their data on the heap. Vectors are to slices
-what `String` is to `&str`. You can create them with the `vec!` macro:
+*Вектор* - это динамический, "растущий" массив, реализованный в виде
+стандартного библиотечного типа [`Vec<T>`](../std/vec/) (позже мы поговорим о
+том, что здесь означает `<T>`). Вектора всегда помещают данные в куче. Вектора и
+срез - это как `String` и `&str`. Вы можете создавать их с помощью макроса
+`vec!`:
 
 ```{rust}
 let v = vec![1, 2, 3]; // v: Vec<i32>
 ```
 
-(Notice that unlike the `println!` macro we've used in the past, we use square
-brackets `[]` with `vec!`. Rust allows you to use either in either situation,
-this is just convention.)
+(Заметьте, что, в отличие от макроса `println!`, который мы использовали ранее,
+с `vec!` используются квадратные скобки `[]`. Rust разрешает использование и
+круглых, и квадратных скобок в обеих ситуациях - это просто стилистическое
+соглашение.)
 
-There's an alternate form of `vec!` for repeating an initial value:
+Для создания вектора из повторяющихся значений есть другая форма `vec!`:
 
 ```
 let v = vec![0; 10]; // ten zeroes
 ```
 
-You can get the length of, iterate over, and subscript vectors just like
-arrays. In addition, (mutable) vectors can grow automatically:
+Вы можете получать длину, перебирать и индексировать вектора так же, как и
+массивы. К тому же, (изменяемые) вектора могут расти автоматически:
 
 ```{rust}
 let mut nums = vec![1, 2, 3]; // mut nums: Vec<i32>
 
 nums.push(4);
 
-println!("The length of nums is now {}", nums.len()); // Prints 4
+println!("Теперь длина nums составляет {}", nums.len()); // Печатает 4
 ```
 
-Vectors have many more useful methods.
+У векторов есть много других полезных методов.
 
-A *slice* is a reference to (or "view" into) an array. They are useful for
-allowing safe, efficient access to a portion of an array without copying. For
-example, you might want to reference just one line of a file read into memory.
-By nature, a slice is not created directly, but from an existing variable.
-Slices have a length, can be mutable or not, and in many ways behave like
-arrays:
+*Срез* - это ссылка на (или "проекция" в) массив. Они полезны, когда нужно
+обеспечить безопасный, эффективный доступ к части массива без копирования.
+Например, возможно вам нужно сослаться на единственную строку файла, считанного
+в память. Из-за своей ссылочной природы, срезы создаются не напрямую, а из
+существующих переменных. У срезов есть длина, они могут быть изменяемы или нет,
+и во многих случаях они ведут себя как массивы:
 
 ```{rust}
 let a = [0, 1, 2, 3, 4];
-let middle = &a[1..4]; // A slice of a: just the elements 1, 2, and 3
+let middle = &a[1..4]; // Срез a: только элементы 1, 2, и 3
 
 for e in middle.iter() {
-    println!("{}", e); // Prints 1, 2, 3
+    println!("{}", e); // Печатает 1, 2, 3
 }
 ```
 
-You can also take a slice of a vector, `String`, or `&str`, because they are
-backed by arrays. Slices have type `&[T]`, which we'll talk about when we cover
-generics.
+Вы также можете взять срез вектора, типа `String` или `&str`, потому что все они
+реализованы через массивы. Срезы имеют тип `&[T]`, и мы поговорим о нём позже,
+во время обсуждения обобщённых типов.
 
-We have now learned all of the most basic Rust concepts.
+Мы изучили все основные элементы языка Rust.
