diff --git a/rust/master:src/doc/trpl/unsafe.md b/fix_current_version:unsafe.md
index 3ca3cfd..f3b1cc6 100644
--- a/rust/master:src/doc/trpl/unsafe.md
+++ b/fix_current_version:unsafe.md
@@ -1,67 +1,72 @@
-% Unsafe and Low-Level Code
+% Небезопасный и низкоуровневый код
 
-# Introduction
+# Введение
 
-Rust aims to provide safe abstractions over the low-level details of
-the CPU and operating system, but sometimes one needs to drop down and
-write code at that level. This guide aims to provide an overview of
-the dangers and power one gets with Rust's unsafe subset.
+Rust стремится обеспечить безопасные абстракции над низкоуровневыми деталями
+процессора и операционной системы, но иногда бывает нужно спуститься и писать
+код именно на низком уровне. Цель этого руководства - предоставить обзор
+опасностей и мощи (эффективности), получаемых при использовании небезопасного
+подмножества в Rust.
 
-Rust provides an escape hatch in the form of the `unsafe { ... }`
-block which allows the programmer to dodge some of the compiler's
-checks and do a wide range of operations, such as:
+Rust обеспечивает аварийный люк в виде блока `unsafe { ... }`, который позволяет
+программисту обойти некоторые из проверок компилятора и выполнить широкий спектр
+операций, таких как:
 
-- dereferencing [raw pointers](#raw-pointers)
-- calling a function via FFI ([covered by the FFI guide](ffi.html))
-- casting between types bitwise (`transmute`, aka "reinterpret cast")
-- [inline assembly](#inline-assembly)
+- разыменование [raw pointers](#raw-pointers)
+- вызов функций посредством FFI ([covered by the FFI guide](ffi.html))
+- побитовое (поразрядное) преобразование типов (приведение типов, которое может
+оказаться небезопасным и зависящим от реализации) (`transmute`, также известное
+как "reinterpret cast")
+- встраивание ассемблерного кода [inline assembly](#inline-assembly)
 
-Note that an `unsafe` block does not relax the rules about lifetimes
-of `&` and the freezing of borrowed data.
+Обратите внимание, что блок `unsafe` не дает послабления для правил, относящихся
+к: срокам жизни для `&` и замораживанию (фиксации) позаимствованных данных.
 
-Any use of `unsafe` is the programmer saying "I know more than you" to
-the compiler, and, as such, the programmer should be very sure that
-they actually do know more about why that piece of code is valid.  In
-general, one should try to minimize the amount of unsafe code in a
-code base; preferably by using the bare minimum `unsafe` blocks to
-build safe interfaces.
+Любое использование `unsafe` равносильно заявлению программиста: "Я знаю больше,
+чем ты", для компилятора. И таким образом, программист должен быть абсолютно
+уверен в том, что он на самом деле знает что-то, почему этот кусок кода является
+валидным. В целом, следует попытаться свести к минимуму количество опасного кода
+в кодовой базе; предпочтительно использовать допустимо минимальное количество
+`unsafe` блоков при создания безопасных интерфейсов.
 
-> **Note**: the low-level details of the Rust language are still in
-> flux, and there is no guarantee of stability or backwards
-> compatibility. In particular, there may be changes that do not cause
-> compilation errors, but do cause semantic changes (such as invoking
-> undefined behaviour). As such, extreme care is required.
+> **Примечание**: низкоуровневые детали языка Rust еще могут меняться, поэтому
+нет никакой гарантии стабильности или обратной совместимости. В частности, могут
+быть изменения, которые не вызывают ошибок компиляции, но вызывают смысловые
+изменения (например, приводящие к неопределенному (двусмысленному) поведению).
+Таким образом, требуется крайняя осторожность.
 
-# Pointers
+# Указатели
 
-## References
+## Ссылки
 
-One of Rust's biggest features is memory safety.  This is achieved in
-part via [the ownership system](ownership.html), which is how the
-compiler can guarantee that every `&` reference is always valid, and,
-for example, never pointing to freed memory.
+Одной из важнейших особенностей Rust является безопасность памяти. Она
+достигается, в частности с помощью [системы владения](ownership.html), а именно:
+благодяря ей компилятор может гарантировать, что каждая ссылка `&` всегда
+валидна, и никогда не указывает на освобожденную память.
 
-These restrictions on `&` have huge advantages. However, they also
-constrain how we can use them. For example, `&` doesn't behave
-identically to C's pointers, and so cannot be used for pointers in
-foreign function interfaces (FFI). Additionally, both immutable (`&`)
-and mutable (`&mut`) references have some aliasing and freezing
-guarantees, required for memory safety.
+Эти ограничения для `&` имеют огромные преимущества. Тем не менее, они также
+ограничивают и то, как мы можем их использовать. Например, поведение ссылок `&`
+отличается от поведения указателей языка C, и поэтому ссылки не могут быть
+использованы в качестве указателей в интерфейсах внеших функций (FFI). Кроме
+того, и неизменяемые (`&`), и изменяемые (`&mut`) ссылки обладают некоторыми
+гарантиями относительно псевдонимизации и замораживания (фиксации), необходимыми
+для обеспечения безопасности памяти.
 
-In particular, if you have an `&T` reference, then the `T` must not be
-modified through that reference or any other reference. There are some
-standard library types, e.g. `Cell` and `RefCell`, that provide inner
-mutability by replacing compile time guarantees with dynamic checks at
-runtime.
+В частности, если у вас есть ссылка `&T`, то `T` не должен быть изменен с
+помощью этой или любой другой ссылки. В стандартной библиотеке есть несколько
+типов, например `Cell` и `RefCell`, которые обеспечивают внутреннюю
+изменчивость, заменяя гарантии во время компиляции на динамические проверки во
+время выполнения.
 
-An `&mut` reference has a different constraint: when an object has an
-`&mut T` pointing into it, then that `&mut` reference must be the only
-such usable path to that object in the whole program. That is, an
-`&mut` cannot alias with any other references.
+Ссылка `&mut` имеет различные ограничения: когда объект имеет ссылку `&mut T`,
+указывающую на него, тогда эта `&mut` ссылка должна быть единственным возможным
+способом обращения к этому объекту во всей программе. То есть, ссылки `&mut` не
+могу быть псевдонимизированны (иметь псевдоним) любыми другими ссылками.
 
-Using `unsafe` code to incorrectly circumvent and violate these
-restrictions is undefined behaviour. For example, the following
-creates two aliasing `&mut` pointers, and is invalid.
+Использование `unsafe` кода, для того чтобы некорректно обойти и нарушить эти
+ограничения, приведет к неопределеному (двусмысленному) поведению. Например,
+следующий код создает два псевдонима для `&mut` указателя, и не является
+валидным.
 
 ```
 use std::mem;
@@ -76,71 +81,79 @@ let ref_2: &mut u8 = unsafe { mem::transmute(&mut *ref_1) };
 *ref_2 = 20;
 ```
 
-## Raw pointers
+## Сырье указатели (Raw pointers)
 
-Rust offers two additional pointer types (*raw pointers*), written as
-`*const T` and `*mut T`. They're an approximation of C's `const T*` and `T*`
-respectively; indeed, one of their most common uses is for FFI,
-interfacing with external C libraries.
+Rust предлагает два дополнительных вида указателя (*сырье указатели* (*raw
+pointers*), написание которых `*const T` и `*mut T`. Они приблизительно
+соответствуют `const T*` и `T*` языка C; действительно, одно из самых
+распространенных их применений - для FFI, при взаимодействии с внешними
+библиотеками C.
 
-Raw pointers have much fewer guarantees than other pointer types
-offered by the Rust language and libraries. For example, they
+Сырье указатели дают гораздо меньше гарантий, чем другие типы указателей,
+предоставляемые языком Rust и библиотеками. Например, они
 
-- are not guaranteed to point to valid memory and are not even
-  guaranteed to be non-null (unlike both `Box` and `&`);
-- do not have any automatic clean-up, unlike `Box`, and so require
-  manual resource management;
-- are plain-old-data, that is, they don't move ownership, again unlike
-  `Box`, hence the Rust compiler cannot protect against bugs like
-  use-after-free;
-- lack any form of lifetimes, unlike `&`, and so the compiler cannot
-  reason about dangling pointers; and
-- have no guarantees about aliasing or mutability other than mutation
-  not being allowed directly through a `*const T`.
+- не гарантируют, что они указывают на действительную область памяти, и не
+гарантируют, что они является ненулевыми указателями (в отличие от `Box` и `&`);
+- не имеют никакой автоматической очистки, в отличие от `Box`, и поэтому требуют
+ручного управления ресурсами;
+- это простые структуры данных (plain-old-data), то есть они не перемещают право
+собственности, опять же в отличие от `Box`, следовательно, компилятор Rust не
+может защитить от ошибок, таких как использование освобождённой памяти (use-
+after-free);
+- лишены сроков жизни в какой-либо форме, в отличие от `&`, и поэтому компилятор
+не может делать выводы о висячих указателях; и
+- не имеют никаких гарантий относительно псевдонимизации или изменяемости, за
+исключением изменений, недопустимых непосредственно для `*const T`.
 
-Fortunately, they come with a redeeming feature: the weaker guarantees
-mean weaker restrictions. The missing restrictions make raw pointers
-appropriate as a building block for implementing things like smart
-pointers and vectors inside libraries. For example, `*` pointers are
-allowed to alias, allowing them to be used to write shared-ownership
-types like reference counted and garbage collected pointers, and even
-thread-safe shared memory types (`Rc` and the `Arc` types are both
-implemented entirely in Rust).
+К счастью, им присуща и положительная особенность: слабые гарантии означают и
+слабые ограничения. Отсутствие ограничений делает сырые указатели подходящими в
+качестве строительного блока для реализации внутри библиотек таких вещей как
+смарт-указатели (умные указатели) и векторы. Например, для `*` указателей
+разрешается задавать псевдонимы, что позволяет им быть использоваными при
+написании типов для множественного права собственности, таких как указатели со
+счетчиком ссылок и указатели со сборкой мусора и даже типов для потоко-
+безопасного совместного использования памяти (типы `Rc` и `Arc` реализованы в
+Rust в полной мере).
 
-There are two things that you are required to be careful about
-(i.e. require an `unsafe { ... }` block) with raw pointers:
+При работе с сырыми указателями есть две вещи, которые требуют большей
+осторожности (т.е. требуют блок `unsafe { ... }`):
 
-- dereferencing: they can have any value: so possible results include
-  a crash, a read of uninitialised memory, a use-after-free, or
-  reading data as normal.
 - pointer arithmetic via the `offset` [intrinsic](#intrinsics) (or
   `.offset` method): this intrinsic uses so-called "in-bounds"
   arithmetic, that is, it is only defined behaviour if the result is
   inside (or one-byte-past-the-end) of the object from which the
   original pointer came.
+- разыменование: указатели могут содержать любое значение: поэтому возможные
+результаты включают: аварии, чтение неинициализированной памяти, использование
+памяти после освобождения или обычное чтение данных.
+- арифметика указателей с помощью `offset` [intrinsic](#intrinsics)
+(или `.offset` метода): внутреннее используется так называемая "in-bounds"
+арифметика, то есть, он определен только поведение, если результат находится
+внутри (или один байт после конца (one-byte-past-the-end)) объекта, из которого
+первоначально указатель пришел.
 
-The latter assumption allows the compiler to optimize more
-effectively. As can be seen, actually *creating* a raw pointer is not
-unsafe, and neither is converting to an integer.
+Последнее предположение позволяет компилятору более эффективно оптимизировать
+код. Как можно видеть, фактически *создание* сырого указателя не является
+небезопасным, и не происходит преобразование указателя в целое число.
 
-### References and raw pointers
+### Ссылки и сырые указатели
 
-At runtime, a raw pointer `*` and a reference pointing to the same
-piece of data have an identical representation. In fact, an `&T`
-reference will implicitly coerce to an `*const T` raw pointer in safe code
-and similarly for the `mut` variants (both coercions can be performed
-explicitly with, respectively, `value as *const T` and `value as *mut T`).
+Во время выполнения и сырой указатель, `*`, и ссылка, указывающая на тот же
+кусок данных, имеют одинаковое представление. По факту, ссылка `&T` будет неявно
+приведена к сырому указателю `*const T` в безопасном коде, аналогично и для
+вариантов `mut` (оба приведения могут быть выполнены явно, с помощью,
+соответственно, `value as *const T` и `value as *mut T`).
 
-Going the opposite direction, from `*const` to a reference `&`, is not
-safe. A `&T` is always valid, and so, at a minimum, the raw pointer
-`*const T` has to point to a valid instance of type `T`. Furthermore,
-the resulting pointer must satisfy the aliasing and mutability laws of
-references. The compiler assumes these properties are true for any
-references, no matter how they are created, and so any conversion from
-raw pointers is asserting that they hold. The programmer *must*
-guarantee this.
+Переход в обратном направлении, от `*const` к ссылке `&`, не являеся безопасным.
+Ссылка `&T` всегда валидна, и поэтому, как минимум, сырой указатель `*const T`
+должен указывать на правильный экземпляр типа `T`. Кроме того, в результате
+указатель должен удовлетворять правилам псевдонимизации и изменяемости ссылок.
+Компилятор предполагает, что эти свойства верны для любых ссылок, независимо от
+того, как они были созданы, и поэтому любое преобразование из сырых указателей
+равносильно утверждению, что они соответствуют этим правилам. Программист
+*должен* гарантировать это.
 
-The recommended method for the conversion is
+Рекомендуемым методом преобразования является
 
 ```
 let i: u32 = 1;
@@ -156,28 +169,28 @@ unsafe {
 }
 ```
 
-The `&*x` dereferencing style is preferred to using a `transmute`.
-The latter is far more powerful than necessary, and the more
-restricted operation is harder to use incorrectly; for example, it
-requires that `x` is a pointer (unlike `transmute`).
+Разыменование с помощью конструкции `&*x` является более предпочтительным, чем с
+использованием `transmute`. Последнее является гораздо более мощным
+инструментом, чем необходимо, а более ограниченное поведение сложнее
+использовать неправильно. Например, она требует, чтобы `x` представляет собой
+указатель (в отличие от `transmute`).
 
+## Делаем небезопасный код безопасным
 
+Есть различные способы создать безопасный интерфейс вокруг некоторого
+небезопасного кода:
 
-## Making the unsafe safe(r)
-
-There are various ways to expose a safe interface around some unsafe
-code:
-
-- store pointers privately (i.e. not in public fields of public
-  structs), so that you can see and control all reads and writes to
-  the pointer in one place.
-- use `assert!()` a lot: since you can't rely on the protection of the
-  compiler & type-system to ensure that your `unsafe` code is correct
-  at compile-time, use `assert!()` to verify that it is doing the
-  right thing at run-time.
-- implement the `Drop` for resource clean-up via a destructor, and use
-  RAII (Resource Acquisition Is Initialization). This reduces the need
-  for any manual memory management by users, and automatically ensures
-  that clean-up is always run, even when the thread panics.
-- ensure that any data stored behind a raw pointer is destroyed at the
-  appropriate time.
+- хранить указатели приватно (т.е. не в публичных полях публичных структур), так
+чтобы вы могли видеть и контролировать всех, кто читает и пишет по указателю, в
+одном месте.
+- использовать макрос `assert!()` повсеместно: так как вы не можете полагаться
+на защиту компилятора и систему типов, чтобы удостовериться в корректности
+вашего `unsafe` кода во время компиляции, то используйте `assert!()`, чтобы
+убедиться, что он работает правильно во время выполнения.
+- реализовывать `Drop` для очистки ресурсов с помощью деструктора, и
+использовать RAII (получение ресурса есть инициализация). Это уменьшает
+потребность в каком-либо ручном управлении памятью пользователями, и
+автоматически гарантирует, что очистка всегда выполняется, даже когда в потоке
+произошла паника.
+- гарантировать, что любые данные, хранящиеся по сырому указателю разрушаются в
+соответствующее время.
