diff --git a/rust/master:src/doc/trpl/arrays.md b/HEAD:arrays.md
index a6ecac9..21f0df8 100644
--- a/rust/master:src/doc/trpl/arrays.md
+++ b/HEAD:arrays.md
@@ -1,48 +1,51 @@
-% Arrays
+% Массивы
 
-Like many programming languages, Rust has list types to represent a sequence of
-things. The most basic is the *array*, a fixed-size list of elements of the
-same type. By default, arrays are immutable.
+В Rust, как и во многих других языках программирования, есть типы-списки для
+представления последовательностей неких вещей. Самый простой из них - это
+*массив*, то есть список элементов одного и того же типа, имеющий фиксированный
+размер. Массивы неизменяемы по умолчанию.
 
 ```{rust}
 let a = [1, 2, 3]; // a: [i32; 3]
 let mut m = [1, 2, 3]; // mut m: [i32; 3]
 ```
 
-There's a shorthand for initializing each element of an array to the same
-value. In this example, each element of `a` will be initialized to `0`:
+Для инициализации всех элементов массива одним и тем же значением есть
+специальный синтаксис. В этом примере каждый элемент `a` будет инициализирован
+значением `0`:
 
 ```{rust}
 let a = [0; 20]; // a: [i32; 20]
 ```
 
-Arrays have type `[T; N]`. We'll talk about this `T` notation later, when we
-cover generics.
+Тип массивов - `[T; N]`. Мы поговорим об этих обозначениях позже, когда будем
+рассматривать обобщенные типы.
 
-You can get the number of elements in an array `a` with `a.len()`, and use
-`a.iter()` to iterate over them with a for loop. This code will print each
-number in order:
+Вы можете получить число элементов массива `a` с помощью вызова `a.len()`, и
+использовать `a.iter()` для перебора элементов в цикле. Этот код напечатает все
+числа по порядку:
 
 ```{rust}
 let a = [1, 2, 3];
 
-println!("a has {} elements", a.len());
+println!("Число элементов в a: {}", a.len());
 for e in a.iter() {
     println!("{}", e);
 }
 ```
 
-You can access a particular element of an array with *subscript notation*:
+Вы можете получить определённый элемент массива с помощью *индекса*:
 
 ```{rust}
 let names = ["Graydon", "Brian", "Niko"]; // names: [&str; 3]
 
-println!("The second name is: {}", names[1]);
+println!("Второе имя: {}", names[1]);
 ```
 
-Subscripts start at zero, like in most programming languages, so the first name
-is `names[0]` and the second name is `names[1]`. The above example prints
-`The second name is: Brian`. If you try to use a subscript that is not in the
-array, you will get an error: array access is bounds-checked at run-time. Such
-errant access is the source of many bugs in other systems programming
-languages.
+Индексы нумеруются с нуля, как и в большинстве языков программирования, поэтому
+мы получаем первое имя с помощью `names[0]`, а второе - с помощью `names[1]`.
+Пример выше печатает `Второе имя: Brian`. Если вы попытаетесь использовать
+индекс, который не входит в массив, вы получите ошибку: при доступе к массивам
+происходит проверка границ во время исполнения программы. Такая ошибочная
+попытка доступа - источник многих проблем в других языках системного
+программирования.
