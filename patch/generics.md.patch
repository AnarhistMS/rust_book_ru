diff --git a/rust/master:src/doc/trpl/generics.md b/HEAD:generics.md
index 517a6e6..00f067e 100644
--- a/rust/master:src/doc/trpl/generics.md
+++ b/HEAD:generics.md
@@ -1,124 +1,184 @@
-% Generics
+% Дженерики (обобщённые типы)
 
-Sometimes, when writing a function or data type, we may want it to work for
-multiple types of arguments. Luckily, Rust has a feature that gives us a better
-way: generics. Generics are called ‘parametric polymorphism’ in type theory,
-which means that they are types or functions that have multiple forms (‘poly’
-is multiple, ‘morph’ is form) over a given parameter (‘parametric’).
+Иногда, при написании функции или типа данных, мы можем захотеть, чтобы они
+работали для нескольких типов аргументов. Например, помните тип `OptionalInt`?
 
-Anyway, enough with type theory, let’s check out some generic code. Rust’s
-standard library provides a type, `Option<T>`, that’s generic:
+```{rust}
+enum OptionalInt {
+    Value(i32),
+    Missing,
+}
+```
+
+Если мы также захотим иметь `OptionalFloat64`, то нам потребуется новое
+перечисление:
+
+```{rust}
+enum OptionalFloat64 {
+    Valuef64(f64),
+    Missingf64,
+}
+```
+
+Это не очень удобно. К счастью, у Rust есть фича, которая дает нам лучший способ
+реализовать это: дженерики (обобщённые типы). Дженериками называется
+*параметрический полиморфизм* в теории типов. Это означает, что они являются
+типами или функциями, которые имеют несколько форм (*poly* - кратно, *morph* -
+форма) по данному параметру (*параметрический*).
+
+В любом случае, достаточно с декларациями теории типов, давайте проверим общую
+форму `OptionalInt`. На самом деле этот обобщённый тип определен в самом Rust, и
+выглядит следующим образом:
 
 ```rust
 enum Option<T> {
     Some(T),
     None,
 }
 ```
 
-The `<T>` part, which you’ve seen a few times before, indicates that this is
-a generic data type. Inside the declaration of our enum, wherever we see a `T`,
-we substitute that type for the same type used in the generic. Here’s an
-example of using `Option<T>`, with some extra type annotations:
+Часть `<T>`, которую вы уже видели несколько раз прежде, указывает, что это
+обобщённый тип данных. Внутри перечисления, везде, где мы видим `T`, мы
+подставляем вместо этого абстактного типа тот, который используется в дженерике.
+Вот пример использования `Option<T>` с некоторыми дополнительными аннотациями
+типов:
 
-```rust
+```{rust}
 let x: Option<i32> = Some(5);
 ```
 
-In the type declaration, we say `Option<i32>`. Note how similar this looks to
-`Option<T>`. So, in this particular `Option`, `T` has the value of `i32`. On
-the right-hand side of the binding, we do make a `Some(T)`, where `T` is `5`.
-Since that’s an `i32`, the two sides match, and Rust is happy. If they didn’t
-match, we’d get an error:
+В определении типа мы используем `Option<i32>`. Обратите внимание, что это очень
+похоже на `Option<T>`. С той лишь разницей, что, в данном конкретном `Option`,
+`T` имеет значение `i32`. В правой стороне выражения, мы используем `Some(T)`,
+где `T` равно `5`. Так как `5` является представителем типа `i32`, то типы по
+обе стороны совпадают, отчего Rust счастлив. Если же они не совпадают, то мы
+получим ошибку:
 
-```rust,ignore
+```{rust,ignore}
 let x: Option<f64> = Some(5);
 // error: mismatched types: expected `core::option::Option<f64>`,
 // found `core::option::Option<_>` (expected f64 but found integral variable)
 ```
 
-That doesn’t mean we can’t make `Option<T>`s that hold an `f64`! They just have
-to match up:
+Но это не значит, что мы не можем сделать `Option<T>`, который содержит `f64`!
+Просто с левой и с правой сторон выражения объявления переменной типы должны
+совпадать:
 
-```rust
+```{rust}
 let x: Option<i32> = Some(5);
 let y: Option<f64> = Some(5.0f64);
 ```
 
-This is just fine. One definition, multiple uses.
+Это просто прекрасно. Одно определение - многостороннее использование.
 
-Generics don’t have to only be generic over one type. Consider another type from Rust’s standard library that’s similar, `Result<T, E>`:
+Дженерики могут быть обобщёнными не только для одного единственного типа.
+Рассмотрим встроенный в Rust тип `Result<T, E>`:
 
-```rust
+```{rust}
 enum Result<T, E> {
     Ok(T),
     Err(E),
 }
 ```
 
-This type is generic over _two_ types: `T` and `E`. By the way, the capital letters
-can be any letter you’d like. We could define `Result<T, E>` as:
+Этот тип является обобщённым сразу для _двух_ типов: `T` и `E`. Кстати,
+заглавные буквы может быть любыми, какими хотите. Мы могли бы определить
+`Result<T, E>` как:
 
-```rust
+```{rust}
 enum Result<A, Z> {
     Ok(A),
     Err(Z),
 }
 ```
 
-if we wanted to. Convention says that the first generic parameter should be
-`T`, for ‘type’, and that we use `E` for ‘error’. Rust doesn’t care, however.
+если бы захотели. Соглашение гласит, что первый обобщённый параметр должен быть:
+`T` - для 'типа', и `E` - для 'ошибки.' Но Rust не проверяет этого.
 
-The `Result<T, E>` type is intended to be used to return the result of a
-computation, and to have the ability to return an error if it didn’t work out.
+Тип `Result<T, E>` предназначен для того, чтобы возвращать результат вычисления,
+и имеет возможность вернуть ошибку, если произойдет какой-либо сбой. Вот пример:
 
-## Generic functions
+```{rust}
+let x: Result<f64, String> = Ok(2.3f64);
+let y: Result<f64, String> = Err("There was an error.".to_string());
+```
 
-We can write functions that take generic types with a similar syntax:
+Этот конкретный `Result` вернет `f64` в случае успеха и `String` в случае
+неудачи. Давайте напишем функцию, которая использует `Result<T, E>`:
 
-```rust
-fn takes_anything<T>(x: T) {
-    // do something with x
+```{rust}
+fn inverse(x: f64) -> Result<f64, String> {
+    if x == 0.0f64 { return Err("x cannot be zero!".to_string()); }
+
+    Ok(1.0f64 / x)
 }
 ```
 
-The syntax has two parts: the `<T>` says “this function is generic over one
-type, `T`”, and the `x: T` says “x has the type `T`.”
+Мы не можем получить элемент, обратный нулю, поэтому мы проверяем, что бы в
+качестве входного значения не был передан нуль. Если все же нуль был передан, то
+мы возвращаем `Err` с сообщением. Если же нет, то мы возвращаем `Ok` с ответом.
 
-Multiple arguments can have the same generic type:
+Почему это важно? Помните как `match` делает всеобъемлющую обработку значения?
+Вот как обрабатывается результат этой функции:
 
-```rust
-fn takes_two_of_the_same_things<T>(x: T, y: T) {
-    // ...
+```{rust}
+# fn inverse(x: f64) -> Result<f64, String> {
+#     if x == 0.0f64 { return Err("x cannot be zero!".to_string()); }
+#     Ok(1.0f64 / x)
+# }
+let x = inverse(25.0f64);
+
+match x {
+    Ok(x) => println!("The inverse of 25 is {}", x),
+    Err(msg) => println!("Error: {}", msg),
 }
 ```
 
-We could write a version that takes multiple types:
+`match` обеспечивает обработку случая с `Err`. Кроме того, поскольку ответ
+завернут в `Ok`, мы не можем просто использовать результат, не используя при
+этом деструктурирования:
 
-```rust
-fn takes_two_things<T, U>(x: T, y: U) {
-    // ...
+```{rust,ignore}
+let x = inverse(25.0f64);
+println!("{}", x + 2.0f64); // error: binary operation `+` cannot be applied
+           // to type `core::result::Result<f64,collections::string::String>`
+```
+
+Эта функция хороша, но есть еще одна проблема: она работает только для 64 битных
+значений с плавающей точкой. Что делать, если мы хотим работать так же и с 32
+битными значениями с плавающей точкой? Тогда мы должны написать так:
+
+```{rust}
+fn inverse32(x: f32) -> Result<f32, String> {
+    if x == 0.0f32 { return Err("x cannot be zero!".to_string()); }
+
+    Ok(1.0f32 / x)
 }
 ```
 
-Generic functions are most useful with ‘trait bounds’, which we’ll cover in the
-[section on traits][traits].
+Облом. Все, что нам нужно, это *дженерик функция*. К счастью, мы уже можем
+написать нечто подобное! Тем не менее, она будет не совсем еще работать. Прежде,
+чем мы пойдем дальше, давайте поговорим о синтаксисе. Дженерик версия `inverse`
+будет выглядеть примерно так:
 
-[traits]: traits.html
+```{rust,ignore}
+fn inverse<T>(x: T) -> Result<T, String> {
+    if x == 0.0 { return Err("x cannot be zero!".to_string()); }
 
-## Generic structs
-
-You can store a generic type in a `struct` as well:
-
-```
-struct Point<T> {
-    x: T,
-    y: T,
+    Ok(1.0 / x)
 }
-
-let int_origin = Point { x: 0, y: 0 };
-let float_origin = Point { x: 0.0, y: 0.0 };
 ```
 
-Similarly to functions, the `<T>` is where we declare the generic parameters,
-and we then use `x: T` in the type declaration, too.
+Для объявления `inverse<T>` мы используем такой же синтаксис, как и для
+`Option<T>`. Затем мы можем использовать `T` внутри остальной части сигнатуры:
+`x` имеет тип `T`, и часть `Result` имеет тип `T`. Однако, если мы попытаемся
+скомпилировать этот пример, мы получим ошибку:
+
+```text
+error: binary operation `==` cannot be applied to type `T`
+```
+
+Поскольку `T` может быть _любым_ типом, даже типом, который не реализует `==`,
+то, следовательно, в первой строке будет ошибка. Что же делать?
+
+Чтобы исправить этот пример, мы должны узнать о другой фиче Rust: трейты.
