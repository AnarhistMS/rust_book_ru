diff --git a/rust/master:src/doc/trpl/closures.md b/fix_current_version:closures.md
index 01b8163..5ba23a4 100644
--- a/rust/master:src/doc/trpl/closures.md
+++ b/fix_current_version:closures.md
@@ -1,13 +1,13 @@
-% Closures
+% Замыкания
 
-Rust not only has named functions, but anonymous functions as well. Anonymous
-functions that have an associated environment are called 'closures', because they
-close over an environment. Rust has a really great implementation of them, as
-we'll see.
+Помимо именованных функций Rust предоставляет еще и анонимные функции. Анонимные
+функции, которые имеют связанное окружение, называются 'замыкания'. Они так
+называются потому что они замыкают свое окружение. Как мы увидим далее, Rust
+имеет реально крутую реализацию замыканий.
 
-# Syntax
+# Синтаксис
 
-Closures look like this:
+Замыкания выглядят следующим образом:
 
 ```rust
 let plus_one = |x: i32| x + 1;
@@ -15,10 +15,10 @@ let plus_one = |x: i32| x + 1;
 assert_eq!(2, plus_one(1));
 ```
 
-We create a binding, `plus_one`, and assign it to a closure. The closure's
-arguments go between the pipes (`|`), and the body is an expression, in this
-case, `x + 1`. Remember that `{ }` is an expression, so we can have multi-line
-closures too:
+Мы создаем связывание, `plus_one`, и присваиваем ему замыкание. Аргументы
+замыкания располагаются между двумя символами `|`, а телом замыкания является
+выражение, в данном случае: `x + 1`. Помните, что `{ }` также является
+выражением, поэтому тело замыкания может содержать много строк:
 
 ```rust
 let plus_two = |x| {
@@ -33,10 +33,10 @@ let plus_two = |x| {
 assert_eq!(4, plus_two(2));
 ```
 
-You'll notice a few things about closures that are a bit different than regular
-functions defined with `fn`. The first of which is that we did not need to
-annotate the types of arguments the closure takes or the values it returns. We
-can:
+Обратите внимание, что есть несколько небольших различий между замыканиями и
+обычными функциями, определенными с помощью `fn`. Первое отличие состоит в том,
+что для замыкания мы не должны указывать ни типы аргументов, которые оно
+принимает, ни тип возвращаемого им значения. Мы можем:
 
 ```rust
 let plus_one = |x: i32| -> i32 { x + 1 };
@@ -49,9 +49,15 @@ While specifying the full type for named functions is helpful with things like
 documentation and type inference, the types of closures are rarely documented
 since they’re anonymous, and they don’t cause the kinds of error-at-a-distance
 that inferring named function types can.
+Но мы не должны. Почему так? В основном, это было сделано из эргономических
+соображений (соображений удобства). В то время как для именованных функций
+указание полного типа является полезным для таких аспектов как документация и
+вывод типа, типы замыканий редко документируют, поскольку они анонимны, и они не
+вызывают виды ошибок на расстояния (отлрженных ошибок) (error-at-a-distance),
+которое могут выдавать типы именованных функций.
 
-The second is that the syntax is similar, but a bit different. I've added spaces
-here to make them look a little closer:
+Второе отличие - синтаксис очень похож, но все же немного отличается. Я добавил
+пробелы здесь, чтобы было более наглядно:
 
 ```rust
 fn  plus_one_v1 (  x: i32 ) -> i32 { x + 1 }
@@ -59,12 +65,12 @@ let plus_one_v2 = |x: i32 | -> i32 { x + 1 };
 let plus_one_v3 = |x: i32 |          x + 1  ;
 ```
 
-Small differences, but they're similar in ways.
+Есть небольшие различия, но принцип аналогичен.
 
-# Closures and their environment
+# Замыкания и их окружение
 
-Closures are called such because they 'close over their environment.' It
-looks like this:
+Замыкания называются так потому, что они 'замыкают свое окружение.' Это выглядит
+следующим образом:
 
 ```rust
 let num = 5;
@@ -73,9 +79,10 @@ let plus_num = |x: i32| x + num;
 assert_eq!(10, plus_num(5));
 ```
 
-This closure, `plus_num`, refers to a `let` binding in its scope: `num`. More
-specifically, it borrows the binding. If we do something that would conflict
-with that binding, we get an error. Like this one:
+Это замыкание, `plus_num`, ссылается на связанную с помощью оператора `let`
+переменную `num`, расположенную в своей области видимости. Если говорить более
+конкретно, то оно заимствует связывание. Если мы сделаем что-то, что
+противоречило бы связыванию, то получим ошибку. Например этот код:
 
 ```rust,ignore
 let mut num = 5;
@@ -84,7 +91,7 @@ let plus_num = |x: i32| x + num;
 let y = &mut num;
 ```
 
-Which errors with:
+Который выдаст следующие ошибки:
 
 ```text
 error: cannot borrow `num` as mutable because it is also borrowed as immutable
@@ -105,9 +112,9 @@ fn main() {
 ^
 ```
 
-A verbose yet helpful error message! As it says, we can't take a mutable borrow
-on `num` because the closure is already borrowing it. If we let the closure go
-out of scope, we can:
+Подробные сообщения, но полезно ошибка! Как говорится в сообщении, мы не можем
+получить изменяемый заем переменной `num` потому что замыкание уже заимствует
+его. Если же мы обеспечим выход замыкания из области видимости, то мы сможем:
 
 ```rust
 let mut num = 5;
@@ -119,8 +126,8 @@ let mut num = 5;
 let y = &mut num;
 ```
 
-If your closure requires it, however, Rust will take ownership and move
-the environment instead:
+Однако, Rust также может забирать право владения и перемещать свое окружение,
+если этого требует замыкание:
 
 ```rust,ignore
 let nums = vec![1, 2, 3];
@@ -130,7 +137,7 @@ let takes_nums = || nums;
 println!("{:?}", nums);
 ```
 
-This gives us:
+Этот код выдаст:
 
 ```text
 note: `nums` moved into closure environment here because it has type
@@ -139,14 +146,15 @@ let takes_nums = || nums;
                     ^~~~~~~
 ```
 
-`Vec<T>` has ownership over its contents, and therefore, when we refer to it
-in our closure, we have to take ownership of `nums`. It's the same as if we'd
-passed `nums` to a function that took ownership of it.
+`Vec<T>` обладает правом собственности на свое содержимое, и поэтому, когда мы
+ссылаемся на него в нашем замыкании, мы должны забрать право собственности на
+`nums`. Это тоже самое, как если бы мы передавали `nums` в функцию, которая
+забирала бы право собственности на него.
 
-## `move` closures
+## `move` замыкания
 
-We can force our closure to take ownership of its environment with the `move`
-keyword:
+Мы можем заставить наше замыкание забирать право собственности из его окружения
+с помошью ключевого слова `move`:
 
 ```rust
 let num = 5;
@@ -157,6 +165,9 @@ let owns_num = move |x: i32| x + num;
 Now, even though the keyword is `move`, the variables follow normal move semantics.
 In this case, `5` implements `Copy`, and so `owns_num` takes ownership of a copy
 of `num`. So what's the difference?
+Теперь, когда указано ключевое слово `move`, переменные следуют нормальной
+семантике перемещения. В данном примере, `5` реализует `Copy`, поэтому
+`owns_num` становится владельцем копии `num`. Так в чем же разница?
 
 ```rust
 let mut num = 5;
@@ -170,15 +181,15 @@ let mut num = 5;
 assert_eq!(10, num);
 ```
 
-So in this case, our closure took a mutable reference to `num`, and then when
-we called `add_num`, it mutated the underlying value, as we'd expect. We also
-needed to declare `add_num` as `mut` too, because we’re mutating its
-environment.
+Таким образом, в этом примере наше замыкание принимает изменяемую ссылку на
+`num`. Затем, когда мы вызываем замыкание `add_num`, то, как мы и ожидали, оно
+изменяет значение внутри. Нам также необходимо объявить `owns_num` как `mut`,
+потому что оно изменяет свое окружение.
 
-We also had to declare `add_num` as mut, since we will be modifying its
-environment.
+Мы также должны были объявить `add_num` как `mut`, так как оно будет изменять
+свое окружение.
 
-If we change to a `move` closure, it's different:
+Если же мы изменим на `move` замыкание, то получим следующие отличия:
 
 ```rust
 let mut num = 5;
@@ -192,35 +203,43 @@ let mut num = 5;
 assert_eq!(5, num);
 ```
 
-We only get `5`. Rather than taking a mutable borrow out on our `num`, we took
-ownership of a copy.
+Мы всего лишь получаем `5`. Вместо того, чтобы получать изменяемый заем на
+`num`, мы получаем право собственности на копию.
 
-Another way to think about `move` closures: they give a closure its own stack
-frame.  Without `move`, a closure may be tied to the stack frame that created
-it, while a `move` closure is self-contained. This means that you cannot
-generally return a non-`move` closure from a function, for example.
+Вот еще один способ думать о `move` замыканиях: они предоставляют замыкание со
+своим собственным фреймом стека. Без `move`, замыкание может быть связано с
+фреймом стека, который его создал, в то время как `move` замыкание содержит свой
+собственный фрейм стека. Это означает, например, что вы не можете вернуть не
+`move` замыкание из функции.
 
-But before we talk about taking and returning closures, we should talk some more
-about the way that closures are implemented. As a systems language, Rust gives
-you tons of control over what your code does, and closures are no different.
+Но прежде чем говорить о получении в качестве аргумента и возвращении замыкания,
+мы должны поговорить о том, как реализуются замыкания. Как системный язык
+программирования, Rust дает вам кучу контроля над тем, что делает ваш код, и
+замыкания не являются исключением.
 
-# Closure implementation
+# Реализация замыканий
 
-Rust's implementation of closures is a bit different than other languages. They
-are effectively syntax sugar for traits. You'll want to make sure to have read
-the [traits chapter][traits] before this one, as well as the chapter on [static
-and dynamic dispatch][dispatch], which talks about trait objects.
+Реализация замыканий в Rust немного отличается от других языков. Фактически, она
+представляет из себя просто синтаксисический сахар для трейтов. Перед тем как
+читать дальше, настоятельно рекомендуем прочитать главу [Трейты][traits], а
+также главу о [статической и динамической диспетчеризации][dispatch], в которой
+говорится об трейт объектах.
 
 [traits]: traits.html
 [dispatch]: static-and-dynamic-dispatch.html
 
-Got all that? Good.
+Прочитали? Хорошо.
 
 The key to understanding how closures work under the hood is something a bit
 strange: Using `()` to call a function, like `foo()`, is an overloadable
 operator. From this, everything else clicks into place. In Rust, we use the
 trait system to overload operators. Calling functions is no different. We have
 three separate traits to overload with:
+Ключ к пониманию того, как замыкания работают изнутри звучит немного странно:
+использование `()` для вызова функции, как например `foo()`, представляет собой
+перегрузку оператора. Исходя из этого, все остальное встанет на свои места. В
+Rust мы используем трейт систему для перегрузки операторов. Вызов функций не
+является исключением. Существуют три отдельных трейта для перегрузки:
 
 ```rust
 # mod foo {
@@ -240,24 +259,25 @@ pub trait FnOnce<Args> {
 # }
 ```
 
-You'll notice a few differences between these traits, but a big one is `self`:
-`Fn` takes `&self`, `FnMut` takes `&mut self`, and `FnOnce` takes `self`. This
-covers all three kinds of `self` via the usual method call syntax. But we've
-split them up into three traits, rather than having a single one. This gives us
-a large amount of control over what kind of closures we can take.
+Вы можете заметить некоторые различия между этими трейтами, но есть одно главное
+различие - `self`: `Fn` принимает `&self`, `FnMut` принимает `&mut self`,
+`FnOnce` принимает `self`. Это покрывает все три вида `self` с помощью обычного
+синтаксиса вызова методов. Мы разделили их на три трейта, вместо того, чтобы
+иметь один. Это дает нам большее количество контроля над тем, какого вида
+замыкания мы можем принять.
 
-The `|| {}` syntax for closures is sugar for these three traits. Rust will
-generate a struct for the environment, `impl` the appropriate trait, and then
-use it.
+Использование `|| {}` при создании замыканий является синтаксическим сахаром для
+этих трех трейтов. Rust будет генерировать структуру для окружения, реализующую
+(`impl`) соответствующий трейт, а затем использовать его.
 
-# Taking closures as arguments
+# Передача замыканий в качестве аргументов
 
-Now that we know that closures are traits, we already know how to accept and
-return closures: just like any other trait!
+Теперь, когда мы знаем, что замыкания являются трейтами, получается, что мы уже
+знаем, как принимать и возвращать замыкания: как и любой другой трейт!
 
-This also means that we can choose static vs dynamic dispatch as well. First,
-let's write a function which takes something callable, calls it, and returns
-the result:
+Это также означает, что мы можем выбирать между статической и динамической
+диспетчеризацией. Во-первых, давайте напишем функцию, которая принимает что-то
+вызываемое, вызывает его и возвращает результат:
 
 ```rust
 fn call_with_one<F>(some_closure: F) -> i32
@@ -271,10 +291,11 @@ let answer = call_with_one(|x| x + 2);
 assert_eq!(3, answer);
 ```
 
-We pass our closure, `|x| x + 2`, to `call_with_one`. It just does what it
-suggests: it calls the closure, giving it `1` as an argument.
+Мы передаем наше замыкание, `|x| x + 2`, в функцию `call_with_one`. Она же
+делает то, что написано у нее в названии: вызывает замыкание, передавая ему `1`
+в качестве аргумента.
 
-Let's examine the signature of `call_with_one` in more depth:
+Давайте рассмотрим сигнатуру функции `call_with_one` более подробно:
 
 ```rust
 fn call_with_one<F>(some_closure: F) -> i32
@@ -282,8 +303,8 @@ fn call_with_one<F>(some_closure: F) -> i32
 #    some_closure(1) }
 ```
 
-We take one parameter, and it has the type `F`. We also return a `i32`. This part
-isn't interesting. The next part is:
+Мы принимаем один параметр, который имеет тип `F`. Мы также возвращаем `i32`.
+Эта часть не интересна. Следующим важным моментом является:
 
 ```rust
 # fn call_with_one<F>(some_closure: F) -> i32
@@ -291,20 +312,22 @@ isn't interesting. The next part is:
 #   some_closure(1) }
 ```
 
-Because `Fn` is a trait, we can bound our generic with it. In this case, our closure
-takes a `i32` as an argument and returns an `i32`, and so the generic bound we use
-is `Fn(i32) -> i32`.
+Так как `Fn` является трейтом, мы можем связать с ним наш дженерик (обобщенный)
+параметр. В этом примере, замыкание принимает `i32` в качестве аргумента и
+возвращает `i32`, поэтому дженерик привязка, которую мы используем, выглядит:
+`Fn(i32) -> i32`.
 
-There's one other key point here: because we're bounding a generic with a
-trait, this will get monomorphized, and therefore, we'll be doing static
-dispatch into the closure. That's pretty neat. In many langauges, closures are
-inherently heap allocated, and will always involve dynamic dispatch. In Rust,
-we can stack allocate our closure environment, and statically dispatch the
-call. This happens quite often with iterators and their adapters, which often
-take closures as arguments.
+Здесь есть еще один ключевой момент: так как мы ограничиваем дженерик параметр с
+помощью трейта, то будет применена мономорфизация, и поэтому в замыкании будет
+использоваться статическая диспетчеризация. Это довольно лаконично (аккуратно).
+Во многих языках для замыканий по существу используется выделение памяти в куче,
+и поэтому всегда будет использоваться динамическая диспетчеризация. В Rust мы
+можем выделить память для окружения замыкания в стеке и использовать статическую
+диспетчеризацию вызова. Это случается довольно часто с итераторами и их
+адаптерами, которые нередко принимают замыкания в качестве аргументов.
 
-Of course, if we want dynamic dispatch, we can get that too. A trait object
-handles this case, as usual:
+Конечно, если нам нужна динамическая диспетчеризация, мы также можем
+использовать и ее. Обычно для этого случая используется трейт объект:
 
 ```rust
 fn call_with_one(some_closure: &Fn(i32) -> i32) -> i32 {
@@ -316,15 +339,16 @@ let answer = call_with_one(&|x| x + 2);
 assert_eq!(3, answer);
 ```
 
-Now we take a trait object, a `&Fn`. And we have to make a reference
-to our closure when we pass it to `call_with_one`, so we use `&||`.
+Теперь наша функция в качетве аргумента принимает трейт объект, `&Fn`. Поэтому
+мы должны создать ссылку на замыкание а затем передать ее в функцию
+`call_with_one`, для этого мы используем `&||`.
 
-# Returning closures
+# Возврат замыканий
 
-It’s very common for functional-style code to return closures in various
-situations. If you try to return a closure, you may run into an error. At
-first, it may seem strange, but we'll figure it out. Here's how you'd probably
-try to return a closure from a function:
+Что очень характерно для кода в функциональном стиле - возвращать замыкания в
+различных ситуациях. Если вы попытаетесь вернуть замыкание, то можете
+столкнуться с ошибкой. Сперва это может показаться странным, но мы с этим
+разберемся. Вот как вы, наверное, попытаетесь вернуть замыкание из функции:
 
 ```rust,ignore
 fn factory() -> (Fn(i32) -> Vec<i32>) {
@@ -339,7 +363,7 @@ let answer = f(4);
 assert_eq!(vec![1, 2, 3, 4], answer);
 ```
 
-This gives us these long, related errors:
+Это выдаст следующие длинные, взаимосвязанные ошибки:
 
 ```text
 error: the trait `core::marker::Sized` is not implemented for the type
@@ -360,11 +384,12 @@ fa ctory() -> (Fn(i32) -> Vec<i32>) {
 
 ```
 
-In order to return something from a function, Rust needs to know what
-size the return type is. But since `Fn` is a trait, it could be various
-things of various sizes: many different types can implement `Fn`. An easy
-way to give something a size is to take a reference to it, as references
-have a known size. So we'd write this:
+Для того чтобы вернуть что-то из функции, Rust должен знать, какой размер имеет
+тип возвращаемого значения. Но так как `Fn` является трейтом, то в качестве него
+могут выступать совершенно разные объекты, с разными размерами: много различных
+типов могут реализовать `Fn`. Самый простой способ передать что-то
+неопределенного размера - получить ссылку на это что-то, так как ссылки имеют
+известный размер. Таким образом, следовало бы написать так:
 
 ```rust,ignore
 fn factory() -> &(Fn(i32) -> Vec<i32>) {
@@ -379,7 +404,7 @@ let answer = f(4);
 assert_eq!(vec![1, 2, 3, 4], answer);
 ```
 
-But we get another error:
+Но тогда мы получим другую ошибку:
 
 ```text
 error: missing lifetime specifier [E0106]
@@ -387,9 +412,9 @@ fn factory() -> &(Fn(i32) -> i32) {
                 ^~~~~~~~~~~~~~~~~
 ```
 
-Right. Because we have a reference, we need to give it a lifetime. But
-our `factory()` function takes no arguments, so elision doesn't kick in
-here. What lifetime can we choose? `'static`:
+Верно. Так как у нас используется ссылка, то мы должны задать ее срок жизни. Так
+наша функция `factory()` не принимает никаких аргументов, то элизия (сокрытие)
+здесь не уместна. Какой срок жизни мы должны выбрать? `'static`:
 
 ```rust,ignore
 fn factory() -> &'static (Fn(i32) -> i32) {
@@ -404,7 +429,7 @@ let answer = f(1);
 assert_eq!(6, answer);
 ```
 
-But we get another error:
+Но мы получим еще ошибку:
 
 ```text
 error: mismatched types:
@@ -417,22 +442,27 @@ error: mismatched types:
 
 ```
 
-This error is letting us know that we don't have a `&'static Fn(i32) -> i32`,
-we have a `[closure <anon>:7:9: 7:20]`. Wait, what?
+Эта ошибка сообщает нам, что ожидается использование `&'static Fn(i32) -> i32`,
+а у используется `[closure <anon>:7:9: 7:20]`. Подождите, что?
 
 Because each closure generates its own environment `struct` and implementation
 of `Fn` and friends, these types are anonymous. They exist just solely for
 this closure. So Rust shows them as `closure <anon>`, rather than some
 autogenerated name.
+Поскольку каждое замыкание (в индивидуальном порядке) генерирует свою
+собственную `struct` для окружения и реализует `Fn` и друзей, то эти типы
+являются анонимными. Они существуют исключительно для этого замыкания. Поэтому
+Rust показывает их как `closure <anon>`, а не в виде какого-то сгенерированного
+имени.
 
-But why doesn't our closure implement `&'static Fn`? Well, as we discussed before,
-closures borrow their environment. And in this case, our environment is based
-on a stack-allocated `5`, the `num` variable binding. So the borrow has a lifetime
-of the stack frame. So if we returned this closure, the function call would be
-over, the stack frame would go away, and our closure is capturing an environment
-of garbage memory!
+Но почему же наше замыкание не реализует `&'static Fn`? Как мы обсуждали ранее,
+замыкание занимает свое окружение. И в этом случае, наше окружение представляет
+собой выделеную в стеке память, содержащую значени связанной переменной `num` -
+`5`. Из-за этого заем имеет срок жизни кадра стека. Так что, когда мы вернем это
+замыкание, то вызов функции будет завершен, а кадр стека уйдет, и наше замыкание
+захватит окружение, содержащее в памяти мусор!
 
-So what to do? This _almost_ works:
+Так что же делать? Этот код _почти_ работает:
 
 ```rust,ignore
 fn factory() -> Box<Fn(i32) -> i32> {
@@ -448,7 +478,8 @@ assert_eq!(6, answer);
 # }
 ```
 
-We use a trait object, by `Box`ing up the `Fn`. There's just one last problem:
+Мы используем трейт объект, представляющий собой упакованный (`Box`) трейт `Fn`.
+И остаётся только одна, последняя проблема:
 
 ```text
 error: `num` does not live long enough
@@ -456,8 +487,8 @@ Box::new(|x| x + num)
          ^~~~~~~~~~~
 ```
 
-We still have a reference to the parent stack frame. With one last fix, we can
-make this work:
+Но мы все еще по-прежнему ссылаемся на родительский фрейм стека. С этии
+последним исправлением мы сможем наконец сделать эту работу:
 
 ```rust
 fn factory() -> Box<Fn(i32) -> i32> {
@@ -476,3 +507,7 @@ assert_eq!(6, answer);
 By making the inner closure a `move Fn`, we create a new stack frame for our
 closure. By `Box`ing it up, we've given it a known size, and allowing it to
 escape our stack frame.
+Благодаря изменению внутреннего замыкания на `move Fn` будет создаваться новый
+кадр стека для нашего замыкания. А благодаря его упаковке (`Box`),
+обеспечивается известный размер возвращаемого значения, и позволяет ему избежать
+нашей стека.
