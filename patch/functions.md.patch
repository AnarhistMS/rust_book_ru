diff --git a/rust/master:src/doc/trpl/functions.md b/fix_current_version:functions.md
index 8e8ee8d..723a1e9 100644
--- a/rust/master:src/doc/trpl/functions.md
+++ b/fix_current_version:functions.md
@@ -1,31 +1,32 @@
-% Functions
+% Функции
 
-You've already seen one function so far, the `main` function:
+К этому моменту вы уже видели одну функцию, `main`:
 
 ```rust
 fn main() {
 }
 ```
 
-This is the simplest possible function declaration. As we mentioned before,
-`fn` says "this is a function," followed by the name, some parentheses because
-this function takes no arguments, and then some curly braces to indicate the
-body. Here's a function named `foo`:
+Это - простейшее объявление функции. Как мы упоминали ранее, ключевое слово `fn`
+объявляет функцию. За ним следует её имя, пустые круглые скобки (поскольку эта
+функция не принимает аргументов), а затем тело функции, заключённое в
+фигурные скобки. Вот функция `foo`:
 
 ```rust
 fn foo() {
 }
 ```
 
-So, what about taking arguments? Here's a function that prints a number:
+Итак, что насчёт аргументов, принимаемых функцией? Вот функция, печатающая
+число:
 
 ```rust
 fn print_number(x: i32) {
-    println!("x is: {}", x);
+    println!("x равен: {}", x);
 }
 ```
 
-Here's a complete program that uses `print_number`:
+Вот полная программа, использующая функцию `print_number`:
 
 ```rust
 fn main() {
@@ -33,14 +34,14 @@ fn main() {
 }
 
 fn print_number(x: i32) {
-    println!("x is: {}", x);
+    println!("x равен: {}", x);
 }
 ```
 
-As you can see, function arguments work very similar to `let` declarations:
-you add a type to the argument name, after a colon.
+Как видите, аргументы функций похожи на операторы `let`: вы можете объявить
+тип аргумента после двоеточия.
 
-Here's a complete program that adds two numbers together and prints them:
+Вот полная программа, которая складывает два числа и печатает их:
 
 ```rust
 fn main() {
@@ -48,15 +49,14 @@ fn main() {
 }
 
 fn print_sum(x: i32, y: i32) {
-    println!("sum is: {}", x + y);
+    println!("сумма чисел: {}", x + y);
 }
 ```
 
-You separate arguments with a comma, both when you call the function, as well
-as when you declare it.
+Аргументы разделяются запятой - и при вызове функции, и при её объявлении.
 
-Unlike `let`, you _must_ declare the types of function arguments. This does
-not work:
+В отличие от `let`, вы _должны_ объявлять типы аргументов функции. Этот код
+не скомпилируется:
 
 ```{rust,ignore}
 fn print_sum(x, y) {
@@ -64,20 +64,21 @@ fn print_sum(x, y) {
 }
 ```
 
-You get this error:
+Вы увидите такую ошибку:
 
 ```text
 hello.rs:5:18: 5:19 expected one of `!`, `:`, or `@`, found `)`
 hello.rs:5 fn print_number(x, y) {
 ```
 
-This is a deliberate design decision. While full-program inference is possible,
-languages which have it, like Haskell, often suggest that documenting your
-types explicitly is a best-practice. We agree that forcing functions to declare
-types while allowing for inference inside of function bodies is a wonderful
-sweet spot between full inference and no inference.
+Это осознанное решение при проектировании языка. Бесспорно, вывод типов во всей
+программе возможен. Однако даже в Haskell считается хорошим стилем явно
+документировать типы функций, хотя в этом языке и возможен полный вывод типов.
+Мы считаем, что принудительное объявление типов функций при сохранении
+локального вывода типов - это хороший компромисс.
 
-What about returning a value? Here's a function that adds one to an integer:
+Как насчёт возвращаемого значения? Вот функция, которая прибавляет один к
+целому:
 
 ```rust
 fn add_one(x: i32) -> i32 {
@@ -85,10 +86,11 @@ fn add_one(x: i32) -> i32 {
 }
 ```
 
-Rust functions return exactly one value, and you declare the type after an
-"arrow," which is a dash (`-`) followed by a greater-than sign (`>`).
+Функции в Rust возвращают ровно одно значение, тип которого объявляется после
+"стрелки". "Стрелка" представляет собой дефис (`-`), за которым следует знак
+"больше" (`>`).
 
-You'll note the lack of a semicolon here. If we added it in:
+Заметьте, что в функции выше нет точки с запятой. Если бы мы добавили этот знак:
 
 ```{rust,ignore}
 fn add_one(x: i32) -> i32 {
@@ -96,7 +98,7 @@ fn add_one(x: i32) -> i32 {
 }
 ```
 
-We would get an error:
+Мы бы получили ошибку:
 
 ```text
 error: not all control paths return a value
@@ -109,19 +111,23 @@ help: consider removing this semicolon:
           ^
 ```
 
-Remember our earlier discussions about semicolons and `()`? Our function claims
-to return an `i32`, but with a semicolon, it would return `()` instead. Rust
-realizes this probably isn't what we want, and suggests removing the semicolon.
+Помните мы обсуждали точку с запятой и тривиальное значение `()` (unit)?
+Наша функция объявлена, как возвращающая `i32`. Но если в конце есть точка с
+запятой, функция вернёт тривиальное значение `()`. Компилятор Rust обрабатывает
+эту ситуацию и предлагает удалить точку с запятой.
 
-This is very much like our `if` statement before: the result of the block
-(`{}`) is the value of the expression. Other expression-oriented languages,
-such as Ruby, work like this, but it's a bit unusual in the systems programming
-world. When people first learn about this, they usually assume that it
-introduces bugs. But because Rust's type system is so strong, and because unit
-is its own unique type, we have never seen an issue where adding or removing a
-semicolon in a return position would cause a bug.
+Это очень похоже на оператор `if`: результат блока (`{}`) это результат выражения.
+Есть и другие языки программирования, в которых операторы возвращают
+значение - например, Ruby; однако, такая логика немного непривычна в мире
+системного программирования. Люди, впервые узнающие об этой возможности, часто
+считают, что она приводит к появлению ошибок. Однако, во-первых, Rust
+реализует строгую типизацию. Во-вторых, тривиальное значение `()` имеет
+уникальный тип. Поэтому мы никогда не видели ситуации, в которой добавление
+или удаление точки с запятой в позиции возвращаемого значения вызывало бы
+ошибку.
 
-But what about early returns? Rust does have a keyword for that, `return`:
+А что насчёт раннего возврата из функции? У нас есть для этого ключевое слово
+`return`:
 
 ```rust
 fn foo(x: i32) -> i32 {
@@ -131,8 +137,8 @@ fn foo(x: i32) -> i32 {
 }
 ```
 
-Using a `return` as the last line of a function works, but is considered poor
-style:
+`return` можно написать и в последней строке тела функции, но это считается
+плохим стилем:
 
 ```rust
 fn foo(x: i32) -> i32 {
@@ -142,10 +148,10 @@ fn foo(x: i32) -> i32 {
 }
 ```
 
-The previous definition without `return` may look a bit strange if you haven't
-worked in an expression-based language before, but it becomes intuitive over
-time. If this were production code, we wouldn't write it in that way anyway,
-we'd write this:
+Если вы никогда не работали с языком, в котором операторы являются выражениями,
+предыдущее определение без `return` может показаться вам странным. Но со
+временем вы просто перестанете замечать это. К тому же, если бы это был
+настоящий код, мы бы всё равно не написали его так. Этот вариант лучше:
 
 ```rust
 fn foo(x: i32) -> i32 {
@@ -157,37 +163,38 @@ fn foo(x: i32) -> i32 {
 }
 ```
 
-Because `if` is an expression, and it's the only expression in this function,
-the value will be the result of the `if`.
+Поскольку оператор `if` является выражением, и это единственное выражение в этой
+функции, значением `foo` будет результат оператора `if`.
 
-## Diverging functions
+## Расходящиеся функции
 
-Rust has some special syntax for 'diverging functions', which are functions that
-do not return:
+Для функций, которые не возвращают управление ("расходящихся"), в Rust есть
+специальный синтаксис:
 
 ```
 fn diverges() -> ! {
-    panic!("This function never returns!");
+    panic!("Эта функция не возвращает управление!");
 }
 ```
 
-`panic!` is a macro, similar to `println!()` that we've already seen. Unlike
-`println!()`, `panic!()` causes the current thread of execution to crash with
-the given message.
+`panic!` - это макрос, как и `println!()`, который мы встречали ранее. В
+отличие от `println!()`, `panic!()` вызывает остановку текущего потока
+исполнения с заданным сообщением.
 
-Because this function will cause a crash, it will never return, and so it has
-the type '`!`', which is read "diverges." A diverging function can be used
-as any type:
+Поскольку эта функция вызывает остановку исполнения, она никогда не вернёт
+управление. Поэтому тип её возвращаемого значения обозначается знаком `!` и
+читается как "расходится". Значение расходящейся функции может быть
+использовано как значение любого типа:
 
 ```should_panic
 # fn diverges() -> ! {
-#    panic!("This function never returns!");
+#    panic!("Эта функция никогда не выходит!");
 # }
 
 let x: i32 = diverges();
 let x: String = diverges();
 ```
 
-We don't have a good use for diverging functions yet, because they're used in
-conjunction with other Rust features. But when you see `-> !` later, you'll
-know what it's called.
+Пока эта возможность выглядит бесполезной. Она приобретает значение в
+сочетании с другими возможностями Rust. Но по крайней мере, если вы увидите
+` -> !`, вы будете знать, что это такое.
