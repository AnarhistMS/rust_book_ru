diff --git a/rust/master:src/doc/trpl/patterns.md b/HEAD:patterns.md
index 266c1ca..c59ff1b 100644
--- a/rust/master:src/doc/trpl/patterns.md
+++ b/HEAD:patterns.md
@@ -1,256 +1,260 @@
-% Patterns
+% –®–∞–±–ª–æ–Ω—ã —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏—è `match`
 
-Patterns are quite common in Rust. We use them in [variable
-bindings][bindings], [match statements][match], and other places, too. Let‚Äôs go
-on a whirlwind tour of all of the things patterns can do!
+–®–∞–±–ª–æ–Ω—ã –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —á–∞—Å—Ç–æ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –≤ Rust. –ú—ã —É–∂–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ –∏—Ö –≤ —Ä–∞–∑–¥–µ–ª–µ
+[–°–≤—è–∑—ã–≤–∞–Ω–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö][bindings], –≤ —Ä–∞–∑–¥–µ–ª–µ [–ö–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏—è `match`][match], –∞
+—Ç–∞–∫–∂–µ –≤ –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö –¥—Ä—É–≥–∏—Ö –º–µ—Å—Ç–∞—Ö. –î–∞–≤–∞–π—Ç–µ –∫–æ—Ä–æ—Ç–∫–æ –ø—Ä–æ–±–µ–∂–∏–º—Å—è –ø–æ –≤—Å–µ–º
+–≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—è–º, –∫–æ—Ç–æ—Ä—ã–µ –º–æ–∂–Ω–æ —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å —Å –ø–æ–º–æ—â—å—é —à–∞–±–ª–æ–Ω–æ–≤!
 
 [bindings]: variable-bindings.html
 [match]: match.html
 
-A quick refresher: you can match against literals directly, and `_` acts as an
-‚Äòany‚Äô case:
+–ë—ã—Å—Ç—Ä–æ –æ—Å–≤–µ–∂–∏–º –≤ –ø–∞–º—è—Ç–∏: —Å–æ–ø–æ—Å—Ç–∞–≤–ª—è—Ç—å —Å —à–∞–±–ª–æ–Ω–æ–º –ª–∏—Ç–µ—Ä–∞–ª—ã –º–æ–∂–Ω–æ –ª–∏–±–æ –Ω–∞–ø—Ä—è–º—É—é,
+–ª–∏–±–æ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º —Å–∏–º–≤–æ–ª–∞ `_`, –∫–æ—Ç–æ—Ä—ã–π –æ–∑–Ω–∞—á–∞–µ—Ç *–ª—é–±–æ–π* —Å–ª—É—á–∞–π:
 
 ```rust
 let x = 1;
 
 match x {
     1 => println!("one"),
     2 => println!("two"),
     3 => println!("three"),
     _ => println!("anything"),
 }
 ```
 
-This prints `one`.
+–≠—Ç–æ—Ç –∫–æ–¥ –Ω–∞–ø–µ—á–∞—Ç–∞–µ—Ç `one`.
 
-# Multiple patterns
+# –°–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ —Å –Ω–µ—Å–∫–æ–ª—å–∫–∏–º–∏ —à–∞–±–ª–æ–Ω–∞–º–∏
 
-You can match multiple patterns with `|`:
+–í—ã –º–æ–∂–µ—Ç–µ —Å–æ–ø–æ—Å—Ç–∞–≤–ª—è—Ç—å —Å –Ω–µ—Å–∫–æ–ª—å–∫–∏–º–∏ —à–∞–±–ª–æ–Ω–∞–º–∏, –∏—Å–ø–æ–ª—å–∑—É—è `|`:
 
 ```rust
 let x = 1;
 
 match x {
     1 | 2 => println!("one or two"),
     3 => println!("three"),
     _ => println!("anything"),
 }
 ```
 
-This prints `one or two`.
+–≠—Ç–æ—Ç –∫–æ–¥ –Ω–∞–ø–µ—á–∞—Ç–∞–µ—Ç `one or two`.
 
-# Ranges
+# –°–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ —Å –¥–∏–∞–ø–∞–∑–æ–Ω–æ–º
 
-You can match a range of values with `...`:
+–í—ã –º–æ–∂–µ—Ç–µ —Å–æ–ø–æ—Å—Ç–∞–≤–ª—è—Ç—å —Å –¥–∏–∞–ø–∞–∑–æ–Ω–æ–º –∑–Ω–∞—á–µ–Ω–∏–π, –∏—Å–ø–æ–ª—å–∑—É—è `...`:
 
 ```rust
 let x = 1;
 
 match x {
     1 ... 5 => println!("one through five"),
     _ => println!("anything"),
 }
 ```
 
-This prints `one through five`.
+–≠—Ç–æ—Ç –∫–æ–¥ –Ω–∞–ø–µ—á–∞—Ç–∞–µ—Ç `one through five`.
 
-Ranges are mostly used with integers and `char`s:
+–î–∏–∞–ø–∞–∑–æ–Ω—ã –≤ –æ—Å–Ω–æ–≤–Ω–æ–º –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è —Å —á–∏—Å–ª–∞–º–∏ –∏–ª–∏ –æ–¥–∏–Ω–æ—á–Ω—ã–º–∏ —Å–∏–º–≤–æ–ª–∞–º–∏ (`char`).
 
 ```rust
 let x = 'üíÖ';
 
 match x {
     'a' ... 'j' => println!("early letter"),
     'k' ... 'z' => println!("late letter"),
     _ => println!("something else"),
 }
 ```
 
-This prints `something else`
+–≠—Ç–æ—Ç –∫–æ–¥ –Ω–∞–ø–µ—á–∞—Ç–∞–µ—Ç `something else`.
 
-# Bindings
+# –°–≤—è–∑—ã–≤–∞–Ω–∏–µ
 
-You can bind values to names with `@`:
+–í—ã –º–æ–∂–µ—Ç–µ —Å–≤—è–∑–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ —Å –∏–º–µ–Ω–µ–º —Å –ø–æ–º–æ—â—å—é —Å–∏–º–≤–æ–ª–∞ `@`:
 
 ```rust
 let x = 1;
 
 match x {
     e @ 1 ... 5 => println!("got a range element {}", e),
     _ => println!("anything"),
 }
 ```
 
-This prints `got a range element 1`. This is useful when you want to
-do a complicated match of part of a data structure:
+–≠—Ç–æ—Ç –∫–æ–¥ –Ω–∞–ø–µ—á–∞—Ç–∞–µ—Ç `got a range element 1`. –≠—Ç–æ –ø–æ–ª–µ–∑–Ω–æ, –∫–æ–≥–¥–∞ –≤—ã —Ö–æ—Ç–∏—Ç–µ
+—Å–¥–µ–ª–∞—Ç—å —Å–ª–æ–∂–Ω–æ–µ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –¥–ª—è —á–∞—Å—Ç–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö:
 
 ```rust
 #[derive(Debug)]
 struct Person {
     name: Option<String>,
 }
 
 let name = "Steve".to_string();
 let mut x: Option<Person> = Some(Person { name: Some(name) });
 match x {
     Some(Person { name: ref a @ Some(_), .. }) => println!("{:?}", a),
     _ => {}
 }
 ```
 
-This prints `Some("Steve")`: We‚Äôve bound the inner `name` to `a`.
+–≠—Ç–æ—Ç –∫–æ–¥ –Ω–∞–ø–µ—á–∞—Ç–∞–µ—Ç `Some("Steve")`: –º—ã —Å–≤—è–∑–∞–ª–∏ –≤–Ω—É—Ç—Ä–µ–Ω–Ω—é—é `name` —Å `a`.
 
-If you use `@` with `|`, you need to make sure the name is bound in each part
-of the pattern:
+–ï—Å–ª–∏ –≤—ã –∏—Å–ø–æ–ª—å–∑—É–µ—Ç–µ `@` —Å–æ–≤–º–µ—Å—Ç–Ω–æ —Å `|`, —Ç–æ –≤—ã –¥–æ–ª–∂–Ω—ã —É–±–µ–¥–∏—Ç—å—Å—è, —á—Ç–æ –∏–º—è
+—Å–≤—è–∑—ã–≤–∞–µ—Ç—Å—è –≤ –∫–∞–∂–¥–æ–π –∏–∑ —á–∞—Å—Ç–µ–π —à–∞–±–ª–æ–Ω–∞:
 
 ```rust
 let x = 5;
 
 match x {
     e @ 1 ... 5 | e @ 8 ... 10 => println!("got a range element {}", e),
     _ => println!("anything"),
 }
 ```
 
-# Ignoring variants
+# –ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤
 
-If you‚Äôre matching on an enum which has variants, you can use `..` to
-ignore the value and type in the variant:
+–ï—Å–ª–∏ –ø—Ä–∏ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–∏ –≤—ã –∏—Å–ø–æ–ª—å–∑—É–µ—Ç–µ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ, —Å–æ–¥–µ—Ä–∂–∞—â–µ–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã, —Ç–æ –≤—ã
+–º–æ–∂–µ—Ç–µ —É–∫–∞–∑–∞—Ç—å `..`, —á—Ç–æ–±—ã –ø—Ä–æ–∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –∏ —Ç–∏–ø –≤ –≤–∞—Ä–∏–∞–Ω—Ç–µ:
 
 ```rust
 enum OptionalInt {
     Value(i32),
     Missing,
 }
 
 let x = OptionalInt::Value(5);
 
 match x {
     OptionalInt::Value(..) => println!("Got an int!"),
     OptionalInt::Missing => println!("No such luck."),
 }
 ```
 
-This prints `Got an int!`.
+–≠—Ç–æ—Ç –∫–æ–¥ –Ω–∞–ø–µ—á–∞—Ç–∞–µ—Ç `Got an int!`.
 
-# Guards
+# –û–≥—Ä–∞–Ω–∏—á–∏—Ç–µ–ª–∏ —à–∞–±–ª–æ–Ω–æ–≤
 
-You can introduce ‚Äòmatch guards‚Äô with `if`:
+–í—ã –º–æ–∂–µ—Ç–µ –≤–≤–µ—Å—Ç–∏ *–æ–≥—Ä–∞–Ω–∏—á–∏—Ç–µ–ª–∏ —à–∞–±–ª–æ–Ω–æ–≤* (*match guards*) —Å –ø–æ–º–æ—â—å—é `if`:
 
 ```rust
 enum OptionalInt {
     Value(i32),
     Missing,
 }
 
 let x = OptionalInt::Value(5);
 
 match x {
     OptionalInt::Value(i) if i > 5 => println!("Got an int bigger than five!"),
     OptionalInt::Value(..) => println!("Got an int!"),
     OptionalInt::Missing => println!("No such luck."),
 }
 ```
 
-This prints `Got an int!`
+–≠—Ç–æ—Ç –∫–æ–¥ –Ω–∞–ø–µ—á–∞—Ç–∞–µ—Ç `Got an int!`.
 
-# ref and ref mut
+# ref –∏ ref mut
 
-If you want to get a [reference][ref], use the `ref` keyword:
+–ï—Å–ª–∏ –≤—ã —Ö–æ—Ç–∏—Ç–µ –ø–æ–ª—É—á–∏—Ç—å [—Å—Å—ã–ª–∫—É][ref], —Ç–æ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ `ref`:
 
 ```rust
 let x = 5;
 
 match x {
     ref r => println!("Got a reference to {}", r),
 }
 ```
 
-This prints `Got a reference to 5`.
+–≠—Ç–æ—Ç –∫–æ–¥ –Ω–∞–ø–µ—á–∞—Ç–∞–µ—Ç `Got a reference to 5`.
 
 [ref]: references-and-borrowing.html
 
-Here, the `r` inside the `match` has the type `&i32`. In other words, the `ref`
-keyword _creates_ a reference, for use in the pattern. If you need a mutable
-reference, `ref mut` will work in the same way:
+–ó–¥–µ—Å—å `r` –≤–Ω—É—Ç—Ä–∏ `match` –∏–º–µ–µ—Ç —Ç–∏–ø `&i32`. –î—Ä—É–≥–∏–º–∏ —Å–ª–æ–≤–∞–º–∏, –∫–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ `ref`
+_—Å–æ–∑–¥–∞–µ—Ç_ —Å—Å—ã–ª–∫—É, –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ —à–∞–±–ª–æ–Ω–µ. –ï—Å–ª–∏ –≤–∞–º –Ω—É–∂–Ω–∞ –∏–∑–º–µ–Ω—è–µ–º–∞—è —Å—Å—ã–ª–∫–∞,
+—Ç–æ `ref mut` –±—É–¥–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å –∞–Ω–∞–ª–æ–≥–∏—á–Ω—ã–º –æ–±—Ä–∞–∑–æ–º:
 
 ```rust
 let mut x = 5;
 
 match x {
     ref mut mr => println!("Got a mutable reference to {}", mr),
 }
 ```
 
-# Destructuring
+# –î–µ—Å—Ç—Ä—É–∫—Ç—É—Ä–∏–∑–∞—Ü–∏—è
 
-If you have a compound data type, like a [`struct`][struct], you can destructure it
-inside of a pattern:
+–ï—Å–ª–∏ —É –≤–∞—Å –µ—Å—Ç—å —Å–ª–æ–∂–Ω—ã–π —Ç–∏–ø –¥–∞–Ω–Ω—ã—Ö, –Ω–∞–ø—Ä–∏–º–µ—Ä [`struct`][struct], –≤—ã –º–æ–∂–µ—Ç–µ
+–¥–µ—Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞—Ç—å –µ–≥–æ –≤–Ω—É—Ç—Ä–∏ —à–∞–±–ª–æ–Ω–∞:
 
 ```rust
 struct Point {
     x: i32,
     y: i32,
 }
 
 let origin = Point { x: 0, y: 0 };
 
 match origin {
     Point { x: x, y: y } => println!("({},{})", x, y),
 }
 ```
 
 [struct]: structs.html
 
-If we only care about some of the values, we don‚Äôt have to give them all names:
+–ï—Å–ª–∏ –Ω–∞–º –Ω—É–∂–Ω—ã –∑–Ω–∞—á–µ–Ω–∏—è —Ç–æ–ª—å–∫–æ –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö –∏–∑ –ø–æ–ª–µ–π —Å—Ç—Ä—É–∫—Ç—É—Ä—ã, —Ç–æ –º—ã –º–æ–∂–µ–º –Ω–µ
+–ø—Ä–∏—Å–≤–∞–∏–≤–∞—Ç—å –∏–º –≤—Å–µ–º –∏–º–µ–Ω–∞:
 
 ```rust
 struct Point {
     x: i32,
     y: i32,
 }
 
 let origin = Point { x: 0, y: 0 };
 
 match origin {
     Point { x: x, .. } => println!("x is {}", x),
 }
 ```
 
-This prints `x is 0`.
+–≠—Ç–æ—Ç –∫–æ–¥ –Ω–∞–ø–µ—á–∞—Ç–∞–µ—Ç `x is 0`.
 
-You can do this kind of match on any member, not just the first:
+–í—ã –º–æ–∂–µ—Ç–µ —Å–¥–µ–ª–∞—Ç—å —ç—Ç–æ –¥–ª—è –ª—é–±–æ–≥–æ –ø–æ–ª—è, –∞ –Ω–µ —Ç–æ–ª—å–∫–æ –¥–ª—è –ø–µ—Ä–≤–æ–≥–æ:
 
 ```rust
 struct Point {
     x: i32,
     y: i32,
 }
 
 let origin = Point { x: 0, y: 0 };
 
 match origin {
     Point { y: y, .. } => println!("y is {}", y),
 }
 ```
 
-This prints `y is 0`.
+–≠—Ç–æ—Ç –∫–æ–¥ –Ω–∞–ø–µ—á–∞—Ç–∞–µ—Ç `y is 0`.
 
-This ‚Äòdestructuring‚Äô behavior works on any compound data type, like
-[tuples][tuples] or [enums][enums].
+–¢–∞–∫–æ–µ ‚Äò–¥–µ—Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ‚Äò —Ä–∞–±–æ—Ç–∞–µ—Ç –¥–ª—è –ª—é–±—ã—Ö —Å–ª–æ–∂–Ω—ã—Ö —Ç–∏–ø–æ–≤ –¥–∞–Ω–Ω—ã—Ö, —Ç–∞–∫–∏—Ö –∫–∞–∫
+[–∫–æ—Ä—Ç–µ–∂–∏][tuples] –∏–ª–∏ [–ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è][enums].
 
 [tuples]: primitive-types.html#tuples
 [enums]: enums.html
 
 # Mix and Match
 
-Whew! That‚Äôs a lot of different ways to match things, and they can all be
-mixed and matched, depending on what you‚Äôre doing:
+–í–æ—Ç —Ç–∞–∫! –°—É—â–µ—Å—Ç–≤—É–µ—Ç –º–Ω–æ–≥–æ —Ä–∞–∑–Ω—ã—Ö —Å–ø–æ—Å–æ–±–æ–≤ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏
+—Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏—è —Å —à–∞–±–ª–æ–Ω–æ–º, –∏ –≤—Å–µ –æ–Ω–∏ –º–æ–≥—É—Ç –±—ã—Ç—å —Å–º–µ—à–∞–Ω—ã –∏ —Å–æ—Å—Ç—ã–∫–æ–≤–∞–Ω—ã, –≤
+–∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–æ–≥–æ, —á—Ç–æ –≤—ã —Ö–æ—Ç–∏—Ç–µ —Å–¥–µ–ª–∞—Ç—å:
 
 ```rust,ignore
 match x {
     Foo { x: Some(ref name), y: None } => ...
 }
 ```
 
-Patterns are very powerful. Make good use of them.
+–®–∞–±–ª–æ–Ω—ã —è–≤–ª—è—é—Ç—Å—è –æ—á–µ–Ω—å –º–æ—â–Ω—ã–º –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–º. –ò—Ö –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –Ω–∞—Ö–æ–¥–∏—Ç –æ—á–µ–Ω—å
+—à–∏—Ä–æ–∫–æ–µ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ.
