diff --git a/rust/master:src/doc/trpl/patterns.md b/HEAD:patterns.md
index c88e3a0..e536534 100644
--- a/rust/master:src/doc/trpl/patterns.md
+++ b/HEAD:patterns.md
@@ -1,196 +1,206 @@
-% Patterns
+% Шаблоны `match`
 
-Patterns are quite common in Rust. We use them in [variable
-bindings][bindings], [match statements][match], and other places, too. Let’s go
-on a whirlwind tour of all of the things patterns can do!
+Мы уже использовали шаблоны несколько раз в этом руководстве: сначала при
+рассмотрении оператора `let`, а затем при изучении конструкции `match`. Давайте
+коротко пробежимся по всем возможностям, которые можно реализовать с помощью
+шаблонов!
 
-[bindings]: variable-bindings.html
-[match]: match.html
+Быстро освежим в памяти: сопоставлять с образцами литералы можно либо напрямую,
+либо с помощью символа `_`, который означает *любой* случай:
 
-A quick refresher: you can match against literals directly, and `_` acts as an
-‘any’ case:
-
-```rust
+```{rust}
 let x = 1;
 
 match x {
     1 => println!("one"),
     2 => println!("two"),
     3 => println!("three"),
     _ => println!("anything"),
 }
 ```
 
-# Multiple patterns
+Вы можете сопоставлять с несколькими шаблонами, используя `|`:
 
-You can match multiple patterns with `|`:
-
-```rust
+```{rust}
 let x = 1;
 
 match x {
     1 | 2 => println!("one or two"),
     3 => println!("three"),
     _ => println!("anything"),
 }
 ```
 
-# Ranges
+Вы можете сопоставлять с диапазоном значений, используя `...`:
 
-You can match a range of values with `...`:
-
-```rust
+```{rust}
 let x = 1;
 
 match x {
     1 ... 5 => println!("one through five"),
     _ => println!("anything"),
 }
 ```
 
-Ranges are mostly used with integers and single characters.
+Диапазоны в основном используются с числами или одиночными символами.
 
-# Bindings
+Если вы используете множественное сопоставление, с помощью `|` или `...`, вы
+можете присвоить значение переменной с именем `@`:
 
-If you’re matching multiple things, via a `|` or a `...`, you can bind
-the value to a name with `@`:
-
-```rust
+```{rust}
 let x = 1;
 
 match x {
     e @ 1 ... 5 => println!("got a range element {}", e),
     _ => println!("anything"),
 }
 ```
 
-# Ignoring variants
+Если при сопоставлении вы используете перечисление, содержащее варианты, то вы
+можете указать `..`, чтобы проигнорировать значение и тип в варианте:
 
-If you’re matching on an enum which has variants, you can use `..` to
-ignore the value and type in the variant:
-
-```rust
+```{rust}
 enum OptionalInt {
     Value(i32),
     Missing,
 }
 
 let x = OptionalInt::Value(5);
 
 match x {
     OptionalInt::Value(..) => println!("Got an int!"),
     OptionalInt::Missing => println!("No such luck."),
 }
 ```
 
-# Guards
+Вы можете ввести *ограничители шаблонов сопоставления* (*match guards*) с
+помощью `if`:
 
-You can introduce ‘match guards’ with `if`:
-
-```rust
+```{rust}
 enum OptionalInt {
     Value(i32),
     Missing,
 }
 
 let x = OptionalInt::Value(5);
 
 match x {
     OptionalInt::Value(i) if i > 5 => println!("Got an int bigger than five!"),
     OptionalInt::Value(..) => println!("Got an int!"),
     OptionalInt::Missing => println!("No such luck."),
 }
 ```
 
-# ref and ref mut
+Если вы сопоставляете с указателем, то вы можете использовать тот же синтаксис,
+что и при его объявлении. Во-первых, `&`:
 
-If you want to get a [reference][ref], use the `ref` keyword:
+```{rust}
+let x = &5;
 
-```rust
+match x {
+    &val => println!("Got a value: {}", val),
+}
+```
+
+Здесь `val` внутри `match` имеет тип `i32`. Другими словами, в левой части
+шаблона сопоставления значение деструктурируется. Если `&val` соответствует
+`&5`, то `val` будет `5`.
+
+Если же вы хотите получить ссылку, то используйте ключевое слово `ref`:
+
+```{rust}
 let x = 5;
 
 match x {
     ref r => println!("Got a reference to {}", r),
 }
 ```
 
-[ref]: references-and-borrowing.html
+Здесь `r` внутри `match` имеет тип `&i32`. Другими словами, ключевое слово `ref`
+_создает_ ссылку, для использования в шаблоне. Если вам нужна изменяемая ссылка,
+то `ref mut` будет работать аналогичным образом:
 
-Here, the `r` inside the `match` has the type `&i32`. In other words, the `ref`
-keyword _creates_ a reference, for use in the pattern. If you need a mutable
-reference, `ref mut` will work in the same way:
-
-```rust
+```{rust}
 let mut x = 5;
 
 match x {
     ref mut mr => println!("Got a mutable reference to {}", mr),
 }
 ```
 
-# Destructuring
+Если у вас есть структура, вы можете деструктурировать ее внутри шаблона:
 
-If you have a compound data type, like a `struct`, you can destructure it
-inside of a pattern:
-
-```rust
+```{rust}
+# #![allow(non_shorthand_field_patterns)]
 struct Point {
     x: i32,
     y: i32,
 }
 
 let origin = Point { x: 0, y: 0 };
 
 match origin {
     Point { x: x, y: y } => println!("({},{})", x, y),
 }
 ```
 
-If we only care about some of the values, we don’t have to give them all names:
+Если нам нужны значения только некоторых из полей структуры, то мы можем не
+присваивать им всем имена:
 
-```rust
+```{rust}
+# #![allow(non_shorthand_field_patterns)]
 struct Point {
     x: i32,
     y: i32,
 }
 
 let origin = Point { x: 0, y: 0 };
 
 match origin {
     Point { x: x, .. } => println!("x is {}", x),
 }
 ```
 
-You can do this kind of match on any member, not just the first:
+Вы можете сделать это для любого поля, а не только для первого:
 
-```rust
+```{rust}
+# #![allow(non_shorthand_field_patterns)]
 struct Point {
     x: i32,
     y: i32,
 }
 
 let origin = Point { x: 0, y: 0 };
 
 match origin {
     Point { y: y, .. } => println!("y is {}", y),
 }
 ```
 
-This ‘destructuring’ behavior works on any compound data type, like
-[tuples][tuples] or [enums][enums].
+Если вы хотите использовать сопоставление со срезом или массивом, то вы можете
+указать `&`:
 
-[tuples]: primitive-types.html#tuples
-[enums]: enums.html
+```{rust}
+# #![feature(slice_patterns)]
+fn main() {
+    let v = vec!["match_this", "1"];
 
-# Mix and Match
+    match &v[..] {
+        ["match_this", second] => println!("The second element is {}", second),
+        _ => {},
+    }
+}
+```
 
-Whew! That’s a lot of different ways to match things, and they can all be
-mixed and matched, depending on what you’re doing:
+Вот так! Существует много разных способов использования конструкции
+сопоставления с шаблоном, и все они могут быть смешаны и состыкованы, в
+зависимости от того, что вы хотите сделать:
 
 ```{rust,ignore}
 match x {
     Foo { x: Some(ref name), y: None } => ...
 }
 ```
 
-Patterns are very powerful.  Make good use of them.
+Шаблоны являются очень мощным инструментом. Их использование находит очень
+широкое применение.
