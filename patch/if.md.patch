diff --git a/rust/master:src/doc/trpl/if.md b/HEAD:if.md
index a532dab..029a197 100644
--- a/rust/master:src/doc/trpl/if.md
+++ b/HEAD:if.md
@@ -1,73 +1,156 @@
-% if
+% Конструкция `if`
 
-Rust’s take on `if` is not particularly complex, but it’s much more like the
-`if` you’ll find in a dynamically typed language than in a more traditional
-systems language. So let’s talk about it, to make sure you grasp the nuances.
+`if` в Rust'е не сильно сложен и больше похож на `if` в динамически 
+типизированных языках, чем на более традиционный из системных. Давайте 
+поговорим о нём, чтобы вы поняли некоторые его нюансы.
 
-`if` is a specific form of a more general concept, the ‘branch’. The name comes
-from a branch in a tree: a decision point, where depending on a choice,
-multiple paths can be taken.
+`if` является одной из форм более общего понятия, именуемого *ветвлением*.
+Это название произошло от ветвей деревьев: конечный результат зависит от того, 
+какой из нескольких вариантов будет выбран.
 
-In the case of `if`, there is one choice that leads down two paths:
+`if` содержит одно условие, в зависимости от которого будет выполняться одна из 
+двух ветвей:
 
 ```rust
 let x = 5;
 
 if x == 5 {
-    println!("x is five!");
+    println!("x равняется пяти!");
 }
 ```
 
-If we changed the value of `x` to something else, this line would not print.
-More specifically, if the expression after the `if` evaluates to `true`, then
-the block is executed. If it’s `false`, then it is not.
+При изменении значения `x` на какое-либо другое, эта строчка не будет выведена 
+на экран.
+Если подробнее, то когда условие, будет иметь значение `true`, следующий после 
+него блок кода, выполнится. В противном случае - нет.
 
-If you want something to happen in the `false` case, use an `else`:
+Бывает нужно что-то выполнить, если условие не выполнится (выражение будет иметь 
+значение false). В таком случае можно использовать `else`:
 
-```rust
+```{rust}
 let x = 5;
 
 if x == 5 {
-    println!("x is five!");
+    println!("x равняется пяти!");
 } else {
-    println!("x is not five :(");
+    println!("x это не пять :(");
 }
 ```
 
-If there is more than one case, use an `else if`:
+Когда необходимо больше одного выбора, то можно использовать `else if`:
 
 ```rust
 let x = 5;
 
 if x == 5 {
-    println!("x is five!");
+    println!("x равняется пяти!");
 } else if x == 6 {
-    println!("x is six!");
+    println!("x это шесть!");
 } else {
-    println!("x is not five or six :(");
+    println!("x это ни пять, ни шесть :(");
 }
 ```
 
-This is all pretty standard. However, you can also do this:
+Всё это довольно прозаично. Однако, вы так же можете сделать такую штуку:
 
-```rust
+```{rust}
 let x = 5;
 
 let y = if x == 5 {
     10
 } else {
     15
 }; // y: i32
 ```
 
-Which we can (and probably should) write like this:
+Которую мы можем (и должны) записать примерно следующим образом:
 
-```rust
+```{rust}
 let x = 5;
 
 let y = if x == 5 { 10 } else { 15 }; // y: i32
 ```
 
-This works because `if` is an expression. The value of the expression is the
-value of the last expression in whichever branch was chosen. An `if` without an
-`else` always results in `()` as the value.
+Здесь показаны две интересные особенности Rust'а. Во-первых, это выражение-ориентированный 
+язык, и во-вторых, смысл точки с запятой отличается от смысла аналогичного символа 
+в других `фигурные скобки и точка с запятой`-основанных языках. Эти две 
+особенности связаны.
+
+## Выражения и операторы
+
+Rust - в первую очередь выражение-ориентированный язык. Есть только два типа
+операторов, а всё остальное является выражением.
+
+А в чём же разница? Выражение возвращает значение, в то время как оператор - нет.
+Во многих языках `if` является оператором и поэтому `let x = if ...` не будет 
+иметь смысла. Но в Rust'е `if` - это выражение, и значит он возвращает значение. 
+Благодаря этому, мы можем использовать его для инициализации связи.
+
+К слову говоря, связывание - это первый из двух типов операторов в Rust, который
+правильнее называть *оператор объявления*. Итак, как мы видим, `let` это только 
+вид оператора объявления. Давайте ещё немного поговорим об этом.
+
+В некоторых языках, связывание переменных может быть записано как выражение, а не
+только как оператор. Например, в Ruby:
+
+```{ruby}
+x = y = 5
+```
+
+Однако, в Rust'е использование `let` для создания связи _не является_ выражением.
+Следующий код вызовет ошибку компиляции:
+
+```{ignore}
+let x = (let y = 5); // expected identifier, found keyword `let`
+```
+
+Здесь компилятор сообщил нам, что ожидал увидеть выражение, но `let` является 
+оператором, а не выражением.
+
+Обратите внимание, что присвоение уже связанной переменной (н-р: `y = 5`) является
+выражением, но его значение не особенно полезно. В отличие от C, где присвоение
+вычисляется в присваиваемое значение (н-р: `5` из предыдущего примера), в Rust
+значением присвоения является единичный тип `()` (о котором мы поговорим дальше).
+
+Вторым типом операторов в Rust'е является *оператор выражения*. Его цель - превратить
+любое выражение в оператор. В практическом плане, грамматика Rust'а ожидает что 
+за операторами будут идти другие операторы. Это означает, что вы используете 
+точку с запятой для разделения выражений друг от друга. Rust выглядит как многие 
+другие языки, которые требуют использовать точку с запятой в конце каждой строки
+и вы увидите её в конце почти каждой строки кода на Rust.
+
+Из-за чего мы говорим "почти"? Вы это уже видели в этом примере:
+
+```{rust}
+let x = 5;
+
+let y: i32 = if x == 5 { 10 } else { 15 };
+```
+
+Заметьте, что я указал тип для `y`. `y` должна быть целым 32-х битным числом..
+
+Следующий пример не соберётся:
+
+```{ignore}
+let x = 5;
+
+let y: i32 = if x == 5 { 10; } else { 15; };
+```
+
+Обратите внимание, что точка с запятой стоит после 10 и 15. Rust выдаст нам 
+следующую ошибку:
+
+```text
+error: mismatched types: expected `i32`, found `()` (expected i32, found ())
+```
+
+Мы ожидали целое число, а получили `()`. `()` - это *единичный тип*, являющийся
+специальным типом в системе типов Rust'а. В Rust'е, `()` _не является_ корректным 
+значением для переменной типа `i32`. Он является правильным только для переменных 
+типа `()`, которые не очень полезны. Помните как мы вызвали оператор, который не 
+возвращал значение? Что ж, каков же смысл единичного типа в данном случае?
+Точка с запятой превращает любые выражения в операторы, отбрасывая из значение 
+и возвращая вместо него `()`.
+
+Есть ещё один случай, когда не увидите точку с запятой в конце строки. Для этого
+вам надо познакомиться с другим концептом: функциями.
