% Дженерики (обобщённые типы)

Иногда, при написании функции или типа данных, мы можем захотеть, чтобы они работали для нескольких типов аргументов. Например, помните тип `OptionalInt`?

```{rust}
enum OptionalInt {
    Value(i32),
    Missing,
}
```

Если мы также захотим иметь `OptionalFloat64`, то нам потребуется новое перечисление:

```{rust}
enum OptionalFloat64 {
    Valuef64(f64),
    Missingf64,
}
```

Это не очень удобно. К счастью, у Rust есть фича, которая дает нам лучший способ реализовать это: дженерики (обобщённые типы). Дженериками называется *параметрический полиморфизм* в теории типов. Это означает, что они являются типами или функциями, которые имеют несколько форм (*poly* - кратно, *morph* - форма) по данному параметру (*параметрический*).

В любом случае, достаточно с декларациями теории типов, давайте проверим общую форму `OptionalInt`. На самом деле этот обобщённый тип определен в самом Rust, и выглядит следующим образом:

```rust
enum Option<T> {
    Some(T),
    None,
}
```

Часть `<T>`, которую вы уже видели несколько раз прежде, указывает, что это обобщённый тип данных. Внутри перечисления, везде, где мы видим `T`, мы  подставляем вместо этого абстактного типа тот, который используется в дженерике. Вот пример использования `Option<T>` с некоторыми дополнительными аннотациями типов:

```{rust}
let x: Option<i32> = Some(5);
```

В определении типа мы используем `Option<i32>`. Обратите внимание, что это очень похоже на `Option<T>`. С той лишь разницей, что, в данном конкретном `Option`, `T` имеет значение `i32`. В правой стороне выражения, мы используем `Some(T)`, где `T` равно `5`. Так как `5` является представителем типа `i32`, то типы по обе стороны совпадают, отчего Rust счастлив. Если же они не совпадают, то мы получим ошибку:

```{rust,ignore}
let x: Option<f64> = Some(5);
// error: mismatched types: expected `core::option::Option<f64>`,
// found `core::option::Option<_>` (expected f64 but found integral variable)
```

Но это не значит, что мы не можем сделать `Option<T>`, который содержит `f64`! Просто с левой и с правой сторон выражения объявления переменной типы должны совпадать:

```{rust}
let x: Option<i32> = Some(5);
let y: Option<f64> = Some(5.0f64);
```

Это просто прекрасно. Одно определение - многостороннее использование.

Дженерики могут быть обобщёнными не только для одного единственного типа. Рассмотрим встроенный в Rust тип `Result<T, E>`:

```{rust}
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

Этот тип является обобщённым сразу для _двух_ типов: `T` и `E`. Кстати, заглавные буквы может быть любыми, какими хотите. Мы могли бы определить `Result<T, E>` как:

```{rust}
enum Result<A, Z> {
    Ok(A),
    Err(Z),
}
```

если бы захотели. Соглашение гласит, что первый обобщённый параметр должен быть: `T` - для 'типа', и `E` - для 'ошибки.' Но Rust не проверяет этого.

Тип `Result<T, E>` предназначен для того, чтобы возвращать результат вычисления, и имеет возможность вернуть ошибку, если произойдет какой-либо сбой. Вот пример:

```{rust}
let x: Result<f64, String> = Ok(2.3f64);
let y: Result<f64, String> = Err("There was an error.".to_string());
```

Этот конкретный `Result` вернет `f64` в случае успеха и `String` в случае неудачи. Давайте напишем функцию, которая использует `Result<T, E>`:

```{rust}
fn inverse(x: f64) -> Result<f64, String> {
    if x == 0.0f64 { return Err("x cannot be zero!".to_string()); }

    Ok(1.0f64 / x)
}
```

Мы не можем получить элемент, обратный нулю, поэтому мы проверяем, что бы в качестве входного значения не был передан нуль. Если все же нуль был передан, то мы возвращаем `Err` с сообщением. Если же нет, то мы возвращаем `Ok` с ответом.

Почему это важно? Помните как `match` делает всеобъемлющую обработку значения? Вот как обрабатывается результат этой функции:

```{rust}
# fn inverse(x: f64) -> Result<f64, String> {
#     if x == 0.0f64 { return Err("x cannot be zero!".to_string()); }
#     Ok(1.0f64 / x)
# }
let x = inverse(25.0f64);

match x {
    Ok(x) => println!("The inverse of 25 is {}", x),
    Err(msg) => println!("Error: {}", msg),
}
```

`match` обеспечивает обработку случая с `Err`. Кроме того, поскольку ответ завернут в `Ok`, мы не можем просто использовать результат, не используя при этом деструктурирования:

```{rust,ignore}
let x = inverse(25.0f64);
println!("{}", x + 2.0f64); // error: binary operation `+` cannot be applied
           // to type `core::result::Result<f64,collections::string::String>`
```

Эта функция хороша, но есть еще одна проблема: она работает только для 64 битных значений с плавающей точкой. Что делать, если мы хотим работать так же и с 32 битными значениями с плавающей точкой? Тогда мы должны написать так:

```{rust}
fn inverse32(x: f32) -> Result<f32, String> {
    if x == 0.0f32 { return Err("x cannot be zero!".to_string()); }

    Ok(1.0f32 / x)
}
```

Облом. Все, что нам нужно, это *дженерик функция*. К счастью, мы уже можем написать нечто подобное! Тем не менее, она будет не совсем еще работать. Прежде, чем мы пойдем дальше, давайте поговорим о синтаксисе. Дженерик версия `inverse` будет выглядеть примерно так:

```{rust,ignore}
fn inverse<T>(x: T) -> Result<T, String> {
    if x == 0.0 { return Err("x cannot be zero!".to_string()); }

    Ok(1.0 / x)
}
```

Для объявления `inverse<T>` мы используем такой же синтаксис, как и для `Option<T>`. Затем мы можем использовать `T` внутри остальной части сигнатуры: `x` имеет тип `T`, и часть `Result` имеет тип `T`. Однако, если мы попытаемся скомпилировать этот пример, мы получим ошибку:

```text
error: binary operation `==` cannot be applied to type `T`
```

Поскольку `T` может быть _любым_ типом, даже типом, который не реализует `==`, то, следовательно, в первой строке будет ошибка. Что же делать?

Чтобы исправить этот пример, мы должны узнать о другой фиче Rust: трейты.
