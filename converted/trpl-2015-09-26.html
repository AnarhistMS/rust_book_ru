<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="The Rust Team">
  <meta name="dcterms.date" content="2015-09-26">
  <title>The Rust Programming Language</title>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; background-color: #f8f8f8; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
pre, code { background-color: #f8f8f8; }
code > span.kw { color: #204a87; font-weight: bold; }
code > span.dt { color: #204a87; }
code > span.dv { color: #0000cf; }
code > span.bn { color: #0000cf; }
code > span.fl { color: #0000cf; }
code > span.ch { color: #4e9a06; }
code > span.st { color: #4e9a06; }
code > span.co { color: #8f5902; font-style: italic; }
code > span.ot { color: #8f5902; }
code > span.al { color: #ef2929; }
code > span.fu { color: #000000; }
code > span.er { font-weight: bold; }
  </style>
  <link href="data:text/css,%2F%2A%2A%0A%20%2A%20%23%20Stylesheet%20for%20Pandoc%20Documents%0A%20%2A%2F%0A%0A%2F%2A%2A%0A%20%2A%20%23%23%20Fonts%0A%20%2A%2F%0A%0Abody%20%7B%0A%20%20font%2Dfamily%3A%20Georgia%2C%20Palatino%2C%20%27Palatino%20Linotype%27%2C%20Times%2C%20%27Times%20New%20Roman%27%2C%20serif%3B%0A%20%20font%2Dsize%3A%2012px%3B%0A%20%20line%2Dheight%3A%201%2E7%3B%0A%20%20max%2Dwidth%3A%2042em%3B%0A%7D%0A%0A%40media%20only%20screen%20and%20%28min%2Dwidth%3A%20480px%29%20%7B%0A%20%20body%20%7B%0A%20%20%20%20font%2Dsize%3A%2014px%3B%0A%20%20%7D%0A%7D%0A%40media%20only%20screen%20and%20%28min%2Dwidth%3A%20768px%29%20%7B%0A%20%20body%20%7B%0A%20%20%20%20font%2Dsize%3A%2016px%3B%0A%20%20%7D%0A%7D%0A%0Ah1%2C%20h2%2C%20h3%2C%20h4%2C%20h5%2C%20h6%20%7B%0A%20%20line%2Dheight%3A%20125%25%3B%0A%7D%0A%0Ah1%2C%20h2%2C%20h3%20%7B%0A%20%20font%2Dweight%3A%20normal%3B%0A%7D%0A%0Ah4%2C%20h5%2C%20h6%20%7B%0A%20%20font%2Dweight%3A%20bold%3B%0A%7D%0A%0Ah1%20%7B%0A%20%20font%2Dsize%3A%202em%3B%0A%7D%0A%0Ah2%20%7B%0A%20%20font%2Dsize%3A%201%2E8em%3B%0A%7D%0A%0Ah3%20%7B%0A%20%20font%2Dsize%3A%201%2E5em%3B%0A%7D%0A%0Ah4%20%7B%0A%20%20font%2Dsize%3A%201%2E2em%3B%0A%7D%0A%0Ah5%20%7B%0A%20%20font%2Dsize%3A%201em%3B%0A%7D%0A%0Ah6%20%7B%0A%20%20font%2Dsize%3A%200%2E9em%3B%0A%7D%0A%0Apre%2C%20code%2C%20kbd%2C%20samp%20%7B%0A%20%20font%2Dfamily%3A%20monospace%3B%0A%20%20font%2Dsize%3A%200%2E98em%3B%0A%7D%0A%0A%2F%2A%2A%0A%20%2A%20%23%23%20Other%20Styles%0A%20%2A%2F%0A%0Ahtml%20%7B%0A%20%20font%2Dsize%3A%20100%25%3B%0A%20%20overflow%2Dy%3A%20scroll%3B%0A%20%20%2Dwebkit%2Dtext%2Dsize%2Dadjust%3A%20100%25%3B%0A%20%20%2Dms%2Dtext%2Dsize%2Dadjust%3A%20100%25%3B%0A%7D%0A%0Abody%20%7B%0A%20%20color%3A%20%23444%3B%0A%20%20padding%3A%201em%3B%0A%20%20margin%3A%20auto%3B%0A%20%20background%3A%20%23fefefe%3B%0A%7D%0A%0Aa%20%7B%0A%20%20color%3A%20%230645ad%3B%0A%20%20text%2Ddecoration%3A%20none%3B%0A%7D%0A%0Aa%3Avisited%20%7B%0A%20%20color%3A%20%230b0080%3B%0A%7D%0A%0Aa%3Ahover%20%7B%0A%20%20color%3A%20%2306e%3B%0A%7D%0A%0Aa%3Aactive%20%7B%0A%20%20color%3A%20%23faa700%3B%0A%7D%0A%0Aa%3Afocus%20%7B%0A%20%20outline%3A%20thin%20dotted%3B%0A%7D%0A%0A%2A%3A%3A%2Dmoz%2Dselection%20%7B%0A%20%20background%3A%20rgba%28255%2C%20255%2C%200%2C%200%2E3%29%3B%0A%20%20color%3A%20%23000%3B%0A%7D%0A%0A%2A%3A%3Aselection%20%7B%0A%20%20background%3A%20rgba%28255%2C%20255%2C%200%2C%200%2E3%29%3B%0A%20%20color%3A%20%23000%3B%0A%7D%0A%0Aa%3A%3A%2Dmoz%2Dselection%20%7B%0A%20%20background%3A%20rgba%28255%2C%20255%2C%200%2C%200%2E3%29%3B%0A%20%20color%3A%20%230645ad%3B%0A%7D%0A%0Aa%3A%3Aselection%20%7B%0A%20%20background%3A%20rgba%28255%2C%20255%2C%200%2C%200%2E3%29%3B%0A%20%20color%3A%20%230645ad%3B%0A%7D%0A%0Ah1%2C%20h2%2C%20h3%2C%20h4%2C%20h5%2C%20h6%20%7B%0A%20%20color%3A%20%23111%3B%0A%20%20margin%2Dtop%3A%202em%3B%0A%7D%0A%0Ap%20%7B%0A%20%20margin%3A%201em%200%3B%0A%7D%0A%0Aimg%20%7B%0A%20%20max%2Dwidth%3A%20100%25%3B%0A%7D%0A%0Aq%20%7B%20quotes%3A%20%22%5C201C%22%20%22%5C201D%22%20%22%5C2018%22%20%22%5C2019%22%3B%20%7D%0A%0A%5Blang%3Dde%5D%20q%20%7B%0A%20%20quotes%3A%20%22%5C00bb%22%20%22%5C00ab%22%20%22%5C203A%22%20%22%5C2039%22%3B%0A%7D%0A%0Ablockquote%2C%0Aaside%2Enotes%20%7B%0A%20%20color%3A%20%23666%3B%0A%20%20margin%3A%200%3B%0A%20%20padding%2Dleft%3A%203em%3B%0A%20%20border%2Dleft%3A%200%2E5em%20%23EEE%20solid%3B%0A%7D%0A%0Aaside%2Enotes%20%7B%0A%20%20color%3A%20%23999%3B%0A%20%20border%2Dleft%2Dcolor%3A%20%23ffa%3B%0A%7D%0A%0Ahr%20%7B%0A%20%20display%3A%20block%3B%0A%20%20height%3A%202px%3B%0A%20%20border%3A%200%3B%0A%20%20border%2Dtop%3A%201px%20solid%20%23aaa%3B%0A%20%20border%2Dbottom%3A%201px%20solid%20%23eee%3B%0A%20%20margin%3A%201em%200%3B%0A%20%20padding%3A%200%3B%0A%7D%0A%0Apre%2C%20code%2C%20kbd%2C%20samp%20%7B%0A%20%20color%3A%20%23000%3B%0A%7D%0A%0Apre%20%7B%0A%20%20white%2Dspace%3A%20pre%3B%0A%20%20white%2Dspace%3A%20pre%2Dwrap%3B%0A%20%20word%2Dwrap%3A%20break%2Dword%3B%0A%20%20padding%3A%200%2E1em%200%2E4em%3B%0A%20%20text%2Dindent%3A%201em%3B%0A%7D%0A%0Ab%2C%20strong%20%7B%0A%20%20font%2Dweight%3A%20bold%3B%0A%7D%0A%0Adfn%20%7B%0A%20%20font%2Dstyle%3A%20italic%3B%0A%7D%0A%0Ains%20%7B%0A%20%20background%3A%20%23ff9%3B%0A%20%20color%3A%20%23000%3B%0A%20%20text%2Ddecoration%3A%20none%3B%0A%7D%0A%0Amark%20%7B%0A%20%20background%3A%20%23ff0%3B%0A%20%20color%3A%20%23000%3B%0A%20%20font%2Dstyle%3A%20italic%3B%0A%20%20font%2Dweight%3A%20bold%3B%0A%7D%0A%0Asub%2C%20sup%20%7B%0A%20%20font%2Dsize%3A%2075%25%3B%0A%20%20line%2Dheight%3A%200%3B%0A%20%20position%3A%20relative%3B%0A%20%20vertical%2Dalign%3A%20baseline%3B%0A%7D%0A%0Asup%20%7B%0A%20%20top%3A%20%2D0%2E5em%3B%0A%7D%0A%0Asub%20%7B%0A%20%20bottom%3A%20%2D0%2E25em%3B%0A%7D%0A%0Aul%2C%20ol%20%7B%0A%20%20margin%3A%201em%200%3B%0A%20%20padding%3A%200%200%200%202em%3B%0A%7D%0A%0Ali%20p%3Alast%2Dchild%20%7B%0A%20%20margin%2Dbottom%3A%200%3B%0A%7D%0A%0Aul%20ul%2C%20ol%20ol%20%7B%0A%20%20margin%3A%20%2E3em%200%3B%0A%7D%0A%0Adl%20%7B%0A%20%20margin%2Dbottom%3A%201em%3B%0A%7D%0A%0Adt%20%7B%0A%20%20font%2Dweight%3A%20bold%3B%0A%20%20margin%2Dbottom%3A%20%2E8em%3B%0A%7D%0A%0Add%20%7B%0A%20%20margin%3A%200%200%20%2E8em%202em%3B%0A%7D%0A%0Add%3Alast%2Dchild%20%7B%0A%20%20margin%2Dbottom%3A%200%3B%0A%7D%0A%0Aimg%20%7B%0A%20%20border%3A%200%3B%0A%20%20%2Dms%2Dinterpolation%2Dmode%3A%20bicubic%3B%0A%20%20vertical%2Dalign%3A%20middle%3B%0A%7D%0A%0Afigure%20%7B%0A%20%20display%3A%20block%3B%0A%20%20text%2Dalign%3A%20center%3B%0A%20%20margin%3A%202em%200%3B%0A%7D%0A%0Afigure%20img%20%7B%0A%20%20border%3A%20none%3B%0A%20%20margin%3A%200%20auto%201em%3B%0A%7D%0A%0Afigcaption%20%7B%0A%20%20font%2Dsize%3A%200%2E8em%3B%0A%20%20font%2Dstyle%3A%20italic%3B%0A%20%20margin%3A%200%200%20%2E8em%3B%0A%7D%0A%0Atable%20%7B%0A%20%20margin%2Dbottom%3A%202em%3B%0A%20%20border%2Dbottom%3A%201px%20solid%20%23ddd%3B%0A%20%20border%2Dright%3A%201px%20solid%20%23ddd%3B%0A%20%20border%2Dspacing%3A%200%3B%0A%20%20border%2Dcollapse%3A%20collapse%3B%0A%7D%0A%0Atable%20th%20%7B%0A%20%20padding%3A%20%2E2em%201em%3B%0A%20%20background%2Dcolor%3A%20%23eee%3B%0A%20%20border%2Dtop%3A%201px%20solid%20%23ddd%3B%0A%20%20border%2Dleft%3A%201px%20solid%20%23ddd%3B%0A%7D%0A%0Atable%20td%20%7B%0A%20%20padding%3A%20%2E2em%201em%3B%0A%20%20border%2Dtop%3A%201px%20solid%20%23ddd%3B%0A%20%20border%2Dleft%3A%201px%20solid%20%23ddd%3B%0A%20%20vertical%2Dalign%3A%20top%3B%0A%7D%0A%0A%2Ebyline%20%7B%0A%20%20font%2Dsize%3A%201%2E2em%3B%0A%20%20text%2Dalign%3A%20center%3B%0A%7D%0A%0A%2Ereferences%20a%2Euri%20%7Bword%2Dbreak%3A%20break%2Dall%3B%7D%0A%0Anav%2Etoc%20ul%20%7B%0A%20%20list%2Dstyle%2Dtype%3A%20decimal%3B%0A%7D%0A%0Anav%2Etoc%2Ealready%2Dnumbered%20ul%20%7B%0A%20%20list%2Dstyle%2Dtype%3A%20none%3B%0A%7D%0A%0Anav%2Etoc%2Ealready%2Dnumbered%20%3E%20ul%20%7B%0A%20%20padding%3A%200%3B%0A%7D%0A%0A%2F%2A%2A%0A%20%2A%20%23%23%20Print%20Styles%0A%20%2A%2F%0A%0A%40media%20print%20%7B%0A%20%20%2A%20%7B%0A%20%20%20%20background%3A%20transparent%20%21important%3B%0A%20%20%20%20color%3A%20black%20%21important%3B%0A%20%20%20%20filter%3A%20none%20%21important%3B%0A%20%20%20%20%2Dms%2Dfilter%3A%20none%20%21important%3B%0A%20%20%7D%0A%0A%20%20body%20%7B%0A%20%20%20%20font%2Dsize%3A%209pt%3B%0A%20%20%20%20line%2Dheight%3A%201%2E2%3B%0A%20%20%20%20max%2Dwidth%3A%20100%25%3B%0A%20%20%7D%0A%0A%20%20a%2C%20a%3Avisited%20%7B%0A%20%20%20%20text%2Ddecoration%3A%20underline%3B%0A%20%20%7D%0A%0A%20%20hr%20%7B%0A%20%20%20%20height%3A%201px%3B%0A%20%20%20%20border%3A%200%3B%0A%20%20%20%20border%2Dbottom%3A%201px%20solid%20black%3B%0A%20%20%7D%0A%0A%20%20%2F%2Aa%5Bhref%5D%3Aafter%20%7B%0A%20%20%20%20content%3A%20%22%20%28%22%20attr%28href%29%20%22%29%22%3B%0A%20%20%7D%2A%2F%0A%0A%20%20abbr%5Btitle%5D%3Aafter%20%7B%0A%20%20%20%20content%3A%20%22%20%28%22%20attr%28title%29%20%22%29%22%3B%0A%20%20%7D%0A%0A%20%20%2Eir%20a%3Aafter%2C%20a%5Bhref%5E%3D%22javascript%3A%22%5D%3Aafter%2C%20a%5Bhref%5E%3D%22%23%22%5D%3Aafter%20%7B%0A%20%20%20%20content%3A%20%22%22%3B%0A%20%20%7D%0A%0A%20%20pre%2C%20blockquote%20%7B%0A%20%20%20%20border%3A%201px%20solid%20%23999%3B%0A%20%20%20%20padding%2Dright%3A%201em%3B%0A%20%20%20%20page%2Dbreak%2Dinside%3A%20avoid%3B%0A%20%20%7D%0A%0A%20%20tr%2C%20img%20%7B%0A%20%20%20%20page%2Dbreak%2Dinside%3A%20avoid%3B%0A%20%20%7D%0A%0A%20%20img%20%7B%0A%20%20%20%20max%2Dwidth%3A%20100%25%20%21important%3B%0A%20%20%7D%0A%0A%20%20%40page%20%3Aleft%20%7B%0A%20%20%20%20margin%3A%2025mm%2030mm%2025mm%2020mm%3B%0A%20%20%7D%0A%0A%20%20%40page%20%3Aright%20%7B%0A%20%20%20%20margin%3A%2025mm%2020mm%2025mm%2030mm%3B%0A%20%20%7D%0A%0A%20%20p%2C%20h2%2C%20h3%20%7B%0A%20%20%20%20orphans%3A%203%3B%0A%20%20%20%20widows%3A%203%3B%0A%20%20%7D%0A%0A%20%20h1%2C%20h2%2C%20h3%2C%20h4%20%7B%0A%20%20%20%20page%2Dbreak%2Dafter%3A%20avoid%3B%0A%20%20%7D%0A%7D%0A" rel="stylesheet">
</head>
<body role="document">


<header>
  <h1 class="title">The Rust Programming Language</h1>

  
  <div class="byline vcard">
    <address>
          <p class="author">The Rust Team</p>
        </address>
      <time pubdate="pubdate" date="2015-09-26" class="date">2015-09-26</time>
    </div>
</header>


<nav class="toc" id="TOC">
  <h2>Table of Contents</h2>
  <ul>
  <li><a href="#introduction">Introduction</a><ul>
  <li><a href="#contributing">Contributing</a></li>
  <li><a href="#a-brief-introduction-to-rust">A brief introduction to Rust</a></li>
  </ul></li>
  <li><a href="#sec--INTRODUCTION">Введение</a></li>
  <li><a href="#sec--getting-started">C чего начать</a><ul>
  <li><a href="#установка-rust">Установка Rust</a></li>
  <li><a href="#привет-мир">Привет, мир!</a></li>
  <li><a href="#привет-cargo">Привет, Cargo!</a></li>
  <li><a href="#заключение">Заключение</a></li>
  </ul></li>
  <li><a href="#sec--learn-rust">Изучение Rust</a><ul>
  <li><a href="#sec--guessing-game">Угадайка</a><ul>
  <li><a href="#создание-нового-проекта">Создание нового проекта</a></li>
  <li><a href="#обработка-предположения">Обработка предположения</a></li>
  <li><a href="#генерация-секретного-числа">Генерация секретного числа</a></li>
  <li><a href="#сравнение">Сравнение</a></li>
  <li><a href="#зацикливание">Зацикливание</a></li>
  <li><a href="#готово">Готово!</a></li>
  </ul></li>
  <li><a href="#sec--dining-philosophers">Обедающие философы</a></li>
  <li><a href="#sec--rust-inside-other-languages">Вызов кода на Rust из других языков</a><ul>
  <li><a href="#проблема">Проблема</a></li>
  <li><a href="#библиотека-на-rust">Библиотека на Rust</a></li>
  <li><a href="#ruby">Ruby</a></li>
  <li><a href="#python">Python</a></li>
  <li><a href="#node.js">Node.js</a></li>
  <li><a href="#заключение-1">Заключение</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#sec--effective-rust">Эффективное использование Rust</a><ul>
  <li><a href="#sec--the-stack-and-the-heap">Стек и куча</a><ul>
  <li><a href="#управление-памятью">Управление памятью</a></li>
  <li><a href="#стек">Стек</a></li>
  <li><a href="#куча">Куча</a></li>
  <li><a href="#аргументы-и-заимствование">Аргументы и заимствование</a></li>
  <li><a href="#сложный-пример">Сложный пример</a></li>
  <li><a href="#а-что-делают-другие-языки">А что делают другие языки?</a></li>
  <li><a href="#что-использовать">Что использовать?</a></li>
  </ul></li>
  <li><a href="#sec--testing">Тестирование</a><ul>
  <li><a href="#тесты-с-атрибутом-test">Тесты с атрибутом <code>test</code></a></li>
  <li><a href="#тесты-с-атрибутом-ignore">Тесты с атрибутом <code>ignore</code></a></li>
  <li><a href="#тесты-в-модуле-test">Тесты в модуле <code>test</code></a></li>
  <li><a href="#тесты-в-директории-tests">Тесты в директории <code>tests</code></a></li>
  <li><a href="#тесты-в-документации">Тесты в документации</a></li>
  </ul></li>
  <li><a href="#sec--conditional-compilation">Условная компиляция</a><ul>
  <li><a href="#cfg_attr">cfg_attr</a></li>
  <li><a href="#cfg">cfg!</a></li>
  </ul></li>
  <li><a href="#sec--documentation">Документация</a></li>
  <li><a href="#sec--iterators">Итераторы</a></li>
  <li><a href="#sec--concurrency">Многозадачность</a></li>
  <li><a href="#sec--error-handling">Обработка ошибок</a><ul>
  <li><a href="#содержание">Содержание</a></li>
  <li><a href="#основы">Основы</a></li>
  <li><a href="#работа-с-несколькими-типами-ошибок">Работа с несколькими типами ошибок</a></li>
  <li><a href="#типажи-из-стандартной-библиотеки-используемые-для-обработки-ошибок">Типажи из стандартной библиотеки, используемые для обработки ошибок</a></li>
  <li><a href="#заключение-2">Заключение</a></li>
  </ul></li>
  <li><a href="#sec--choosing-your-guarantees">Выбор гарантий</a><ul>
  <li><a href="#основные-типы-указателей">Основные типы указателей</a></li>
  <li><a href="#типы-ячейки-cell-types">Типы-ячейки (cell types)</a></li>
  <li><a href="#синхронизированные-типы">Синхронизированные типы</a></li>
  <li><a href="#сочетание">Сочетание</a></li>
  </ul></li>
  <li><a href="#sec--ffi">Интерфейс внешних функций (FFI)</a><ul>
  <li><a href="#введение">Введение</a></li>
  <li><a href="#создание-безопасного-интерфейса">Создание безопасного интерфейса</a></li>
  <li><a href="#деструкторы">Деструкторы</a></li>
  <li><a href="#обратные-вызовы-функций-rust-кодом-на-c-callbacks-from-c-code-to-rust">Обратные вызовы функций Rust кодом на C (Callbacks from C code to Rust</a></li>
  <li><a href="#functions">functions)</a></li>
  <li><a href="#компоновка">Компоновка</a></li>
  <li><a href="#небезопасные-блоки">Небезопасные блоки</a></li>
  <li><a href="#доступ-к-внешним-глобальным-переменным">Доступ к внешним глобальным переменным</a></li>
  <li><a href="#взаимодействие-с-внешним-кодом">Взаимодействие с внешним кодом</a></li>
  <li><a href="#оптимизация-указателей-допускающих-нулевое-значение">Оптимизация указателей, допускающих нулевое значение</a></li>
  <li><a href="#the-nullable-pointer-optimization">(The nullable pointer optimization)</a></li>
  <li><a href="#вызов-кода-на-rust-из-кода-на-c">Вызов кода на Rust из кода на C</a></li>
  </ul></li>
  <li><a href="#sec--borrow-and-asref">Типажи <code>Borrow</code> и <code>AsRef</code></a><ul>
  <li><a href="#типаж-borrow">Типаж Borrow</a></li>
  <li><a href="#типаж-asref">Типаж AsRef</a></li>
  <li><a href="#что-в-каком-случае-следует-использовать">Что в каком случае следует использовать?</a></li>
  </ul></li>
  <li><a href="#sec--release-channels">Каналы сборок</a><ul>
  <li><a href="#обзор">Обзор</a></li>
  <li><a href="#выбор-версии">Выбор версии</a></li>
  <li><a href="#помощь-экосистеме-с-помощью-непрерывной-интеграции">Помощь экосистеме с помощью непрерывной интеграции</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#sec--syntax-and-semantics">Синтаксис и семантика</a><ul>
  <li><a href="#sec--variable-bindings">Связывание имён</a></li>
  <li><a href="#sec--functions">Функции</a></li>
  <li><a href="#sec--primitive-types">Простые типы</a><ul>
  <li><a href="#логический-тип-bool">Логический тип (<code>bool</code>)</a></li>
  <li><a href="#символы-char">Символы (<code>char</code>)</a></li>
  <li><a href="#массивы">Массивы</a></li>
  <li><a href="#str"><code>str</code></a></li>
  <li><a href="#функции">Функции</a></li>
  </ul></li>
  <li><a href="#sec--comments">Комментарии</a></li>
  <li><a href="#sec--if">Конструкция <code>if</code></a></li>
  <li><a href="#sec--loops">Циклы</a></li>
  <li><a href="#sec--ownership">Владение</a><ul>
  <li><a href="#мета">Мета</a></li>
  <li><a href="#владение">Владение</a></li>
  <li><a href="#больше-чем-владение">Больше, чем владение</a></li>
  </ul></li>
  <li><a href="#sec--references-and-borrowing">Ссылки и заимствование</a><ul>
  <li><a href="#мета-1">Мета</a></li>
  <li><a href="#ссылки-mut">Ссылки &amp;mut</a></li>
  <li><a href="#правила">Правила</a></li>
  </ul></li>
  <li><a href="#sec--lifetimes">Время жизни</a><ul>
  <li><a href="#мета-2">Мета</a></li>
  <li><a href="#время-жизни">Время жизни</a></li>
  </ul></li>
  <li><a href="#sec--mutability">Изменяемость (mutability)</a><ul>
  <li><a href="#внутренняя-interior-и-внешняя-exterior-изменяемость">Внутренняя (interior) и внешняя (exterior) изменяемость</a></li>
  </ul></li>
  <li><a href="#sec--structs">Структуры</a><ul>
  <li><a href="#синтаксис-обновления-update-syntax">Синтаксис обновления (update syntax)</a></li>
  <li><a href="#кортежные-структуры">Кортежные структуры</a></li>
  <li><a href="#unit-подобные-структуры">Unit-подобные структуры</a></li>
  </ul></li>
  <li><a href="#sec--enums">Перечисления</a><ul>
  <li><a href="#конструкторы-как-функции">Конструкторы как функции</a></li>
  </ul></li>
  <li><a href="#sec--match">Конструкция <code>match</code></a><ul>
  <li><a href="#сопоставление-с-образцом-для-перечислений">Сопоставление с образцом для перечислений</a></li>
  </ul></li>
  <li><a href="#sec--patterns">Шаблоны сопоставления <code>match</code></a><ul>
  <li><a href="#сопоставление-с-несколькими-шаблонами">Сопоставление с несколькими шаблонами</a></li>
  <li><a href="#деструктуризация">Деструктуризация</a></li>
  <li><a href="#игнорирование-связывания">Игнорирование связывания</a></li>
  <li><a href="#ref-и-ref-mut">ref и ref mut</a></li>
  <li><a href="#сопоставление-с-диапазоном">Сопоставление с диапазоном</a></li>
  <li><a href="#связывание">Связывание</a></li>
  <li><a href="#ограничители-шаблонов">Ограничители шаблонов</a></li>
  <li><a href="#заключение-3">Заключение</a></li>
  </ul></li>
  <li><a href="#sec--method-syntax">Синтаксис методов</a><ul>
  <li><a href="#вызов-методов">Вызов методов</a></li>
  <li><a href="#цепочка-вызовов-методов">Цепочка вызовов методов</a></li>
  <li><a href="#статические-методы">Статические методы</a></li>
  <li><a href="#шаблон-строитель-builder-pattern">Шаблон «строитель» (Builder Pattern)</a></li>
  </ul></li>
  <li><a href="#sec--vectors">Вектора</a></li>
  <li><a href="#sec--strings">Строки</a></li>
  <li><a href="#sec--generics">Обобщённое программирование</a></li>
  <li><a href="#sec--traits">Типажи</a><ul>
  <li><a href="#множественные-ограничения-по-типажам">Множественные ограничения по типажам</a></li>
  <li><a href="#утверждение-where">Утверждение where</a></li>
  <li><a href="#методы-по-умолчанию">Методы по умолчанию</a></li>
  <li><a href="#наследование">Наследование</a></li>
  </ul></li>
  <li><a href="#sec--drop">Типаж <code>Drop</code> (сброс)</a></li>
  <li><a href="#sec--if-let">Конструкция <code>if let</code></a></li>
  <li><a href="#sec--trait-objects">Типажи-объекты</a></li>
  <li><a href="#sec--closures">Замыкания</a><ul>
  <li><a href="#синтаксис">Синтаксис</a></li>
  <li><a href="#замыкания-и-их-окружение">Замыкания и их окружение</a></li>
  <li><a href="#реализация-замыканий">Реализация замыканий</a></li>
  <li><a href="#передача-замыканий-в-качестве-аргументов">Передача замыканий в качестве аргументов</a></li>
  <li><a href="#возврат-замыканий">Возврат замыканий</a></li>
  </ul></li>
  <li><a href="#sec--ufcs">Универсальный синтаксис вызова функций (UFCS)</a><ul>
  <li><a href="#форма-с-угловыми-скобками">Форма с угловыми скобками</a></li>
  </ul></li>
  <li><a href="#sec--crates-and-modules">Контейнеры (crates) и модули (modules)</a><ul>
  <li><a href="#основные-термины-контейнеры-и-модули">Основные термины: контейнеры и модули</a></li>
  <li><a href="#объявление-модулей">Объявление модулей</a></li>
  <li><a href="#контейнеры-с-несколькими-файлами">Контейнеры с несколькими файлами</a></li>
  <li><a href="#импорт-внешних-контейнеров">Импорт внешних контейнеров</a></li>
  <li><a href="#экспорт-публичных-интерфейсов">Экспорт публичных интерфейсов</a></li>
  <li><a href="#импорт-модулей-с-помощью-use">Импорт модулей с помощью <code>use</code></a></li>
  </ul></li>
  <li><a href="#sec--const-and-static"><code>const</code> и <code>static</code></a><ul>
  <li><a href="#static-1"><code>static</code></a></li>
  <li><a href="#инициализация">Инициализация</a></li>
  <li><a href="#какую-конструкцию-стоит-использовать">Какую конструкцию стоит использовать?</a></li>
  </ul></li>
  <li><a href="#sec--attributes">Атрибуты</a></li>
  <li><a href="#sec--type-aliases">Псевдонимы типов</a></li>
  <li><a href="#sec--casting-between-types">Приведение типов</a><ul>
  <li><a href="#as"><code>as</code></a></li>
  <li><a href="#transmute"><code>transmute</code></a></li>
  </ul></li>
  <li><a href="#sec--associated-types">Ассоциированные типы</a></li>
  <li><a href="#sec--unsized-types">Безразмерные типы</a><ul>
  <li><a href="#sized">?Sized</a></li>
  </ul></li>
  <li><a href="#sec--operators-and-overloading">Перегрузка операций</a><ul>
  <li><a href="#использование-типажей-операций-в-обобщённых-структурах">Использование типажей операций в обобщённых структурах</a></li>
  </ul></li>
  <li><a href="#sec--deref-coercions">Преобразования при разыменовании (deref coercions)</a></li>
  <li><a href="#sec--macros">Макросы</a><ul>
  <li><a href="#определение-макросов-макроопределения">Определение макросов (Макроопределения)</a></li>
  <li><a href="#гигиена-hygiene">Гигиена (Hygiene)</a></li>
  <li><a href="#рекурсия-макросов">Рекурсия макросов</a></li>
  <li><a href="#требования-синтаксиса">Требования синтаксиса</a></li>
  <li><a href="#области-видимости-импорт-и-экспорт-макросов">Области видимости, импорт и экспорт макросов</a></li>
  <li><a href="#переменная-crate">Переменная <code>$crate</code></a></li>
  <li><a href="#во-тьме-глубин">Во тьме глубин</a></li>
  <li><a href="#распространённые-макросы">Распространённые макросы</a></li>
  <li><a href="#процедурные-макросы">Процедурные макросы</a></li>
  </ul></li>
  <li><a href="#sec--raw-pointers">Сырые указатели</a><ul>
  <li><a href="#основы-1">Основы</a></li>
  <li><a href="#ffi">FFI</a></li>
  <li><a href="#ссылки-и-сырые-указатели">Ссылки и сырые указатели</a></li>
  </ul></li>
  <li><a href="#sec--unsafe">Небезопасный код</a><ul>
  <li><a href="#что-значит-безопасный">Что значит “безопасный”?</a></li>
  <li><a href="#сверхспособности-небезопасного-кода">Сверхспособности небезопасного кода</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#sec--nightly-rust">Нестабильные возможности Rust</a><ul>
  <li><a href="#sec--compiler-plugins">Плагины к компилятору</a><ul>
  <li><a href="#введение-1">Введение</a></li>
  <li><a href="#расширения-синтаксиса">Расширения синтаксиса</a></li>
  <li><a href="#плагины-статических-проверок">Плагины статических проверок</a></li>
  </ul></li>
  <li><a href="#sec--inline-assembly">Встроенный ассемблерный код</a></li>
  <li><a href="#sec--no-stdlib">Без stdlib</a></li>
  <li><a href="#sec--intrinsics">Внутренние средства (intrinsics)</a></li>
  <li><a href="#sec--lang-items">Элементы языка (lang items)</a></li>
  <li><a href="#sec--advanced-linking">Продвинутое руководство по компоновке (advanced linking)</a><ul>
  <li><a href="#аргументы-компоновки-link-args">Аргументы компоновки (link args)</a></li>
  <li><a href="#статическое-связывание">Статическое связывание</a></li>
  </ul></li>
  <li><a href="#sec--benchmark-tests">Тесты производительности</a></li>
  <li><a href="#sec--box-syntax-and-patterns">Синтаксис упаковки и шаблоны <code>match</code></a><ul>
  <li><a href="#возврат-указателей">Возврат указателей</a></li>
  </ul></li>
  <li><a href="#sec--slice-patterns">Шаблоны <code>match</code> для срезов</a></li>
  <li><a href="#sec--associated-constants">Ассоциированные константы</a></li>
  <li><a href="#sec--custom-allocators">Пользовательские менеджеры памяти</a><ul>
  <li><a href="#стандартный-менеджер-памяти">Стандартный менеджер памяти</a></li>
  <li><a href="#переключение-менеджеров-памяти">Переключение менеджеров памяти</a></li>
  <li><a href="#написание-своего-менеджера-памяти">Написание своего менеджера памяти</a></li>
  <li><a href="#ограничения-пользовательских-менеджеров-памяти">Ограничения пользовательских менеджеров памяти</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#sec--glossary">Глоссарий</a></li>
  <li><a href="#sec--bibliography">Библиография</a></li>
  </ul>
</nav>

<article role="main">
  <section id="introduction" class="level1">
  <h1>Introduction</h1>
  <p>Welcome! This book will teach you about the <a href="https://www.rust-lang.org">Rust Programming Language</a>. Rust is a systems programming language focused on three goals: safety, speed, and concurrency. It maintains these goals without having a garbage collector, making it a useful language for a number of use cases other languages aren’t good at: embedding in other languages, programs with specific space and time requirements, and writing low-level code, like device drivers and operating systems. It improves on current languages targeting this space by having a number of compile-time safety checks that produce no runtime overhead, while eliminating all data races. Rust also aims to achieve ‘zero-cost abstractions’ even though some of these abstractions feel like those of a high-level language. Even then, Rust still allows precise control like a low-level language would.</p>
  <p>“The Rust Programming Language” is split into eight sections. This introduction is the first. After this:</p>
  <ul>
  <li><a href="#sec--getting-started">Getting started</a> - Set up your computer for Rust development.</li>
  <li><a href="#sec--learn-rust">Learn Rust</a> - Learn Rust programming through small projects.</li>
  <li><a href="#sec--effective-rust">Effective Rust</a> - Higher-level concepts for writing excellent Rust code.</li>
  <li><a href="#sec--syntax-and-semantics">Syntax and Semantics</a> - Each bit of Rust, broken down into small chunks.</li>
  <li><a href="#sec--nightly-rust">Nightly Rust</a> - Cutting-edge features that aren’t in stable builds yet.</li>
  <li><a href="#sec--glossary">Glossary</a> - A reference of terms used in the book.</li>
  <li><a href="#sec--bibliography">Bibliography</a> - Background on Rust’s influences, papers about Rust.</li>
  </ul>
  <p>After reading this introduction, you’ll want to dive into either ‘Learn Rust’ or ‘Syntax and Semantics’, depending on your preference: ‘Learn Rust’ if you want to dive in with a project, or ‘Syntax and Semantics’ if you prefer to start small, and learn a single concept thoroughly before moving onto the next. Copious cross-linking connects these parts together.</p>
  <section id="contributing" class="level3">
  <h3>Contributing</h3>
  <p>The source files from which this book is generated can be found on Github: <a href="https://github.com/rust-lang/rust/tree/master/src/doc/trpl">github.com/rust-lang/rust/tree/master/src/doc/trpl</a></p>
  </section>
  <section id="a-brief-introduction-to-rust" class="level2">
  <h2>A brief introduction to Rust</h2>
  <p>Is Rust a language you might be interested in? Let’s examine a few small code samples to show off a few of its strengths.</p>
  <p>The main concept that makes Rust unique is called ‘ownership’. Consider this small example:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="kw">let</span> <span class="kw">mut</span> x = <span class="ot">vec!</span>[<span class="st">&quot;Hello&quot;</span>, <span class="st">&quot;world&quot;</span>];
  }</code></pre>
  <p>This program makes a <a href="#sec--variable-bindings">variable binding</a> named <code>x</code>. The value of this binding is a <code>Vec&lt;T&gt;</code>, a ‘vector’, that we create through a <a href="#sec--macros">macro</a> defined in the standard library. This macro is called <code>vec</code>, and we invoke macros with a <code>!</code>. This follows a general principle of Rust: make things explicit. Macros can do significantly more complicated things than function calls, and so they’re visually distinct. The <code>!</code> also helps with parsing, making tooling easier to write, which is also important.</p>
  <p>We used <code>mut</code> to make <code>x</code> mutable: bindings are immutable by default in Rust. We’ll be mutating this vector later in the example.</p>
  <p>It’s also worth noting that we didn’t need a type annotation here: while Rust is statically typed, we didn’t need to explicitly annotate the type. Rust has type inference to balance out the power of static typing with the verbosity of annotating types.</p>
  <p>Rust prefers stack allocation to heap allocation: <code>x</code> is placed directly on the stack. However, the <code>Vec&lt;T&gt;</code> type allocates space for the elements of the vector on the heap. If you’re not familiar with this distinction, you can ignore it for now, or check out <a href="#sec--the-stack-and-the-heap">‘The Stack and the Heap’</a>. As a systems programming language, Rust gives you the ability to control how your memory is allocated, but when we’re getting started, it’s less of a big deal.</p>
  <p>Earlier, we mentioned that ‘ownership’ is the key new concept in Rust. In Rust parlance, <code>x</code> is said to ‘own’ the vector. This means that when <code>x</code> goes out of scope, the vector’s memory will be de-allocated. This is done deterministically by the Rust compiler, rather than through a mechanism such as a garbage collector. In other words, in Rust, you don’t call functions like <code>malloc</code> and <code>free</code> yourself: the compiler statically determines when you need to allocate or deallocate memory, and inserts those calls itself. To err is to be human, but compilers never forget.</p>
  <p>Let’s add another line to our example:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="kw">let</span> <span class="kw">mut</span> x = <span class="ot">vec!</span>[<span class="st">&quot;Hello&quot;</span>, <span class="st">&quot;world&quot;</span>];
  
      <span class="kw">let</span> y = &amp;x[<span class="dv">0</span>];
  }</code></pre>
  <p>We’ve introduced another binding, <code>y</code>. In this case, <code>y</code> is a ‘reference’ to the first element of the vector. Rust’s references are similar to pointers in other languages, but with additional compile-time safety checks. References interact with the ownership system by <a href="#sec--references-and-borrowing">‘borrowing’</a> what they point to, rather than owning it. The difference is, when the reference goes out of scope, it will not deallocate the underlying memory. If it did, we’d de-allocate twice, which is bad!</p>
  <p>Let’s add a third line. It looks innocent enough, but causes a compiler error:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="kw">let</span> <span class="kw">mut</span> x = <span class="ot">vec!</span>[<span class="st">&quot;Hello&quot;</span>, <span class="st">&quot;world&quot;</span>];
  
      <span class="kw">let</span> y = &amp;x[<span class="dv">0</span>];
  
      x.push(<span class="st">&quot;foo&quot;</span>);
  }</code></pre>
  <p><code>push</code> is a method on vectors that appends another element to the end of the vector. When we try to compile this program, we get an error:</p>
  <pre class="text"><code>error: cannot borrow `x` as mutable because it is also borrowed as immutable
      x.push(&quot;foo&quot;);
      ^
  note: previous borrow of `x` occurs here; the immutable borrow prevents
  subsequent moves or mutable borrows of `x` until the borrow ends
      let y = &amp;x[0];
               ^
  note: previous borrow ends here
  fn main() {
  
  }
  ^</code></pre>
  <p>Whew! The Rust compiler gives quite detailed errors at times, and this is one of those times. As the error explains, while we made our binding mutable, we still cannot call <code>push</code>. This is because we already have a reference to an element of the vector, <code>y</code>. Mutating something while another reference exists is dangerous, because we may invalidate the reference. In this specific case, when we create the vector, we may have only allocated space for two elements. Adding a third would mean allocating a new chunk of memory for all those elements, copying the old values over, and updating the internal pointer to that memory. That all works just fine. The problem is that <code>y</code> wouldn’t get updated, and so we’d have a ‘dangling pointer’. That’s bad. Any use of <code>y</code> would be an error in this case, and so the compiler has caught this for us.</p>
  <p>So how do we solve this problem? There are two approaches we can take. The first is making a copy rather than using a reference:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="kw">let</span> <span class="kw">mut</span> x = <span class="ot">vec!</span>[<span class="st">&quot;Hello&quot;</span>, <span class="st">&quot;world&quot;</span>];
  
      <span class="kw">let</span> y = x[<span class="dv">0</span>].clone();
  
      x.push(<span class="st">&quot;foo&quot;</span>);
  }</code></pre>
  <p>Rust has <a href="#move-semantics">move semantics</a> by default, so if we want to make a copy of some data, we call the <code>clone()</code> method. In this example, <code>y</code> is no longer a reference to the vector stored in <code>x</code>, but a copy of its first element, <code>&quot;Hello&quot;</code>. Now that we don’t have a reference, our <code>push()</code> works just fine.</p>
  <p>If we truly want a reference, we need the other option: ensure that our reference goes out of scope before we try to do the mutation. That looks like this:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="kw">let</span> <span class="kw">mut</span> x = <span class="ot">vec!</span>[<span class="st">&quot;Hello&quot;</span>, <span class="st">&quot;world&quot;</span>];
  
      {
          <span class="kw">let</span> y = &amp;x[<span class="dv">0</span>];
      }
  
      x.push(<span class="st">&quot;foo&quot;</span>);
  }</code></pre>
  <p>We created an inner scope with an additional set of curly braces. <code>y</code> will go out of scope before we call <code>push()</code>, and so we’re all good.</p>
  <p>This concept of ownership isn’t just good for preventing dangling pointers, but an entire set of related problems, like iterator invalidation, concurrency, and more.</p>
  </section>
  </section>
  <section id="sec--INTRODUCTION" class="level1">
  <h1>Введение</h1>
  <p>Добро пожаловать! Эта книга обучает основным принципам работы с языком программирования <a href="http://rust-lang.org">Rust</a>. Rust — это системный язык программирования, внимание которого сосредоточено на трёх задачах: безопасность, скорость и параллелизм. Он решает эти задачи без сборщика мусора, что делает его полезным в ряде случаев, когда использование других языков было бы нецелесообразно: при встраивании в другие языки, при написании программ с особыми пространственными и временными требованиями, при написании низкоуровневого кода, такого как драйверы устройств и операционные системы. Во время компиляции Rust делает ряд проверок безопасности. За счёт этого не возникает накладных расходов во время выполнения приложения и устраняются все гонки данных. Это даёт Rust преимущество над другими языками программирования, имеющими аналогичную направленность. Rust также направлен на достижение «абстракции с нулевой стоимостью». Хотя некоторые из этих абстракций и ведут себя как в языках высокого уровня, но даже тогда Rust по-прежнему обеспечивает точный контроль, как делал бы язык низкого уровня.</p>
  <p>Книга «Язык программирования Rust» делится на восемь разделов. Это введение является первым из них. Затем идут:</p>
  <ul>
  <li><a href="#sec--getting-started">C чего начать</a> — Настройка компьютера для разработки на Rust.</li>
  <li><a href="#sec--learn-rust">Изучение Rust</a> — Обучение программированию на Rust на примере небольших проектов.</li>
  <li><a href="#sec--effective-rust">Эффективное использование Rust</a> — Понятия более высокого уровня для написания качественного кода на Rust.</li>
  <li><a href="#sec--syntax-and-semantics">Синтаксис и семантика</a> — Каждое понятие Rust разбивается на небольшие кусочки.</li>
  <li><a href="#sec--nightly-rust">Нестабильные возможности Rust</a> — Передовые возможности, которые пока не добавлены в стабильную сборку.</li>
  <li><a href="#sec--glossary">Глоссарий</a> — Ссылки на термины, используемые в книге.</li>
  <li><a href="#sec--academic-research">Академические исследования</a> — Литература, которая оказала влияние на Rust.</li>
  </ul>
  <p>После прочтения этого введения, в зависимости от ваших предпочтений, вы можете продолжить дальнейшее изучение либо в направлении «Изучение Rust», либо в направлении «Синтаксис и семантика». Если вы предпочитаете изучить язык на примере реального проекта, лучшим выбором будет раздел «Изучение Rust». Раздел «Синтаксис и семантика» подойдёт тем, кто предпочитает тщательно изучить каждое понятие языка отдельно, перед тем как двигаться дальше. Большое количество перекрёстных ссылок соединяет эти части воедино.</p>
  <section id="содействие" class="level5">
  <h5>Содействие</h5>
  <p>Исходные файлы, из которых генерируется оригинал этой книги, могут быть найдены на Github: <a href="https://github.com/rust-lang/rust/tree/master/src/doc/trpl">github.com/rust-lang/rust/tree/master/src/doc/trpl</a></p>
  <p>Исходные файлы перевода этой книги на русский язык также находятся на GitHub: <a href="https://github.com/kgv/rust_book_ru">github.com/kgv/rust_book_ru</a></p>
  </section>
  <section id="краткое-введение-в-rust" class="level4">
  <h4>Краткое введение в Rust</h4>
  <p>Чем же Rust может заинтересовать вас? Давайте рассмотрим несколько небольших примеров кода, чтобы продемонстрировать некоторые из его сильных сторон.</p>
  <p>Основное понятие, которое делает Rust уникальным, называется «владение». Рассмотрим следующий небольшой пример:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="kw">let</span> <span class="kw">mut</span> x = <span class="ot">vec!</span>[<span class="st">&quot;Hello&quot;</span>, <span class="st">&quot;world&quot;</span>];
  }</code></pre>
  <p>Эта программа создаёт <a href="#sec--variable-bindings">связанное имя</a> <code>x</code>. Его значением является <code>Vec&lt;T&gt;</code>, «вектор», который мы создаём с помощью <a href="#sec--macros">макроса</a>, определённого в стандартной библиотеке. Этот макрос называется <code>vec</code>, и при его вызове используется символ <code>!</code>. Это следует из общего принципа Rust: делать вещи явными. Макрос может делать значительно более сложные вещи, чем вызовы функций, и поэтому они визуально отличаются. Символ <code>!</code> также помогает при разборе, что облегчает написание инструментов, а это тоже важно.</p>
  <p>Мы использовали <code>mut</code>, чтобы сделать <code>x</code> изменяемым: связанные имена в Rust по умолчанию неизменяемы. Дальше в примере мы будем изменять этот вектор.</p>
  <p>Стоит также отметить, что здесь нам не нужно указывать тип, несмотря на то, что Rust является статически типизированным. Rust может выводить типы, что позволяет достичь компромисса между мощью статической типизации и многословностью указания типов.</p>
  <p>Rust предпочитает выделять память в стеке, а не в куче: <code>x</code> находится непосредственно в стеке. Однако тип <code>Vec&lt;T&gt;</code> выделяет пространство для элементов вектора в куче. Если вы не знакомы с различиями этих двух видов выделения памяти, можете пока просто проигнорировать эту информацию или же ознакомиться с разделом «<a href="#sec--the-stack-and-the-heap">Стек и Куча</a>». Как системный язык программирования, Rust даёт вам возможность контролировать выделение памяти. Но не будем забегать вперёд, мы только начинаем изучение языка.</p>
  <p>Ранее мы упоминали, что «владение» — это то, что делает Rust уникальным. В терминологии Rust, <code>x</code> «владеет» вектором. Это означает, что как только <code>x</code> выходит из области видимости, выделенная для вектора память будет освобождена. Когда это будет происходить, определяется средствами компилятора Rust, а не через механизмы наподобие сборщика мусора. Другими словами, в Rust вы не вызываете функции вроде <code>malloc</code> и <code>free</code> собственноручно: компилятор статически определяет, когда нужно выделить или освободить память, и вставляет эти вызовы самостоятельно. Человек может совершить ошибку при использовании этих вызовов, а компилятор — никогда.</p>
  <p>Давайте добавим ещё одну строку в наш пример:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="kw">let</span> <span class="kw">mut</span> x = <span class="ot">vec!</span>[<span class="st">&quot;Hello&quot;</span>, <span class="st">&quot;world&quot;</span>];
  
      <span class="kw">let</span> y = &amp;x[<span class="dv">0</span>];
  }</code></pre>
  <p>Мы создаём ещё одно имя, <code>y</code>. В этом случае, <code>y</code> является «ссылкой» на первый элемент вектора. Ссылки в Rust похожи на указатели в других языках, но с дополнительными проверками безопасности на этапе компиляции. Ссылки взаимодействуют с системой прав владения при помощи «<a href="#sec--references-and-borrowing">заимствования</a>». Ссылки заимствуют то, на что они указывают, а не получают права владения им. Разница в том, что при заимствовании ссылка не освобождает основную память, когда выходит за пределы области видимости. Если бы это было не так, то память освобождалась бы два раза — плохо!</p>
  <p>Давайте добавим третью строку. На первый взгляд в коде нет ничего такого, но он вызывает ошибку компиляции:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="kw">let</span> <span class="kw">mut</span> x = <span class="ot">vec!</span>[<span class="st">&quot;Hello&quot;</span>, <span class="st">&quot;world&quot;</span>];
  
      <span class="kw">let</span> y = &amp;x[<span class="dv">0</span>];
  
      x.push(<span class="st">&quot;foo&quot;</span>);
  }</code></pre>
  <p><code>push</code> — это метод, который добавляет ещё один элемент в конец вектора. Когда мы пытаемся скомпилировать эту программу, то получаем ошибку:</p>
  <pre class="text"><code>error: cannot borrow `x` as mutable because it is also borrowed as immutable
      x.push(&quot;foo&quot;);
      ^
  note: previous borrow of `x` occurs here; the immutable borrow prevents
  subsequent moves or mutable borrows of `x` until the borrow ends
      let y = &amp;x[0];
               ^
  note: previous borrow ends here
  fn main() {
  
  }
  ^</code></pre>
  <p>Вот так! Компилятор Rust в некоторых случаях выдаёт достаточно подробные ошибки, и это как раз один из таких случаев. Как объясняется в ошибке, несмотря на то, что мы и сделали наше имя изменяемым, мы всё ещё не можем вызвать метод <code>push</code>. Это потому, что у нас уже есть ссылка на элемент вектора, <code>y</code>. Изменять вектор, пока существует другая ссылка на него, опасно, потому что можно сделать ссылку недействительной. В данном конкретном случае, когда мы создаём вектор, у нас есть выделенное пространство памяти только для двух элементов. Добавление третьего элемента будет означать выделение новой области памяти для всех этих элементов, копирование старых значений и обновление внутреннего указателя на эту память. Всё это работает просто отлично. Проблема заключается в том, что <code>y</code> не будет обновлена, из-за чего мы получим «зависший указатель». И это плохо. В этом случае любое использование <code>y</code> будет означать ошибку. Компилятор обнаружил данную проблему.</p>
  <p>Так как же нам решить эту проблему? Есть два подхода, которые мы можем использовать. Первый заключается в создании копии вместо ссылки:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="kw">let</span> <span class="kw">mut</span> x = <span class="ot">vec!</span>[<span class="st">&quot;Hello&quot;</span>, <span class="st">&quot;world&quot;</span>];
  
      <span class="kw">let</span> y = x[<span class="dv">0</span>].clone();
  
      x.push(<span class="st">&quot;foo&quot;</span>);
  }</code></pre>
  <p>По умолчанию, Rust использует <a href="#move-semantics">семантику перемещения</a>, поэтому, если мы хотим сделать копию некоторых данных, мы должны вызывать метод <code>clone()</code>. В этом примере <code>y</code> больше не является ссылкой на вектор, хранящийся в <code>x</code>, но является копией его первого элемента, <code>&quot;Hello&quot;</code>. Теперь, когда у нас больше нет ссылки, метод <code>push()</code> прекрасно работает.</p>
  <p>Если нам всё же нужна ссылка, то следует использовать другой вариант: убедиться, что наша ссылка выходит из области видимости, прежде чем мы попытаемся сделать изменения. Это выглядит примерно так:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="kw">let</span> <span class="kw">mut</span> x = <span class="ot">vec!</span>[<span class="st">&quot;Hello&quot;</span>, <span class="st">&quot;world&quot;</span>];
  
      {
          <span class="kw">let</span> y = &amp;x[<span class="dv">0</span>];
      }
  
      x.push(<span class="st">&quot;foo&quot;</span>);
  }</code></pre>
  <p>Мы создали внутреннюю область видимости с помощью дополнительных фигурных скобок. <code>y</code> выйдет за пределы этой области видимости до вызова метода <code>push()</code>, и поэтому все будет хорошо.</p>
  <p>Концепция владения хороша не только для предотвращения проблемы повисших указателей, но также и для всей совокупности связанных с этим проблем, таких как: недействительность итератора, параллелизм и многое другое.</p>
  </section>
  </section>
  <section id="sec--getting-started" class="level1">
  <h1>C чего начать</h1>
  <p>Первый раздел книги рассказывает о том, как начать работать с Rust и его инструментами. Сначала мы установим Rust, затем напишем классическую программу «Привет, мир!», и, наконец, поговорим о Cargo, который представляет из себя систему сборки и менеджер пакетов в Rust.</p>
  <section id="установка-rust" class="level3">
  <h3>Установка Rust</h3>
  <p>Первым шагом к использованию Rust является его установка. В этой главе нам понадобится интернет соединение для выполнения команд, с помощью которых мы загрузим Rust из интернета.</p>
  <p>Мы воспользуемся несколькими командами в терминале, и они все будут начинаться с <code>$</code>. Вам не нужно вводить <code>$</code>, они используются только для того чтобы обозначить начало каждой команды. В интернете можно увидеть множество руководств и примеров, которые следуют этому правилу: <code>$</code> обозначает команды, которые выполняются с правами обычного пользователя и <code>#</code> для команд, которые выполняются с правами администратора.</p>
  <section id="поддерживаемые-платформы" class="level4">
  <h4>Поддерживаемые платформы</h4>
  <p>Перечень платформ, на которых работает и для которых компилирует компилятор Rust довольно большой, однако, не все платформы поддерживаются одинаково. Уровни поддержки Rust разбиты на три уровня, у каждого из которых свой набор гарантий.</p>
  <p>Платформы идентифицируются по их “целевой тройке”, которая является строкой, сообщающей компилятору, какие выходные данные должны быть произведены. Столбцы ниже указывают, работает ли соответствующий компонент на указанной платформе.</p>
  <section id="первый-уровень" class="level5">
  <h5>Первый уровень</h5>
  <p>Первый уровень платформ может восприниматься как “гарантировано собирается и работает”. В частности, каждый из них удовлетворяет следующим требованиям:</p>
  <ul>
  <li>Автоматические тесты обеспечивают тестирование этих платформ.</li>
  <li>Изменения, принятые в ветку master репозитория <code>rust-lang/rust</code>, прошли тестирование.</li>
  <li>Для этих платформ предоставляются официальные пакеты.</li>
  <li>Доступна документация о том как собрать и использовать платформу.</li>
  </ul>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Target</th>
  <th style="text-align: left;">std</th>
  <th style="text-align: left;">rustc</th>
  <th style="text-align: left;">cargo</th>
  <th style="text-align: left;">notes</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;"><code>x86_64-pc-windows-msvc</code></td>
  <td style="text-align: left;">✓</td>
  <td style="text-align: left;">✓</td>
  <td style="text-align: left;">✓</td>
  <td style="text-align: left;">64-bit MSVC (Windows 7+)</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;"><code>i686-pc-windows-gnu</code></td>
  <td style="text-align: left;">✓</td>
  <td style="text-align: left;">✓</td>
  <td style="text-align: left;">✓</td>
  <td style="text-align: left;">32-bit MinGW (Windows 7+)</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;"><code>x86_64-pc-windows-gnu</code></td>
  <td style="text-align: left;">✓</td>
  <td style="text-align: left;">✓</td>
  <td style="text-align: left;">✓</td>
  <td style="text-align: left;">64-bit MinGW (Windows 7+)</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;"><code>i686-apple-darwin</code></td>
  <td style="text-align: left;">✓</td>
  <td style="text-align: left;">✓</td>
  <td style="text-align: left;">✓</td>
  <td style="text-align: left;">32-bit OSX (10.7+, Lion+)</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;"><code>x86_64-apple-darwin</code></td>
  <td style="text-align: left;">✓</td>
  <td style="text-align: left;">✓</td>
  <td style="text-align: left;">✓</td>
  <td style="text-align: left;">64-bit OSX (10.7+, Lion+)</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;"><code>i686-unknown-linux-gnu</code></td>
  <td style="text-align: left;">✓</td>
  <td style="text-align: left;">✓</td>
  <td style="text-align: left;">✓</td>
  <td style="text-align: left;">32-bit Linux (2.6.18+)</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;"><code>x86_64-unknown-linux-gnu</code></td>
  <td style="text-align: left;">✓</td>
  <td style="text-align: left;">✓</td>
  <td style="text-align: left;">✓</td>
  <td style="text-align: left;">64-bit Linux (2.6.18+)</td>
  </tr>
  </tbody>
  </table>
  </section>
  <section id="второй-уровень" class="level5">
  <h5>Второй уровень</h5>
  <p>Второй уровень платформ может восприниматься как “гарантировано собирается”. Автоматические тесты не поддерживаются и в связи с этим работоспособность сборки не гарантируется. Но эти платформы обычно работают довольно хорошо, и предложения по улучшению всегда приветствуются! В частности эти платформы удовлетворяют следующим требованиям:</p>
  <ul>
  <li>Настроена автоматическая сборка, но тестирования не происходит.</li>
  <li>Изменения, принятые в ветку master репозитория <code>rust-lang/rust</code>, собираются для этих платформ. Имейте ввиду, что для некоторых платформ собирается только стандартная библиотека, но для остальных настроена полная раскрутка компилятора (bootstraping).</li>
  <li>Для этих платформ предоставляются официальные пакеты.</li>
  </ul>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Target</th>
  <th style="text-align: left;">std</th>
  <th style="text-align: left;">rustc</th>
  <th style="text-align: left;">cargo</th>
  <th style="text-align: left;">notes</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;"><code>i686-pc-windows-msvc</code></td>
  <td style="text-align: left;">✓</td>
  <td style="text-align: left;">✓</td>
  <td style="text-align: left;">✓</td>
  <td style="text-align: left;">32-bit MSVC (Windows 7+)</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;"><code>x86_64-unknown-linux-musl</code></td>
  <td style="text-align: left;">✓</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">64-bit Linux with MUSL</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;"><code>arm-linux-androideabi</code></td>
  <td style="text-align: left;">✓</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">ARM Android</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;"><code>arm-unknown-linux-gnueabi</code></td>
  <td style="text-align: left;">✓</td>
  <td style="text-align: left;">✓</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">ARM Linux (2.6.18+)</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;"><code>arm-unknown-linux-gnueabihf</code></td>
  <td style="text-align: left;">✓</td>
  <td style="text-align: left;">✓</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">ARM Linux (2.6.18+)</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;"><code>aarch64-unknown-linux-gnu</code></td>
  <td style="text-align: left;">✓</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">ARM64 Linux (2.6.18+)</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;"><code>mips-unknown-linux-gnu</code></td>
  <td style="text-align: left;">✓</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">MIPS Linux (2.6.18+)</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;"><code>mipsel-unknown-linux-gnu</code></td>
  <td style="text-align: left;">✓</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">MIPS (LE) Linux (2.6.18+)</td>
  </tr>
  </tbody>
  </table>
  </section>
  <section id="третий-уровень" class="level5">
  <h5>Третий уровень</h5>
  <p>Третий уровень платформ — это те, которые Rust поддерживает, но принятые изменения автоматически не собираются и не тестируются. Для этих платформ работоспособность сборки определятся степенью содействия сообщества. К тому же официальные пакеты и установщики не предоставляются, но они могут быть предоставлены сообществом.</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Target</th>
  <th style="text-align: left;">std</th>
  <th style="text-align: left;">rustc</th>
  <th style="text-align: left;">cargo</th>
  <th style="text-align: left;">notes</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;"><code>i686-linux-android</code></td>
  <td style="text-align: left;">✓</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">32-bit x86 Android</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;"><code>aarch64-linux-android</code></td>
  <td style="text-align: left;">✓</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">ARM64 Android</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;"><code>powerpc-unknown-linux-gnu</code></td>
  <td style="text-align: left;">✓</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">PowerPC Linux (2.6.18+)</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;"><code>i386-apple-ios</code></td>
  <td style="text-align: left;">✓</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">32-bit x86 iOS</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;"><code>x86_64-apple-ios</code></td>
  <td style="text-align: left;">✓</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">64-bit x86 iOS</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;"><code>armv7-apple-ios</code></td>
  <td style="text-align: left;">✓</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">ARM iOS</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;"><code>armv7s-apple-ios</code></td>
  <td style="text-align: left;">✓</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">ARM iOS</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;"><code>aarch64-apple-ios</code></td>
  <td style="text-align: left;">✓</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">ARM64 iOS</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;"><code>i686-unknown-freebsd</code></td>
  <td style="text-align: left;">✓</td>
  <td style="text-align: left;">✓</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">32-bit FreeBSD</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;"><code>x86_64-unknown-freebsd</code></td>
  <td style="text-align: left;">✓</td>
  <td style="text-align: left;">✓</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">64-bit FreeBSD</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;"><code>x86_64-unknown-openbsd</code></td>
  <td style="text-align: left;">✓</td>
  <td style="text-align: left;">✓</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">64-bit OpenBSD</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;"><code>x86_64-unknown-netbsd</code></td>
  <td style="text-align: left;">✓</td>
  <td style="text-align: left;">✓</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">64-bit NetBSD</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;"><code>x86_64-unknown-bitrig</code></td>
  <td style="text-align: left;">✓</td>
  <td style="text-align: left;">✓</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">64-bit Bitrig</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;"><code>x86_64-unknown-dragonfly</code></td>
  <td style="text-align: left;">✓</td>
  <td style="text-align: left;">✓</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">64-bit DragonFlyBSD</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;"><code>x86_64-rumprun-netbsd</code></td>
  <td style="text-align: left;">✓</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">64-bit NetBSD Rump Kernel</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;"><code>i686-pc-windows-msvc</code> (XP)</td>
  <td style="text-align: left;">✓</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">Windows XP support</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;"><code>x86_64-pc-windows-msvc</code> (XP)</td>
  <td style="text-align: left;">✓</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">Windows XP support</td>
  </tr>
  </tbody>
  </table>
  <p>Имейте ввиду, что эта таблица со временем может быть дополнена, это не исчерпывающий набор третьего уровня!</p>
  </section>
  </section>
  <section id="установка-на-linux-или-mac" class="level4">
  <h4>Установка на Linux или Mac</h4>
  <p>Если вы используете Linux или Mac, то всё что вам нужно сделать — это ввести следующую команду в консоль:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">curl</span> -sSf https://static.rust-lang.org/rustup.sh <span class="kw">|</span> <span class="kw">sh</span></code></pre>
  <p>Эта команда загрузит скрипт и начнет установку. Если все пройдет успешно, то вы увидите следующий текст:</p>
  <pre class="text"><code>Welcome to Rust.
  
  This script will download the Rust compiler and its package manager, Cargo, and
  install them to /usr/local. You may install elsewhere by running this script
  with the --prefix=&lt;path&gt; option.
  
  The installer will run under ‘sudo’ and may ask you for your password. If you do
  not want the script to run ‘sudo’ then pass it the --disable-sudo flag.
  
  You may uninstall later by running /usr/local/lib/rustlib/uninstall.sh,
  or by running this script again with the --uninstall flag.
  
  Continue? (y/N)</code></pre>
  <p>Нажмите <code>y</code> для подтверждения и следуйте дальнейшим подсказкам.</p>
  </section>
  <section id="установка-на-windows" class="level4">
  <h4>Установка на Windows</h4>
  <p>Если вы используете Windows, то скачайте подходящий <a href="https://www.rust-lang.org/install.html">установщик</a>.</p>
  </section>
  <section id="удаление" class="level4">
  <h4>Удаление</h4>
  <p>Удалить Rust так же просто, как и установить его. На Linux или Mac нужно просто запустить скрипт удаления:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">sudo</span> /usr/local/lib/rustlib/uninstall.sh</code></pre>
  <p>Если вы использовали установщик Windows, то просто повторно запустите <code>.msi</code>, который предложит вам возможность удаления.</p>
  </section>
  <section id="решение-проблем" class="level4">
  <h4>Решение проблем</h4>
  <p>Если у вас установлен Rust, то можно открыть терминал и ввести:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">rustc</span> --version</code></pre>
  <p>Вы должны увидеть версию, хеш коммита и дату коммита.</p>
  <p>Если это так, то теперь у вас есть установленный Rust! Поздравляем!</p>
  <p>Если нет и вы пользователь Windows, то убедитесь в том, что Rust прописан в вашей системной переменной %PATH%. Если это не так, то запустите установочник снова, выберете “Change” на старнице “Change, repair, or remove installation” и убедитесь, что “Add to PATH” указывает на локальный жесткий диск.</p>
  <p>Существуют несколько мест, где вы можете получить помощь. Самый простой вариант — <a href="irc://irc.mozilla.org/#rust">Канал #rust на irc.mozilla.org</a>, к которому вы можете подключиться через <a href="http://chat.mibbit.com/?server=irc.mozilla.org&amp;channel=%23rust">Mibbit</a>. Нажмите на эту ссылку, и вы будете общаться в чате с другими Rustaceans (это дурашливое прозвище, которым мы себя называем), и мы поможем вам. Другие полезные ресурсы, посвящённые Rust: <a href="https://users.rust-lang.org/">форум пользователей</a> и <a href="http://stackoverflow.com/questions/tagged/rust">Stack Overflow</a>. Русскоязычные ресурсы: <a href="http://rustycrate.ru">сайт сообщества</a>, <a href="http://forum.rustycrate.ru">форум</a>, <a href="http://ru.stackoverflow.com/questions/tagged/rust">Stack Overflow</a>.</p>
  <p>Установщик также устанавливает документацию, которая доступна без подключения к сети. На UNIX системах она располагается в директории <code>/usr/local/share/doc/rust</code>. В Windows используется директория <code>share/doc</code>, относительно того куда вы установили Rust.</p>
  </section>
  </section>
  <section id="привет-мир" class="level3">
  <h3>Привет, мир!</h3>
  <p>Теперь, когда вы установили Rust, давайте напишем первую программу на Rust. Традиционно при изучении нового языка программирования, первая написанная программа просто выводит на экран «Привет, мир!», и мы следуем этой традиции.</p>
  <p>Хорошо начинать с такой простой программы, поскольку можно убедиться, что ваш компилятор не только установлен, но и работает правильно. Вывод информации на экран будет замечательным способом проверить это.</p>
  <blockquote>
  <p>На самом деле это приводит к ещё одной проблеме, о которой мы должны предупредить: данное руководство предполагает, что у вас есть базовые навыки работы с командной строкой. Rust не выдвигает специфических требований к вашей среде разработки или тому, как вы храните свой код. Если вы предпочитаете использовать IDE, посмотрите на проект <a href="https://github.com/oakes/SolidOak">SolidOak</a>, или на плагины к вашей любимой IDE. Есть множество расширений, разрабатываемых сообществом, а также <a href="https://github.com/rust-lang/rust/blob/master/src/etc/CONFIGS.md">плагинов для разных редакторов</a>, поддерживаемых командой Rust. Настройка вашего редактора или IDE выходит за пределы данного руководства. Посмотрите руководство по использованию выбранного вами плагина.</p>
  </blockquote>
  <section id="создание-проекта" class="level4">
  <h4>Создание проекта</h4>
  <p>Первое, с чего мы должны начать – создание файла для нашего кода. Для Rust не имеет значения, где находится ваш код, но в рамках этого руководства мы рекомендуем создать директорию <em>projects</em> в вашей домашней директории и хранить там все ваши проекты. Откройте терминал и введите следующие команды чтобы создать директорию для этого проекта:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">mkdir</span> ~/projects
  $ <span class="kw">cd</span> ~/projects
  $ <span class="kw">mkdir</span> hello_world
  $ <span class="kw">cd</span> hello_world</code></pre>
  <blockquote>
  <p>Если вы используете Windows и не используете PowerShell, ~ может не работать. Обратитесь к документации вашей оболочки для уточнения деталей.</p>
  </blockquote>
  </section>
  <section id="написание-и-запуск-программы-на-rust" class="level4">
  <h4>Написание и запуск программы на Rust</h4>
  <p>Теперь создадим новый файл для кода программы. Назовём наш файл <em>main.rs</em>. Файлы с исходным кодом на Rust всегда имеют расширение <em>.rs</em>. Если вы хотите использовать в имени вашего файла больше одного слова, разделяйте их подчёркиванием; например <em>hello_world.rs</em>, а не <em>helloworld.rs</em>.</p>
  <p>Теперь откройте только что созданный файл <em>main.rs</em> и добавьте в него следующий код:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="ot">println!</span>(<span class="st">&quot;Привет, мир!&quot;</span>);
  }</code></pre>
  <p>Сохраните файл и вернитесь к вашему окну терминала. На Linux или OSX введите следующие команды:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">rustc</span> main.rs
  $ <span class="kw">./main</span>
  П<span class="kw">ривет</span>, <span class="kw">м</span>ир!</code></pre>
  <p>На Windows просто замените <code>main</code> на <code>main.exe</code>. В независимости от вашей ОС вы должны увидеть строку <code>Привет, мир!</code> в терминале. Поздравляем! Вы написали первую программу на Rust. Теперь вы Rust-разработчик! Добро пожаловать!</p>
  </section>
  <section id="анатомия-программ-на-rust" class="level4">
  <h4>Анатомия программ на Rust</h4>
  <p>Теперь давайте детально разберемся, что происходит в программе “Привет, мир!”. Вот первый кусочек головоломки:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
  
  }</code></pre>
  <p>Эти строки объявляют «функцию» в Rust. Функция <code>main</code> особенна: это начало каждой программы на Rust. Первая строка говорит: «Мы объявляем функцию, именуемую <code>main</code>, которая не получает параметров и ничего не возвращает». Если бы мы хотели передать в функцию параметры, то указали бы их в скобках (<code>(</code> и <code>)</code>). Поскольку нам не надо ничего возвращать из этой функции, мы можем опустить указание типа возвращаемого значения. Мы вернёмся к этому позже.</p>
  <p>Вы должны были заметить, что функция обёрнута в фигурные скобки (<code>{</code> и <code>}</code>). Rust требует оборачивать ими тело любой функции. Также хорошим стилем считается ставить открывающую фигурную скобку на той же строке, что и объявление функции, отделённую от него одним пробелом.</p>
  <p>Теперь эта строка:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">    <span class="ot">println!</span>(<span class="st">&quot;Привет, мир!&quot;</span>);</code></pre>
  <p>Эта строка делает всю работу в нашей маленькой программе: выводит текст на экран. Тут есть несколько нюансов, которые имеют существенное значение. Во-первых, отступ в четыре пробела, а не табуляция.</p>
  <p>Теперь разберёмся с <code>println!()</code>. Это вызов одного из <a href="#sec--macros">макросов</a>, которыми представлено метапрограммирование в Rust. Если бы вместо макроса была функция, это выглядело бы следующим образом: <code>println()</code> (без <code>!</code>). Позже мы обсудим макросы Rust подробнее, а на данный момент все что вам нужно знать: если вы видите <code>!</code>, то вызывается макрос вместо обычной функции.</p>
  <p>Идём дальше. <code>&quot;Привет, мир!&quot;</code> — это «строка». Строки — это удивительно сложная тема для системного языка программирования. Это <a href="#sec--the-stack-and-the-heap">статически расположенная в памяти</a> строка. Мы передаём строку в качестве аргумента в <code>println!</code>, который выводит строки на экран. Достаточно просто!</p>
  <p>Cтрока заканчивается точкой с запятой (<code>;</code>). Rust — <a href="#expression-oriented-language">язык с ориентацией на выражения</a>, а это означает, что в нём большая часть вещей является выражением. <code>;</code> используется для указания конца выражения и начала следующего. Большинство строк кода на Rust заканчивается символом <code>;</code>.</p>
  </section>
  <section id="компиляция-и-запуск-это-отдельные-шаги" class="level4">
  <h4>Компиляция и запуск это отдельные шаги</h4>
  <p>В разделе “Написание и запуск программы на Rust” мы рассмотрели как запустить только что созданную программу. Теперь мы разберем каждый шаг по отдельности.</p>
  <p>Перед запуском программы ее нужно скомпилировать. Вы можете воспользоваться компилятором Rust с помощью команды <code>rustc</code> и передать ваш файл, как показано здесь:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">rustc</span> main.rs</code></pre>
  <p>Если раньше вы программировали на С или С++, то заметите, что это напоминает <code>gcc</code> или <code>clang</code>. После успешной компиляции Rust создаст двоичный исполняемый файл. На Linux или OSX вы можете убедиться в этом с помощью команды <code>ls</code>:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">ls</span>
  <span class="kw">main</span>  main.rs</code></pre>
  <p>Или в Windows:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">dir</span>
  <span class="kw">main.exe</span>  main.rs</code></pre>
  <p>У нас есть два файла: файл с нашим исходным кодом, с расширением <code>.rs</code>, и исполняемый файл (<code>main.exe</code> в Windows, <code>main</code> в остальных случаях). Все что осталось сделать — это запустить <code>main</code> или <code>main.exe</code>:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">./main</span>  <span class="co"># или main.exe на Windows</span></code></pre>
  <p>Мы вывели наш текст <code>&quot;Привет, мир!&quot;</code> в окне терминала.</p>
  <p>Если раньше вы использовали динамические языки программирования вроде Ruby, Python или JavaScript, то возможно разделение компиляции и запуска покажется вам странным. Rust — это язык, на котором программы <em>компилируются перед исполнением</em>. Это означает, что вы можете собрать программу, дать её кому-то ещё, и ему не нужно устанавливать Rust для запуска этой программы. Если вы передадите кому-нибудь <code>.rb</code>, <code>.py</code> или <code>.js</code> файл, им понадобится интерпретатор Ruby, Python или JavaScript чтобы скомпилировать и запустить вашу программу (это делается одной командой). В мире языков программирования много компромиссов, и Rust сделал свой выбор.</p>
  <p>Использовать <code>rustc</code> удобно лишь для небольших программ, но по мере роста проекта, потребуется инструмент, который поможет управлять настройками проекта, а также позволяет проще делиться кодом с другими людьми и проектами. Далее мы познакомимся с новым инструментом <code>Cargo</code>, который используется для написания настоящих программ на Rust.</p>
  </section>
  </section>
  <section id="привет-cargo" class="level3">
  <h3>Привет, Cargo!</h3>
  <p>Cargo — это система сборки и пакетный менеджер для Rust, и Rustaceans используют его для управления своими проектами на Rust. Cargo заботится о трех вещах: сборка кода, загрузка библиотек, от которых зависит ваш код, и сборка этих библиотек. Библиотеки, которые нужны вашему коду, мы называем “зависимостями” (“dependencies”), поскольку ваш код зависит от них.</p>
  <p>Поначалу вашей программе не понадобится никаких зависимостей, поэтому будем использовать только первую часть его возможностей. Со временем нам понадобится добавить несколько зависимостей, и нам не составит труда сделать это, используя Cargo.</p>
  <p>Подавляющее количество проектов на Rust используют Cargo, по-этому в рамках этой книги мы будем исходить из того, что вы тоже делаете это. Если вы использовали официальный установщик, то Cargo установился вместе с Rust. Если же вы установили Rust каким-либо другим образом, то вы можете проверить, есть ли у вас Cargo введя следующую команду в терминал:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> --version</code></pre>
  <p>Если вы увидели номер версии, то все в порядке. Если же вы увидели сообщение об ошибке на подобии “<code>команда не найдена</code>”, то вам нужно ознакомится с документацией для системы, в которой вы установили Rust.</p>
  <section id="переход-на-cargo" class="level4">
  <h4>Переход на Cargo</h4>
  <p>Давайте переведем наш проект “Привет, мир” на использование Cargo. Для перехода на Cargo нужно сделать три вещи:</p>
  <ol type="1">
  <li>Расположить файл с исходным кодом в правильной директории.</li>
  <li>Избавиться от старого исполняемого файла (<code>main.exe</code> или <code>main</code>) и сделать новый.</li>
  <li>Создать конфигурационный файл для Cargo.</li>
  </ol>
  <p>Давайте сделаем это!</p>
  <section id="создание-нового-исполняемого-файла-и-директории-с-исходным-кодом" class="level5">
  <h5>Создание нового исполняемого файла и директории с исходным кодом</h5>
  <p>Для начала вернитесь к вашему терминалу, перейдите в вашу директорию <em>hello_world</em> и введите следующие команды:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">mkdir</span> src
  $ <span class="kw">mv</span> main.rs src/main.rs
  $ <span class="kw">rm</span> main  <span class="co"># или 'del main.exe' для Windows</span></code></pre>
  <p>Cargo ожидает что ваши файлы с исходным кодом находятся в директории <em>src</em>. Такой подход оставляет верхний уровнь вашего проекта для вещей, вроде README, файлов с текстом лицензии и других не относящихся к вашему коду. Cargo помогает нам сохранять наши проекты красивыми и аккуратными. Всему есть свое место и все находится на своих местах.</p>
  <p>Теперь скопируйте <em>main.rs</em> в директорию <em>src</em> и удалите скомпилированный файл, который вы создали с помощью <code>rustc</code>.</p>
  <p>Отметим, что поскольку мы создаём исполняемый файл, то мы используем <code>main.rs</code>. Если бы мы хотели создать библиотеку, то мы использовали бы lib.rs. Cargo использует это соглашение для успешной компиляции вашего проекта, но вы можете это изменить, если захотите.</p>
  </section>
  <section id="создание-конфигурационного-файла" class="level5">
  <h5>Создание конфигурационного файла</h5>
  <p>Теперь создайте новый файл внутри директории <em>hello_world</em> и назовите его <code>Cargo.toml</code>.</p>
  <p>Убедитесь в том, что имя правильное: вам нужна заглавная <code>C</code>! В противном случае Cargo не найдет конфигурационный файл.</p>
  <p>Это файл в формате [TOML] (Tom’s Obvious, Minimal Language). TOML это аналог INI, но с некоторыми дополнениями, и он используется в конфигурационных файлах для Cargo.</p>
  <p>Вставьте следующую информацию внутрь этого файла:</p>
  <pre class="toml"><code>[package]
  
  name = &quot;hello_world&quot;
  version = &quot;0.0.1&quot;
  authors = [ &quot;Your name &lt;you@example.com&gt;&quot; ]</code></pre>
  <p>Первая строка, <code>[package]</code>, говорит о том, что следующие параметры отвечают за настройку пакета. Когда нам понадобится добавить больше информации в этот файл, мы создадим другие разделы, но сейчас нам достаточно настроек пакета.</p>
  <p>Другие три строчки устанавливают три значения конфигурации, которые необходимы Cargo для компиляции вашей программы: имя, версия и автор.</p>
  <p>После того как вы добавили эту информацию в <em>Cargo.toml</em>, сохраните изменения. На этом создание конфигурационного файла завершено.</p>
  </section>
  </section>
  <section id="сборка-и-запуск-cargo-проекта" class="level4">
  <h4>Сборка и запуск Cargo проекта</h4>
  <p>Теперь, после создания файла <code>Carto.toml</code> в корневой директории, мы готовы приступить к сборке и запуску нашего проекта. Чтобы сделать это, введите следующие команды:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> build
     <span class="kw">Compiling</span> hello_world v0.0.1 (file:///home/yourname/projects/hello_world)
  $ <span class="kw">./target/debug/hello_world</span>
  П<span class="kw">ривет</span>, <span class="kw">м</span>ир!</code></pre>
  <p>Та-да! Мы собрали наш проект вызвав <code>cargo build</code> и запустили его с помощью <code>./target/debug/hello_world</code>. Мы можем сделать это в один шаг используя <code>cargo run</code>:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> run
       <span class="kw">Running</span> <span class="kw">`target/debug/hello_world`</span>
  П<span class="kw">ривет</span>, <span class="kw">м</span>ир!</code></pre>
  <p>Заметьте, что сейчас мы не пересобрали наш проект. Cargo понял, что мы не изменили файл с исходным кодом и сразу запустил исполняемый файл. Если бы мы изменили файл, мы бы увидели оба шага:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> run
     <span class="kw">Compiling</span> hello_world v0.0.1 (file:///home/yourname/projects/hello_world)
       <span class="kw">Running</span> <span class="kw">`target/debug/hello_world`</span>
  П<span class="kw">ривет</span>, <span class="kw">м</span>ир!</code></pre>
  <p>На первый взгляд это кажется сложнее, по сравнению с более простым использованием <code>rustc</code>, но давайте подумаем о будущем: если в нашем проекте будет больше одного файла, мы должны будем вызывать rustc для каждого из них и передавать кучу параметров, чтобы собрать их вместе. С Cargo, когда наш проект вырастет, нам понадобится вызвать только команду <code>cargo build</code> и она всё сделает за нас.</p>
  </section>
  <section id="сборка-релизной-версии" class="level4">
  <h4>Сборка релизной версии</h4>
  <p>Когда вы закончите работать над проектом, и он окончательно будет готов к релизу, используйте команду <code>cargo build --release</code> для компиляции вашего проекта с оптимизацией. Эти оптимизации делают ваш код на Rust быстрее, но требуют больше времени на компиляцию. Именно из-за этого существует два разных способа: один для разработки, другой для сборки финальной версии, которую вы отдалите пользователям.</p>
  <p>Также вы должны были заметить, что Cargo создал новый файл: <code>Cargo.lock</code>.</p>
  <pre class="toml"><code>[root]
  name = &quot;hello_world&quot;
  version = &quot;0.0.1&quot;</code></pre>
  <p>Этот файл используется Cargo для отслеживания зависимостей в вашем приложении. Прямо сейчас у нас нет ни одной, поэтому этот файл немного пустоват. Вам не нужно редактировать этот файл самостоятельно, Cargo сам с ним разберётся.</p>
  <p>Вот и все! Мы успешно собрали <code>hello_world</code> с помощью Cargo.</p>
  <p>Несмотря на то, что наша программа проста, мы использовали большую часть реальных инструментов, которые вы будете использовать в своём дальнейшем пути Rust-программиста. Более того, вы можете расчитывать, что практически все проекты на Rust можно будет собрать с помощью вариации этих команд:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">git</span> clone someurl.com/foo
  $ <span class="kw">cd</span> foo
  $ <span class="kw">cargo</span> build</code></pre>
  </section>
  <section id="простой-способ-создать-новый-cargo-проект" class="level4">
  <h4>Простой способ создать новый Cargo проект</h4>
  <p>Вам не нужно повторять вышеприведённые шаги каждый раз, когда вы хотите создать новый проект! Cargo может создать директорию проекта, в которой вы сразу сможете приступить к разработке.</p>
  <p>Чтобы создать новый проект с помощью Cargo, нужно ввести команду <code>cargo new</code>:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> new hello_world --bin</code></pre>
  <p>Мы указываем аргумент <code>--bin</code>, так как хотим создать исполняемую программу. Если мы не укажем этот аргумент, то Cargo создаст проект для библиотеки. Исполняемые файлы частно называют <em>бинарниками</em> (поскольку обычно они находятся в <code>/usr/bin</code>, если вы используете Unix систему).</p>
  <p>Cargo сгенерировал два файла и одну директорию: <code>Cargo.toml</code> и директорию <em>src</em> с файлом <em>main.rs</em>. Они должны выглядеть так же как те, что мы создали до этого.</p>
  <p>Этого достаточно для того чтобы начать. Открыв <code>Cargo.toml</code>, вы должны увидеть следующее:</p>
  <pre class="toml"><code>[package]
  
  name = &quot;hello_world&quot;
  version = &quot;0.1.0&quot;
  authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]</code></pre>
  <p>Cargo наполнил этот файл значениями по умолчанию на основании переданных аргументов и глобальной конфигурации <code>git</code>. Также он инициализировал директорию <code>hello_world</code> как <code>git</code> репозитоий.</p>
  <p>Вот что должно быть внутри <code>src/main.rs</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="ot">println!</span>(<span class="st">&quot;Hello, world!&quot;</span>);
  }</code></pre>
  <p>Cargo создал «Hello World!» для нас и вы уже можете приступить к программированию!</p>
  <blockquote>
  <p>У Cargo есть собственное <a href="http://doc.crates.io/guide.html">руководство</a>, в котором про него рассказано более детально.</p>
  </blockquote>
  </section>
  </section>
  <section id="заключение" class="level3">
  <h3>Заключение</h3>
  <p>Это основы, которые вы будете часто использовать на протяжении всего вашего взаимодействия с Rust. Теперь давайте отложим инструментарий и узнаем больше о самом языке.</p>
  <p>У вас есть два пути: погрузиться в изучение реального проекта, открыв раздел «<a href="#sec--learn-rust">Изучение Rust</a>», или начать с самого низа и постепенно продвигаться наверх, начав с раздела «<a href="#sec--syntax-and-semantics">Синтаксис и семантика</a>». Программисты, имеющие опыт работы с системными языками, вероятно, предпочтут «Изучение Rust», в то время как программисты, имеющие опыт работы с динамическими языками, скорее всего захотят пойти по второму пути. Разные люди учатся по-разному! Выберите то, что подходит именно вам.</p>
  </section>
  </section>
  <section id="sec--learn-rust" class="level1">
  <h1>Изучение Rust</h1>
  <p>Добро пожаловать! Этот раздел книги содержит несколько глав, которые научат вас создавать проекты на Rust. Вы также получите поверхностное представление о языке - мы не будем сильно углубляться в детали.</p>
  <p>Если вы хотите более основательно изучить язык, читайте раздел «<a href="#sec--syntax-and-semantics">Синтаксис и семантика</a>».</p>
  <section id="sec--guessing-game" class="level2">
  <h2>Угадайка</h2>
  <p>В качестве нашего первого проекта, мы решим классическую для начинающих программистов задачу: игра-угадайка. Немного о том, как игра должна работать: наша программа генерирует случайное целое число из промежутка от 1 до 100. Затем она просит ввести число, которое она «загадала». Для каждого введённого нами числа, она говорит, больше ли оно, чем «загаданное», или меньше. Игра заканчивается когда мы отгадываем число. Звучит не плохо, не так ли?</p>
  <section id="создание-нового-проекта" class="level3">
  <h3>Создание нового проекта</h3>
  <p>Давайте создадим новый проект. Перейдите в вашу директорию с проектами. Помните, как мы создавали структуру директорий и <code>Cargo.toml</code> для <code>hello_world</code>? Cargo может сделать это за нас. Давайте воспользуемся этим:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cd</span> ~/projects
  $ <span class="kw">cargo</span> new guessing_game --bin
  $ <span class="kw">cd</span> guessing_game</code></pre>
  <p>Мы сказали Cargo, что хотим создать новый проект с именем <code>guessing_game</code>. При помощи флага <code>--bin</code>, мы указали что хотим создать исполняемый файл, а не библиотеку.</p>
  <p>Давайте посмотрим сгенерированный <code>Cargo.toml</code>:</p>
  <pre class="toml"><code>[package]
  
  name = &quot;guessing_game&quot;
  version = &quot;0.1.0&quot;
  authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]</code></pre>
  <p>Cargo взял эту информацию из вашего рабочего окружения. Если информация не корректна, исправьте её.</p>
  <p>Наконец, Cargo создал программу <code>Привет, мир!</code>. Посмотрите файл <code>src/main.rs</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="ot">println!</span>(<span class="st">&quot;Привет, мир!&quot;</span>)
  }</code></pre>
  <p>Давайте попробуем скомпилировать созданный Cargo проект:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> build
     <span class="kw">Compiling</span> guessing_game v0.1.0 (file:///home/you/projects/guessing_game)</code></pre>
  <p>Замечательно! Снова откройте <code>src/main.rs</code>. Мы будем писать весь наш код в этом файле.</p>
  <p>Прежде, чем мы начнём работу, давайте рассмотрим ещё одну команду Cargo: <code>run</code>. <code>cargo run</code> похожа на <code>cargo build</code>, но после завершения компиляции, она запускает получившийся исполняемый файл:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> run
     <span class="kw">Compiling</span> guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
       <span class="kw">Running</span> <span class="kw">`target/debug/guessing_game`</span>
  П<span class="kw">ривет</span>, <span class="kw">м</span>ир!</code></pre>
  <p>Великолепно! Команда <code>run</code> помогает, когда надо быстро пересобирать проект. Наша игра как раз и есть такой проект: нам надо быстро тестировать каждое изменение, прежде чем мы приступим к следующей части программы.</p>
  </section>
  <section id="обработка-предположения" class="level3">
  <h3>Обработка предположения</h3>
  <p>Давайте начнём! Первая вещь, которую мы должны сделать для нашей игры — это позволить игроку вводить предположения. Поместите следующий код в ваш <code>src/main.rs</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::io;
  
  <span class="kw">fn</span> main() {
      <span class="ot">println!</span>(<span class="st">&quot;Угадайте число!&quot;</span>);
  
      <span class="ot">println!</span>(<span class="st">&quot;Пожалуйста, введите предположение.&quot;</span>);
  
      <span class="kw">let</span> <span class="kw">mut</span> guess = String::new();
  
      io::stdin().read_line(&amp;<span class="kw">mut</span> guess)
          .ok()
          .expect(<span class="st">&quot;Не удалось прочитать строку&quot;</span>);
  
      <span class="ot">println!</span>(<span class="st">&quot;Ваша попытка: {}&quot;</span>, guess);
  }</code></pre>
  <p>Здесь много чего! Давайте разберём этот участок по частям.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::io;</code></pre>
  <p>Нам надо получить то, что ввёл пользователь, а затем вывести результат на экран. Значит нам понадобится библиотека <code>io</code> из стандартной библиотеки. Изначально, во <a href="http://doc.rust-lang.org/std/prelude/index.html">вступлении</a> (prelude), Rust импортирует в нашу программу лишь самые необходимые вещи. Если чего-то нет по вступлении, мы должны указать при помощи <code>use</code>, что хотим это использовать.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {</code></pre>
  <p>Как вы уже видели до этого, функция <code>main()</code> — это точка входа в нашу программу. <code>fn</code> объявляет новую функцию. Пустые круглые скобки <code>()</code> показывают, что она не принимает аргументов. Открывающая фигурная скобка <code>{</code> начинает тело нашей функции. Из-за того, что мы не указали тип возвращаемого значения, предполагается, что будет возвращаться <code>()</code> — пустой <a href="#tuples">кортеж</a>.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">    <span class="ot">println!</span>(<span class="st">&quot;Угадайте число!&quot;</span>);
  
      <span class="ot">println!</span>(<span class="st">&quot;Пожалуйста, введите предположение.&quot;</span>);</code></pre>
  <p>Мы уже изучили, что <code>println!()</code> — это <a href="#sec--macros">макрос</a>, который выводит <a href="#sec--strings">строки</a> на экран.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">    <span class="kw">let</span> <span class="kw">mut</span> guess = String::new();</code></pre>
  <p>Теперь интереснее! Как же много всего происходит в этой строке! Первая вещь, на которую следует обратить внимание — <a href="#sec--variable-bindings">выражение let</a>, которое используется для <code>создания связи</code>. Оно выглядит так:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> foo = bar;</code></pre>
  <p>Это создаёт новую связь с именем <code>foo</code> и привязывает ей значение <code>bar</code>. Во многих языках это называется <code>переменная</code>, но в Rust связывание переменных имеет несколько трюков в рукаве.</p>
  <p>Например, по умолчанию, связи <a href="#sec--mutability">неизменяемы</a>. По этой причине наш пример использует <code>mut</code>: этот модификатор разрешает менять связь. С левой стороны у <code>let</code> может быть не просто имя связи, а <a href="#sec--patterns">образец</a>. Мы будем использовать их дальше. Их достаточно просто использовать:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> foo = <span class="dv">5</span>; <span class="co">// неизменяемая связь</span>
  <span class="kw">let</span> <span class="kw">mut</span> bar = <span class="dv">5</span>; <span class="co">// изменяемая связь</span></code></pre>
  <p>Ах да, <code>//</code> начинает комментарий, который заканчивается в конце строки. Rust игнорирует всё, что находится в <a href="#sec--comments">комментариях</a>.</p>
  <p>Теперь мы знаем, что <code>let mut guess</code> объявляет изменяемую связь с именем <code>guess</code>, а по другую сторону от <code>=</code> находится то, что будет привязано: <code>String::new()</code>.</p>
  <p><code>String</code> — это строковый тип, предоставляемый нам стандартной библиотекой. <a href="http://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a> — это текст в кодировке UTF-8 переменной длины.</p>
  <p>Синтаксис <code>::new()</code> использует <code>::</code>, так как это привязанная к определённому типу функция. То есть, она привязана к самому типу <code>String</code>, а не к определённой переменной типа <code>String</code>. Некоторые языки называют это «статическим методом».</p>
  <p>Имя этой функции — <code>new()</code>, так как она создаёт новый, пустой <code>String</code>. Вы можете найти эту функцию у многих типов, потому что это общее имя для создания нового значения определённого типа.</p>
  <p>Давайте посмотрим дальше:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">    io::stdin().read_line(&amp;<span class="kw">mut</span> guess)
          .ok()
          .expect(<span class="st">&quot;Не удалось прочитать строку&quot;</span>);</code></pre>
  <p>Это уже побольше! Давайте это всё разберём. В первой строке есть две части. Это первая:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">io::stdin()</code></pre>
  <p>Помните, как мы импортировали (<code>use</code>) <code>std::io</code> в самом начале нашей программы? Сейчас мы вызвали ассоциированную с ним функцию. Если бы мы не сделали <code>use std::io</code>, нам бы пришлось здесь написать <code>std::io::stdin()</code>.</p>
  <p>Эта функция возвращает обработчик стандартного ввода нашего терминала. Более подробно об это можно почитать в <a href="http://doc.rust-lang.org/std/io/struct.Stdin.html">std::io::Stdin</a>.</p>
  <p>Следующая часть использует этот обработчик для получения всего, что введёт пользователь:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">.read_line(&amp;<span class="kw">mut</span> guess)</code></pre>
  <p>Здесь мы вызвали метод <a href="http://doc.rust-lang.org/std/io/struct.Stdin.html#method.read_line"><code>read_line()</code></a> обработчика. <a href="#sec--method-syntax">Методы</a> похожи на привязанные функции, но доступны только у определённого экземпляра типа, а не самого типа. Мы указали один аргумент функции <code>read_line()</code>: <code>&amp;mut guess</code>.</p>
  <p>Помните, как мы выше привязали <code>guess</code>? Мы сказали, что она изменяема. Однако, <code>read_line</code> не получает в качестве аргумента <code>String</code>: она получает <code>&amp;mut String</code>. В Rust есть такая особенность, называемая «<a href="#sec--references-and-borrowing">ссылки</a>», которая позволяет нам иметь несколько ссылок на одни и те же данные, что позволяет избежать излишнего их копирования. Ссылки — достаточно сложная особенность, и одним из основных подкупающих достоинств Rust является то, как он решает вопрос безопасности и простоты их использования. Пока что мы не должны знать об этих деталях, чтобы завершить нашу программу. Сейчас, всё, что нам нужно — это знать, что ссылки, как и связывание при помощи <code>let</code>, неизменяемы по умолчанию. Следовательно, мы должны написать <code>&amp;mut guess</code>, а не <code>&amp;guess</code>.</p>
  <p>Почему <code>read_line()</code> получает изменяемую ссылку на строку? Его работа — это взять то, что пользователь написал в стандартный ввод, и положить это в строку. Итак, функция получает строку в качестве аргумента, и для того, чтобы добавить в эту строку что-то, она должна быть изменяемой.</p>
  <p>Но мы пока что ещё не закончили с этой строкой кода. Пока это одна строка текста, это только первая часть одной логической строки кода:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">        .ok()
          .expect(<span class="st">&quot;Не удалось прочитать строку&quot;</span>);</code></pre>
  <p>Когда мы вызываем метод, используя синтаксис <code>.foo()</code>, мы можем перенести вызов в новую строку и сделать для него отступ. Это помогает работать с длинными строками. Мы <em>могли бы</em> сделать и так:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">    io::stdin().read_line(&amp;<span class="kw">mut</span> guess).ok().expect(<span class="st">&quot;Не удалось прочитать строку&quot;</span>);</code></pre>
  <p>Но это достаточно трудно читать. Поэтому мы разделили строку: по строке на каждый вызов метода. Мы уже поговорили о <code>read_line()</code>, но ещё ничего не сказали про <code>ok()</code> и <code>expect()</code>. Мы узнали, что <code>read_line()</code> передаёт всё, что пользователь ввёл в <code>&amp;mut String</code>, которую мы ему передали. Но этот метод так же и возвращает значение: в данном случае — <a href="http://doc.rust-lang.org/std/io/type.Result.html"><code>io::Result</code></a>. В стандартной библиотеке Rust есть несколько типов с именем <code>Result</code>: общая версия <a href="http://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a> и несколько отдельных версий в подбиблиотеках, например <code>io::Result</code>.</p>
  <p>Целью типов <code>Result</code> является преобразование информации об ошибках, полученных от обработчика. У значений типа <code>Result</code>, как и любого другого типа, есть определённые для него методы. В данном случае, у <code>io::Result</code> имеется метод <code>ok()</code>, который говорит, что «мы хотим получить это значение, если всё прошло хорошо. Если это не так, выбрось сообщение об ошибке». Но зачем выбрасывать? Для небольших программ, мы можем захотеть только вывести сообщение об ошибке и прекратить выполнение программы. <a href="http://doc.rust-lang.org/std/result/enum.Result.html#method.ok">Метод <code>ok()</code></a> возвращает значение, у которого объявлен другой метод: <code>expect()</code>. <a href="http://doc.rust-lang.org/std/option/enum.Option.html#method.expect">Метод <code>expect()</code></a> берёт значение, для которого он вызван, и если оно не удачное, выполняет <a href="#sec--error-handling"><code>panic!</code></a> со строкой, заданной методу в качестве аргумента. <code>panic!</code> остановит нашу программу и выведет сообщение об ошибке.</p>
  <p>Eсли мы уберем вызовы этих двух методов, наша программа скомпилируется, но мы получим следующее предупреждение:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> build
     <span class="kw">Compiling</span> guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
  <span class="kw">src</span>/main.rs:<span class="kw">10</span>:5: 10:39 warning: unused result which must be used,
  <span class="co">#[warn(unused_must_use)] on by default</span>
  <span class="kw">src</span>/main.rs:<span class="kw">10</span>     io::stdin()<span class="kw">.read_line</span>(<span class="kw">&amp;mut</span> guess);
                     ^<span class="kw">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></code></pre>
  <p>Rust предупреждает, что мы не используем значение <code>Result</code>. Это предупреждение пришло из специальной аннотации, которая указана в <code>io::Result</code>. Rust пытается сказать нам, что мы не обрабатываем ошибки, которые могут возникнуть. Наиболее правильным решением предотвращения ошибки будет её обработка. К счастью, если мы только хотим обрушить приложение, если есть проблема, мы можем использовать эти два небольших метода. Если мы можем восстановить что-либо из ошибки, мы должны сделать что-либо другое, но мы сохраним это для будущего проекта.</p>
  <p>Там всего одна строка из первого примера:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">    <span class="ot">println!</span>(<span class="st">&quot;Ваша попытка: {}&quot;</span>, guess);
  }</code></pre>
  <p>Здесь выводится на экран строка, которая была получена с нашего ввода. <code>{}</code> - это указатель места заполнения. В качестве второго аргумента макроса <code>println!</code> мы указали <code>guess</code>. Если нам надо вывести несколько привязок, в самом простом случае, мы должны поставить несколько указателей, по одному на каждую привязку:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">5</span>;
  <span class="kw">let</span> y = <span class="dv">10</span>;
  
  <span class="ot">println!</span>(<span class="st">&quot;x и y: {} и {}&quot;</span>, x, y);</code></pre>
  <p>Просто.</p>
  <p>Мы можем запустить то, что у нас есть при помощи <code>cargo run</code>:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> run
     <span class="kw">Compiling</span> guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
       <span class="kw">Running</span> <span class="kw">`target/debug/guessing_game`</span>
  У<span class="kw">гадайте</span> чис<span class="kw">ло</span>!
  П<span class="kw">ожалуйста</span>, введите предп<span class="kw">оложе</span>ние.
  <span class="kw">6</span>
  В<span class="kw">аша</span> п<span class="kw">о</span>пытка: 6</code></pre>
  <p>Всё правильно! Наша первая часть завершена: мы можем получать данные с клавиатуры и потом печатать их на экран.</p>
  </section>
  <section id="генерация-секретного-числа" class="level3">
  <h3>Генерация секретного числа</h3>
  <p>Далее, нам надо сгенерировать секретное число. В стандартной библиотеке Rust нет ничего, что могло бы нам предоставить функционал для генерации случайных чисел. Однако, разработчики Rust для этого предоставили [контейнер (crate) <code>rand</code>][randcrate]. «Контейнер» — это пакет с кодом Rust. Наш проект — «бинарный контейнер», из которого в итоге получится исполняемый файл. <code>rand</code> — «библиотечный контейнер», который содержит код, предназначенный для использования с другими программами.</p>
  <p>Прежде, чем мы начнём писать код с использованием <code>rand</code>, мы должны модифицировать наш <code>Cargo.toml</code>. Откроем его и добавим в конец следующие строчки:</p>
  <pre class="toml"><code>[dependencies]
  
  rand=&quot;0.3.0&quot;</code></pre>
  <p>Секция <code>[dependencies]</code> похожа на секцию <code>[package]</code>: всё, что расположено после объявления секции и до начала следующей, является частью этой секции. Cargo использует секцию с зависимостями чтобы знать о том, какие сторонние контейнеры потребуются, а так же какие их версии необходимы. В данном случае, мы используем версию <code>0.3.0</code>. Cargo понимает <a href="http://semver.org/lang/ru">семантическое версионирование</a>, которое является стандартом нумерации версий. Если мы хотим использовать последнюю версию контейнера, мы можем использовать <code>*</code>. Так же мы можем указать необходимый промежуток версий. В <a href="http://doc.crates.io/crates-io.html">документации Cargo</a> есть больше информации.</p>
  <p>Теперь, без каких-либо изменений в нашем коде, давайте соберём наш проект:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> build
      <span class="kw">Updating</span> registry <span class="kw">`https</span>://github.com/rust-lang/crates.io-index<span class="kw">`</span>
   <span class="kw">Downloading</span> rand v0.3.8
   <span class="kw">Downloading</span> libc v0.1.6
     <span class="kw">Compiling</span> libc v0.1.6
     <span class="kw">Compiling</span> rand v0.3.8
     <span class="kw">Compiling</span> guessing_game v0.1.0 (file:///home/you/projects/guessing_game)</code></pre>
  <p>(Конечно же, вы можете видеть другие версии.)</p>
  <p>Много нового! Теперь, когда у нас есть внешние зависимости, Cargo скачал последние версии каждой из них из своего реестра, являющегося копией реестра с <a href="https://crates.io">Crates.io</a>. Crates.io — это место, где программисты на Rust могут публиковать свои проекты с открытым исходным кодом, чтобы их использовали в других проектах.</p>
  <p>После обновления реестра, Cargo проверяет раздел <code>[dependencies]</code> и скачивает всё, что нам необходимо. В нашем случае, мы сказали, что наш проект зависит от <code>rand</code>. Самому контейнеру <code>rand</code> для работы нужен контейнер <code>libc</code>. По этой причине Cargo скачал и <code>libc</code>. После загрузки всего необходимого, оно компилируется, а затем компилируется и наш проект.</p>
  <p>Если мы запустим <code>cargo build</code> снова, текст вывода будет другим:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> build</code></pre>
  <p>Всё правильно, ничего не будет выведено! Cargo знает, что уже собраны и наш проект, и все его зависимости, а значит незачем делать это снова. Раз делать ничего не надо, Cargo просто завершил работу. Если мы снова откроем файл <code>src/main.rs</code>, сделаем какие-нибудь изменения и затем сохраним их, мы увидим только одну строку:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> build
     <span class="kw">Compiling</span> guessing_game v0.1.0 (file:///home/you/projects/guessing_game)</code></pre>
  <p>Итак, мы сказали Cargo, что нам нужна библиотека <code>rand</code> с любой версией ветки <code>0.3.x</code>, и он взял последнюю версию, на тот момент, когда его запустили - <code>v0.3.8</code>. Но что делать, когда на следующей неделе выйдет версия <code>v0.3.9</code>, содержащая важные изменения? Что если исправления настолько масштабны, что версия <code>0.3.9</code> становится несовместимой с нашим кодом?</p>
  <p>Решением этой проблемы является файл <code>Cargo.lock</code>, который находится в директории с нашим проектом. Когда мы в первый раз собирали наш проект, Cargo подобрал версии, подходящие под наши условия, и записал их в файл <code>Cargo.lock</code>. Когда мы в будущем будем собирать наш проект, Cargo будет проверять, существует ли <code>Cargo.lock</code>, и затем использовать указанные в нём версии контейнеров. Благодаря этому мы автоматически получаем повторяемые сборки. Другими словами, мы будем использовать контейнер версии <code>0.3.8</code> до тех пор, пока явно не обновим информацию о его версии в <code>Cargo.lock</code>.</p>
  <p>А что, если мы захотим использовать версию <code>v0.3.9</code>? У Cargo есть другая команда, <code>update</code>, которая скажет «игнорируй Cargo.lock, найди последние версии библиотек из той ветки, которую мы указали в Cargo.toml. Когда всё сделаешь, запиши информацию о версиях в Cargo.lock». Но по умолчанию, Cargo смотрит только версию больше, чем <code>0.3.0</code>, и меньше <code>0.4.0</code>. Если мы хотим перейти на версии <code>0.4.x</code>, мы должны указать это в <code>Cargo.toml</code>. Потом, когда мы запустим <code>cargo build</code>, Cargo обновит индекс и пересмотрит наши требования к <code>rand</code>.</p>
  <p>В <a href="http://doc.crates.io">документации</a> по Cargo можно узнать о нём, а так же о <a href="http://doc.crates.io/crates-io.html">его экосистеме</a> намного больше, но пока что это всё, что нам нужно знать. Cargo делает повторное использование библиотек намного проще, и программисты на Rust, как правило, пишут небольшие проекты, которые входят в состав других более крупных проектов.</p>
  <p>Давайте использовать <code>rand</code>. Вот наш следующий шаг:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> crate rand;
  
  <span class="kw">use</span> std::io;
  <span class="kw">use</span> rand::Rng;
  
  <span class="kw">fn</span> main() {
      <span class="ot">println!</span>(<span class="st">&quot;Угадайте число!&quot;</span>);
  
      <span class="kw">let</span> secret_number = rand::thread_rng().gen_range(<span class="dv">1</span>, <span class="dv">101</span>);
  
      <span class="ot">println!</span>(<span class="st">&quot;Загаданное число: {}&quot;</span>, secret_number);
  
      <span class="ot">println!</span>(<span class="st">&quot;Пожалуйста, введите предположение.&quot;</span>);
  
      <span class="kw">let</span> <span class="kw">mut</span> guess = String::new();
  
      io::stdin().read_line(&amp;<span class="kw">mut</span> guess)
          .ok()
          .expect(<span class="st">&quot;Не удалось прочитать строку&quot;</span>);
  
      <span class="ot">println!</span>(<span class="st">&quot;Ваша попытка: {}&quot;</span>, guess);
  }</code></pre>
  <p>Первое, что мы сделали — изменили первую строку. Теперь она выглядит так: <code>extern crate rand</code>. Так как мы указали <code>rand</code> в разделе <code>[dependencies]</code>, мы можем использовать <code>extern crate</code> для того, чтобы Rust знал, что мы собираемся использовать эту зависимость. <code>extern crate</code> также выполняет эквивалент оператора <code>use rand;</code>, т.е. теперь мы можем использовать всё, что есть в контейнере <code>rand</code>, используя префикс <code>rand::</code>.</p>
  <p>Далее, мы добавили новую строку <code>use</code>: <code>use rand::Rng</code>. Мы собираемся использовать метод, а ему нужно, чтобы Rng был в области видимости. Основная идея такова: методы, объявленные где-то в другом месте, называются «типажами» (traits), и для того, чтобы этот метод можно было использовать, необходимо чтобы типаж был в области видимости. Чтобы узнать об этом более подробно, можно прочитать секцию о <a href="#sec--traits">типажах</a>.</p>
  <p>Мы добавили две новые строки в середину кода:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">    <span class="kw">let</span> secret_number = rand::thread_rng().gen_range(<span class="dv">1</span>, <span class="dv">101</span>);
  
      <span class="ot">println!</span>(<span class="st">&quot;Загаданное число: {}&quot;</span>, secret_number);</code></pre>
  <p>Мы используем функцию <code>rand::thread_rng()</code> для получения копии генератора случайных чисел, который будет локальным для текущего <a href="#sec--concurrency">потока</a> выполнения. Выше мы добавили <code>use rand::Rng</code> и теперь можем использовать метод <code>gen_range()</code>. Этот метод получает два аргумента и генерирует число, которое может быть больше либо равно первому аргументу и меньше, чем второй аргумент. Таким образом, если мы укажем числа 1 и 101, то от генератора можно получить числа от 1 до 100 включительно.</p>
  <p>Вторая строка печатает наше секретное число. Это поможет нам во время тестирования, пока мы разрабатываем нашу программу. Но мы обязательно удалим эту строчку в финальной версии. Будет не интересно играть в игру, если она сразу печатает ответ!</p>
  <p>Давайте запустим изменённую программу:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> run
     <span class="kw">Compiling</span> guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
       <span class="kw">Running</span> <span class="kw">`target/debug/guessing_game`</span>
  У<span class="kw">гадайте</span> чис<span class="kw">ло</span>!
  З<span class="kw">агада</span>нн<span class="kw">о</span>е чис<span class="kw">ло</span>: <span class="kw">7</span>
  П<span class="kw">ожалуйста</span>, введите предп<span class="kw">оложе</span>ние.
  <span class="kw">4</span>
  В<span class="kw">аша</span> п<span class="kw">о</span>пытка: 4
  $ <span class="kw">cargo</span> run
       <span class="kw">Running</span> <span class="kw">`target/debug/guessing_game`</span>
  У<span class="kw">гадайте</span> чис<span class="kw">ло</span>!
  З<span class="kw">агада</span>нн<span class="kw">о</span>е чис<span class="kw">ло</span>: <span class="kw">83</span>
  П<span class="kw">ожалуйста</span>, введите предп<span class="kw">оложе</span>ние.
  <span class="kw">5</span>
  В<span class="kw">аша</span> п<span class="kw">о</span>пытка: 5</code></pre>
  <p>Замечательно! Следующий шаг: сравнение нашего предположения с «загаданным» числом.</p>
  </section>
  <section id="сравнение" class="level3">
  <h3>Сравнение</h3>
  <p>Теперь, когда мы знаем, что ввёл пользователь, давайте сравним «загаданное» число с предполагаемым ответом. Здесь приведён наш следующий шаг, который, к сожалению, не будет работать:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> crate rand;
  
  <span class="kw">use</span> std::io;
  <span class="kw">use</span> std::cmp::Ordering;
  <span class="kw">use</span> rand::Rng;
  
  <span class="kw">fn</span> main() {
      <span class="ot">println!</span>(<span class="st">&quot;Угадайте число!&quot;</span>);
  
      <span class="kw">let</span> secret_number = rand::thread_rng().gen_range(<span class="dv">1</span>, <span class="dv">101</span>);
  
      <span class="ot">println!</span>(<span class="st">&quot;Загаданное число: {}&quot;</span>, secret_number);
  
      <span class="ot">println!</span>(<span class="st">&quot;Пожалуйста, введите предположение.&quot;</span>);
  
      <span class="kw">let</span> <span class="kw">mut</span> guess = String::new();
  
      io::stdin().read_line(&amp;<span class="kw">mut</span> guess)
          .ok()
          .expect(<span class="st">&quot;Не удалось прочитать строку&quot;</span>);
  
      <span class="ot">println!</span>(<span class="st">&quot;Ваша попытка: {}&quot;</span>, guess);
  
      <span class="kw">match</span> guess.cmp(&amp;secret_number) {
          Ordering::Less    =&gt; <span class="ot">println!</span>(<span class="st">&quot;Слишком маленькое!&quot;</span>),
          Ordering::Greater =&gt; <span class="ot">println!</span>(<span class="st">&quot;Слишком большое!&quot;</span>),
          Ordering::Equal   =&gt; <span class="ot">println!</span>(<span class="st">&quot;Вы выиграли!&quot;</span>),
      }
  }</code></pre>
  <p>Здесь мы видим что-то новое. Первое — это ещё один <code>use</code>. Мы ввели в область видимости тип <code>std::cmp::Ordering</code>. Далее, ещё пять новых строк в конце, которые используют его:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">match</span> guess.cmp(&amp;secret_number) {
      Ordering::Less    =&gt; <span class="ot">println!</span>(<span class="st">&quot;Слишком маленькое!&quot;</span>),
      Ordering::Greater =&gt; <span class="ot">println!</span>(<span class="st">&quot;Слишком большое!&quot;</span>),
      Ordering::Equal   =&gt; <span class="ot">println!</span>(<span class="st">&quot;Вы выиграли!&quot;</span>),
  }</code></pre>
  <p>Метод <code>cmp()</code> может быть вызван у чего-либо, что может сравниваться, и получает ссылку на то, с чем мы хотим его сравнить. Результатом сравнения будет тип <code>Ordering</code>, который мы добавили выше. Мы используем оператор <a href="#sec--match"><code>match</code></a> для определения <code>Ordering</code> — результата сравнения. <code>Ordering</code> — <a href="#sec--enums"><code>перечисление</code></a>. Они обозначаются <code>enum</code>, сокращённо от <code>enumeration</code> (перечисление). Перечисления выглядят следующим образом:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">enum</span> Foo {
      Bar,
      Baz,
  }</code></pre>
  <p>С таким определением, всё, что имеет тип <code>Foo</code> может иметь значение либо <code>Foo::Bar</code>, либо <code>Foo::Baz</code>. Мы используем <code>::</code> для обозначения пространства имён для вариантов перечисления.</p>
  <p>У перечисления <a href="http://doc.rust-lang.org/std/cmp/enum.Ordering.html"><code>Ordering</code></a> есть три возможных варианта: <code>Less</code>, <code>Equal</code> и <code>Greater</code>. Выражение <code>match</code> получает переменную какого-либо типа и предлагает вам создать «ветви» для каждого возможного значения. Так как у нас есть три возможных значения <code>Ordering</code>, у нас будет три ветви:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">match</span> guess.cmp(&amp;secret_number) {
      Ordering::Less    =&gt; <span class="ot">println!</span>(<span class="st">&quot;Слишком маленькое!&quot;</span>),
      Ordering::Greater =&gt; <span class="ot">println!</span>(<span class="st">&quot;Слишком большое!&quot;</span>),
      Ordering::Equal   =&gt; <span class="ot">println!</span>(<span class="st">&quot;Вы выиграли!&quot;</span>),
  }</code></pre>
  <p>Если результатом сравнения будет значение <code>Less</code>, мы выведем на экран <code>Слишком маленькое!</code>; если будет <code>Greater</code>, то <code>Слишком большое!</code>; и если <code>Equal</code>, то <code>Вы выиграли!</code>. <code>match</code> очень удобен и он часто используется в Rust.</p>
  <p>Мы упоминали, что это не совсем корректный код, но всё же давайте попробуем:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> build
     <span class="kw">Compiling</span> guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
  <span class="kw">src</span>/main.rs:<span class="kw">28</span>:21: 28:35 error: mismatched types:
   <span class="kw">expected</span> <span class="kw">`&amp;collections</span>::string::String<span class="kw">`</span>,
      <span class="kw">found</span> <span class="kw">`&amp;_`</span>
  <span class="kw">(expected</span> struct <span class="kw">`collections</span>::string::String<span class="kw">`</span>,
      <span class="kw">found</span> integral variable<span class="kw">)</span> [<span class="kw">E0308</span>]
  <span class="kw">src</span>/main.rs:<span class="kw">28</span>     match guess.cmp(<span class="kw">&amp;secret_number</span>) <span class="kw">{</span>
                                     ^<span class="kw">~~~~~~~~~~~~~</span>
  <span class="kw">error</span>: aborting due to previous error
  <span class="kw">Could</span> not compile <span class="kw">`guessing_game`</span>.</code></pre>
  <p>У-у-у! Это большая ошибка. Суть этой ошибки в «несоответствии типов» (mismatched types). В Rust строгая статическая система типов. Однако, у нас также есть вывод типов. Когда мы пишем <code>let guess = String::new()</code>, Rust понимает, что <code>guess</code> должна быть типа <code>String</code>, благодаря чему мы можем не указывать тип явно. <code>secret_number</code> — число, которое может иметь значение от одного до ста. Оно может иметь тип <code>i32</code> — 32-битное целое, или <code>u32</code> — 32-битное целое без знака, или <code>i64</code> — 64-битное целое, или какой-нибудь другой. По умолчанию, Rust сделает его 32-битным целым, <code>i32</code>. Однако, здесь Rust не знает как сравнить <code>guess</code> и <code>secret_number</code>. Они должны быть одного типа. В итоге, чтобы можно было сравнить <code>guess</code> и <code>secret_number</code>, мы должны преобразовать переменную <code>guess</code>, которую мы прочитали с ввода, из типа <code>String</code> в настоящий числовой тип. Мы можем сделать это, добавив несколько строчек. Вот как будет выглядеть наша программа:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> crate rand;
  
  <span class="kw">use</span> std::io;
  <span class="kw">use</span> std::cmp::Ordering;
  <span class="kw">use</span> rand::Rng;
  
  <span class="kw">fn</span> main() {
      <span class="ot">println!</span>(<span class="st">&quot;Угадайте число!&quot;</span>);
  
      <span class="kw">let</span> secret_number = rand::thread_rng().gen_range(<span class="dv">1</span>, <span class="dv">101</span>);
  
      <span class="ot">println!</span>(<span class="st">&quot;Загаданное число: {}&quot;</span>, secret_number);
  
      <span class="ot">println!</span>(<span class="st">&quot;Пожалуйста, введите предположение.&quot;</span>);
  
      <span class="kw">let</span> <span class="kw">mut</span> guess = String::new();
  
      io::stdin().read_line(&amp;<span class="kw">mut</span> guess)
          .ok()
          .expect(<span class="st">&quot;Не удалось прочитать строку&quot;</span>);
  
      <span class="kw">let</span> guess: <span class="kw">u32</span> = guess.trim().parse()
          .ok()
          .expect(<span class="st">&quot;Пожалуйста, введите число!&quot;</span>);
  
      <span class="ot">println!</span>(<span class="st">&quot;Ваша попытка: {}&quot;</span>, guess);
  
      <span class="kw">match</span> guess.cmp(&amp;secret_number) {
          Ordering::Less    =&gt; <span class="ot">println!</span>(<span class="st">&quot;Слишком маленькое!&quot;</span>),
          Ordering::Greater =&gt; <span class="ot">println!</span>(<span class="st">&quot;Слишком большое!&quot;</span>),
          Ordering::Equal   =&gt; <span class="ot">println!</span>(<span class="st">&quot;Вы выиграли!&quot;</span>),
      }
  }</code></pre>
  <p>Вот строки, которые мы добавили:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">    <span class="kw">let</span> guess: <span class="kw">u32</span> = guess.trim().parse()
          .ok()
          .expect(<span class="st">&quot;Пожалуйста, введите число!&quot;</span>);</code></pre>
  <p>Подождите минутку, у нас ведь уже есть <code>guess</code>? Rust позволил нам «затенить» (скрыть) предыдущее <code>guess</code> новым. Это часто используется в подобных случаях, когда <code>guess</code> изначально бывает типа <code>String</code>, но нам требуется преобразовать её в <code>u32</code>. Затенение позволяет нам переиспользовать имя <code>guess</code>, а не создавать для каждого типа новое уникальное имя, такое как <code>guess_str</code> и <code>guess</code> или какое-нибудь другое.</p>
  <p>Мы связали <code>guess</code> с выражением, которое похоже на то, что мы писали ранее:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">guess.trim().parse()</code></pre>
  <p>За которым следует вызов <code>ok().expect()</code>. Здесь <code>guess</code> ссылается на старый <code>guess</code>, который ещё является строкой, которую мы получили с ввода. Метод <code>trim()</code> у типа <code>String</code> удаляет всё пустое пространство с начала и конца нашей строки. Это важно, ведь для нормальной работы <code>read_line()</code> нам необходимо нажать <code>Enter</code> после окончания ввода. Это значит, что если мы набрали <code>5</code> и нажали <code>Enter</code>, <code>guess</code> выглядит следующим образом: <code>5\n</code>. <code>\n</code> обозначает «новую строку» (newline) — значение клавиши <code>Enter</code>. <code>trim()</code> удалит его и оставит только <code>5</code>. <a href="http://doc.rust-lang.org/std/primitive.str.html#method.parse">Метод <code>parse()</code></a>, применяемый к строке, преобразует её в число. Он может анализировать различные числа, но мы можем указать Rust какой именно тип нам нужен. Поэтому мы указали <code>let guess: u32</code>. Двоеточие <code>:</code>, идущее после <code>guess</code>, говорит Rust, что мы указали тип значения. <code>u32</code> - 32-битное беззнаковое целое число. У Rust есть <a href="#numeric-types">несколько встроенных числовых типов</a>, но мы выбрали именно <code>u32</code>. Это достаточно хороший тип, чтобы хранить небольшие положительные числа.</p>
  <p>Как и <code>read_line()</code>, вызов <code>parse()</code> может вызвать проблемы. Что, если наша строка будет содержать <code>A👍%</code>? Мы не сможем преобразовать её в число. Как и в случае с <code>read_line()</code>, мы будем использовать методы <code>ok()</code> и <code>expect()</code> на случай, если <code>parse()</code> не сможет преобразовать строку.</p>
  <p>Давайте запустим нашу программу!</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> run
     <span class="kw">Compiling</span> guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
       <span class="kw">Running</span> <span class="kw">`target/guessing_game`</span>
  У<span class="kw">гадайте</span> чис<span class="kw">ло</span>!
  З<span class="kw">агада</span>нн<span class="kw">о</span>е чис<span class="kw">ло</span>: <span class="kw">58</span>
  П<span class="kw">ожалуйста</span>, введите предп<span class="kw">оложе</span>ние.
    <span class="kw">76</span>
  В<span class="kw">аша</span> п<span class="kw">о</span>пытка: 76
  Сл<span class="kw">иш</span>к<span class="kw">ом</span> <span class="kw">большо</span>е!</code></pre>
  <p>Замечательно! Вы можете видеть, что мы добавили пробел перед нашим числом, но программа поняла, что мы хотели сказать <code>76</code>. Запустим программу ещё несколько раз и проверим, что загадывание числа работает.</p>
  <p>Теперь большая часть нашей игры работает, но мы можем сделать только одно предположение. Давайте изменим это, добавив циклы!</p>
  </section>
  <section id="зацикливание" class="level3">
  <h3>Зацикливание</h3>
  <p>Ключевое слово <code>loop</code> создаёт бесконечный цикл. Давайте добавим его:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> crate rand;
  
  <span class="kw">use</span> std::io;
  <span class="kw">use</span> std::cmp::Ordering;
  <span class="kw">use</span> rand::Rng;
  
  <span class="kw">fn</span> main() {
      <span class="ot">println!</span>(<span class="st">&quot;Угадайте число!&quot;</span>);
  
      <span class="kw">let</span> secret_number = rand::thread_rng().gen_range(<span class="dv">1</span>, <span class="dv">101</span>);
  
      <span class="ot">println!</span>(<span class="st">&quot;Загаданное число: {}&quot;</span>, secret_number);
  
      <span class="kw">loop</span> {
          <span class="ot">println!</span>(<span class="st">&quot;Пожалуйста, введите предположение.&quot;</span>);
  
          <span class="kw">let</span> <span class="kw">mut</span> guess = String::new();
  
          io::stdin().read_line(&amp;<span class="kw">mut</span> guess)
              .ok()
              .expect(<span class="st">&quot;Не удалось прочитать строку&quot;</span>);
  
          <span class="kw">let</span> guess: <span class="kw">u32</span> = guess.trim().parse()
              .ok()
              .expect(<span class="st">&quot;Пожалуйста, введите число!&quot;</span>);
  
          <span class="ot">println!</span>(<span class="st">&quot;Ваша попытка: {}&quot;</span>, guess);
  
          <span class="kw">match</span> guess.cmp(&amp;secret_number) {
              Ordering::Less    =&gt; <span class="ot">println!</span>(<span class="st">&quot;Слишком маленькое!&quot;</span>),
              Ordering::Greater =&gt; <span class="ot">println!</span>(<span class="st">&quot;Слишком большое!&quot;</span>),
              Ordering::Equal   =&gt; <span class="ot">println!</span>(<span class="st">&quot;Вы выиграли!&quot;</span>),
          }
      }
  }</code></pre>
  <p>И посмотрим на работу приложения. Но подождите, мы же добавили бесконечный цикл? Всё верно. Помните что мы говорили о <code>parse()</code>? Если мы введём не числовой ответ, мы просто выйдем из программы. Посмотрите:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> run
     <span class="kw">Compiling</span> guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
       <span class="kw">Running</span> <span class="kw">`target/guessing_game`</span>
  У<span class="kw">гадайте</span> чис<span class="kw">ло</span>!
  З<span class="kw">агада</span>нн<span class="kw">о</span>е чис<span class="kw">ло</span>: <span class="kw">59</span>
  П<span class="kw">ожалуйста</span>, введите предп<span class="kw">оложе</span>ние.
  <span class="kw">45</span>
  В<span class="kw">аша</span> п<span class="kw">о</span>пытка: 45
  Сл<span class="kw">иш</span>к<span class="kw">ом</span> <span class="kw">м</span>а<span class="kw">ле</span>ньк<span class="kw">о</span>е!
  П<span class="kw">ожалуйста</span>, введите предп<span class="kw">оложе</span>ние.
  <span class="kw">60</span>
  В<span class="kw">аша</span> п<span class="kw">о</span>пытка: 60
  Сл<span class="kw">иш</span>к<span class="kw">ом</span> <span class="kw">большо</span>е!
  П<span class="kw">ожалуйста</span>, введите предп<span class="kw">оложе</span>ние.
  <span class="kw">59</span>
  В<span class="kw">аша</span> п<span class="kw">о</span>пытка: 59
  В<span class="kw">ы</span> выигра<span class="kw">ли</span>!
  П<span class="kw">ожалуйста</span>, введите предп<span class="kw">оложе</span>ние.
  <span class="kw">quit</span>
  <span class="kw">thread</span> <span class="st">'&lt;main&gt;'</span> panicked at <span class="st">'Пожалуйста, введите число!'</span></code></pre>
  <p>Ха! Если мы введём <code>quit</code>, то действительно выйдем из программы. Как и при вводе любого другого не числового значения. Что ж, это, мягко говоря, не очень хорошо. Для начала, давайте сделаем выход из программы, если мы выиграли игру:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> crate rand;
  
  <span class="kw">use</span> std::io;
  <span class="kw">use</span> std::cmp::Ordering;
  <span class="kw">use</span> rand::Rng;
  
  <span class="kw">fn</span> main() {
      <span class="ot">println!</span>(<span class="st">&quot;Угадайте число!&quot;</span>);
  
      <span class="kw">let</span> secret_number = rand::thread_rng().gen_range(<span class="dv">1</span>, <span class="dv">101</span>);
  
      <span class="ot">println!</span>(<span class="st">&quot;Загаданное число: {}&quot;</span>, secret_number);
  
      <span class="kw">loop</span> {
          <span class="ot">println!</span>(<span class="st">&quot;Пожалуйста, введите предположение.&quot;</span>);
  
          <span class="kw">let</span> <span class="kw">mut</span> guess = String::new();
  
          io::stdin().read_line(&amp;<span class="kw">mut</span> guess)
              .ok()
              .expect(<span class="st">&quot;Не удалось прочитать строку&quot;</span>);
  
          <span class="kw">let</span> guess: <span class="kw">u32</span> = guess.trim().parse()
              .ok()
              .expect(<span class="st">&quot;Пожалуйста, введите число!&quot;</span>);
  
          <span class="ot">println!</span>(<span class="st">&quot;Ваша попытка: {}&quot;</span>, guess);
  
          <span class="kw">match</span> guess.cmp(&amp;secret_number) {
              Ordering::Less    =&gt; <span class="ot">println!</span>(<span class="st">&quot;Слишком маленькое!&quot;</span>),
              Ordering::Greater =&gt; <span class="ot">println!</span>(<span class="st">&quot;Слишком большое!&quot;</span>),
              Ordering::Equal   =&gt; {
                  <span class="ot">println!</span>(<span class="st">&quot;Вы выиграли!&quot;</span>);
                  <span class="kw">break</span>;
              }
          }
      }
  }</code></pre>
  <p>С добавлением строки <code>break</code> после вывода <code>Вы выиграли!</code>, мы получили возможность выхода из цикла, когда мы угадали загаданное число. Выход из цикла также означает и завершение нашей программы, так как это последнее, что есть в <code>main()</code>. Нам надо сделать ещё одно улучшение — при любом не числовом вводе, мы не должны выходить из программы, мы просто должны проигнорировать ввод. Мы можем сделать это следующим образом:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> crate rand;
  
  <span class="kw">use</span> std::io;
  <span class="kw">use</span> std::cmp::Ordering;
  <span class="kw">use</span> rand::Rng;
  
  <span class="kw">fn</span> main() {
      <span class="ot">println!</span>(<span class="st">&quot;Угадайте число!&quot;</span>);
  
      <span class="kw">let</span> secret_number = rand::thread_rng().gen_range(<span class="dv">1</span>, <span class="dv">101</span>);
  
      <span class="ot">println!</span>(<span class="st">&quot;Загаданное число: {}&quot;</span>, secret_number);
  
      <span class="kw">loop</span> {
          <span class="ot">println!</span>(<span class="st">&quot;Пожалуйста, введите предположение.&quot;</span>);
  
          <span class="kw">let</span> <span class="kw">mut</span> guess = String::new();
  
          io::stdin().read_line(&amp;<span class="kw">mut</span> guess)
              .ok()
              .expect(<span class="st">&quot;Не удалось прочитать строку&quot;</span>);
  
          <span class="kw">let</span> guess: <span class="kw">u32</span> = <span class="kw">match</span> guess.trim().parse() {
              <span class="kw">Ok</span>(num) =&gt; num,
              <span class="kw">Err</span>(_) =&gt; <span class="kw">continue</span>,
          };
  
          <span class="ot">println!</span>(<span class="st">&quot;Ваша попытка: {}&quot;</span>, guess);
  
          <span class="kw">match</span> guess.cmp(&amp;secret_number) {
              Ordering::Less    =&gt; <span class="ot">println!</span>(<span class="st">&quot;Слишком маленькое!&quot;</span>),
              Ordering::Greater =&gt; <span class="ot">println!</span>(<span class="st">&quot;Слишком большое!&quot;</span>),
              Ordering::Equal   =&gt; {
                  <span class="ot">println!</span>(<span class="st">&quot;Вы выиграли!&quot;</span>);
                  <span class="kw">break</span>;
              }
          }
      }
  }</code></pre>
  <p>Это строка, которую мы изменили:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> guess: <span class="kw">u32</span> = <span class="kw">match</span> guess.trim().parse() {
      <span class="kw">Ok</span>(num) =&gt; num,
      <span class="kw">Err</span>(_) =&gt; <span class="kw">continue</span>,
  };</code></pre>
  <p>Здесь показано, как мы можем перейти от «сбоя при ошибке» к «обработке ошибки» заменив <code>ok().expect()</code> на инструкцию <code>match</code>. <code>Result</code>, возвращённый функцией <code>parse()</code>, как и <code>Ordering</code>, является перечислением. Однако в данном случае каждый из вариантов имеет некоторые ассоциированные с ним данные: <code>Ok</code> — успех, <code>Err</code> — ошибку. У каждого есть некоторая дополнительная информация: преобразованное число, либо тип ошибки. Здесь мы проверили значение результата работы <code>parse()</code> при помощи <code>match</code>. В случае, если результат равен <code>Ok</code>, то <code>match</code> привяжет внутреннее значение результата (<code>Ok(num)</code>) к имени <code>num</code> и вернёт в привязку <code>guess</code>. Когда происходит ошибка (Err), нам не важно, какая именно это ошибка, поэтому мы используем вместо имени _. Так мы проигнорируем ошибку и вызовем <code>continue</code>, который отправит нас на следующую итерацию цикла.</p>
  <p>Теперь всё должно быть нормально! Давайте посмотрим:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> run
     <span class="kw">Compiling</span> guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
       <span class="kw">Running</span> <span class="kw">`target/guessing_game`</span>
  У<span class="kw">гадайте</span> чис<span class="kw">ло</span>!
  З<span class="kw">агада</span>нн<span class="kw">о</span>е чис<span class="kw">ло</span>: <span class="kw">61</span>
  П<span class="kw">ожалуйста</span>, введите предп<span class="kw">оложе</span>ние.
  <span class="kw">10</span>
  В<span class="kw">аша</span> п<span class="kw">о</span>пытка: 10
  Сл<span class="kw">иш</span>к<span class="kw">ом</span> <span class="kw">м</span>а<span class="kw">ле</span>ньк<span class="kw">о</span>е!
  П<span class="kw">ожалуйста</span>, введите предп<span class="kw">оложе</span>ние.
  <span class="kw">99</span>
  В<span class="kw">аша</span> п<span class="kw">о</span>пытка: 99
  Сл<span class="kw">иш</span>к<span class="kw">ом</span> <span class="kw">большо</span>е!
  П<span class="kw">ожалуйста</span>, введите предп<span class="kw">оложе</span>ние.
  <span class="kw">foo</span>
  П<span class="kw">ожалуйста</span>, введите предп<span class="kw">оложе</span>ние.
  <span class="kw">61</span>
  В<span class="kw">аша</span> п<span class="kw">о</span>пытка: 61
  В<span class="kw">ы</span> выигра<span class="kw">ли</span>!</code></pre>
  <p>Замечательно! Если мы ещё чуть-чуть подкрутим нашу программу, игра будет готова. Догадываетесь, что нужно поменять? Всё правильно, мы не должны выводить наше секретное число. Знание этого числа хорошо для тестирования, но оно портит всю игру. Так выглядит окончательный вариант нашего кода:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> crate rand;
  
  <span class="kw">use</span> std::io;
  <span class="kw">use</span> std::cmp::Ordering;
  <span class="kw">use</span> rand::Rng;
  
  <span class="kw">fn</span> main() {
      <span class="ot">println!</span>(<span class="st">&quot;Угадайте число!&quot;</span>);
  
      <span class="kw">let</span> secret_number = rand::thread_rng().gen_range(<span class="dv">1</span>, <span class="dv">101</span>);
  
      <span class="kw">loop</span> {
          <span class="ot">println!</span>(<span class="st">&quot;Пожалуйста, введите предположение.&quot;</span>);
  
          <span class="kw">let</span> <span class="kw">mut</span> guess = String::new();
  
          io::stdin().read_line(&amp;<span class="kw">mut</span> guess)
              .ok()
              .expect(<span class="st">&quot;Не удалось прочитать строку&quot;</span>);
  
          <span class="kw">let</span> guess: <span class="kw">u32</span> = <span class="kw">match</span> guess.trim().parse() {
              <span class="kw">Ok</span>(num) =&gt; num,
              <span class="kw">Err</span>(_) =&gt; <span class="kw">continue</span>,
          };
  
          <span class="ot">println!</span>(<span class="st">&quot;Ваша попытка: {}&quot;</span>, guess);
  
          <span class="kw">match</span> guess.cmp(&amp;secret_number) {
              Ordering::Less    =&gt; <span class="ot">println!</span>(<span class="st">&quot;Слишком маленькое!&quot;</span>),
              Ordering::Greater =&gt; <span class="ot">println!</span>(<span class="st">&quot;Слишком большое!&quot;</span>),
              Ordering::Equal   =&gt; {
                  <span class="ot">println!</span>(<span class="st">&quot;Вы выиграли!&quot;</span>);
                  <span class="kw">break</span>;
              }
          }
      }
  }</code></pre>
  </section>
  <section id="готово" class="level3">
  <h3>Готово!</h3>
  <p>Вы сделали «Угадайку»! Поздравляем!</p>
  <p>Этот первый проект показал вам следующее: <code>let</code>, <code>match</code>, методы, привязанные функции, использование внешних контейнеров и многое другое. Наш следующий проект покажет ещё больше.</p>
  </section>
  </section>
  <section id="sec--dining-philosophers" class="level2">
  <h2>Обедающие философы</h2>
  <p>Для нашего второго проекта мы выбрали классическую задачу с параллелизмом. Она называется «Обедающие философы». Задача была сформулирована в 1965 году Эдсгером Дейкстрой, но мы будем использовать версию задачи, <a href="http://www.usingcsp.com/cspbook.pdf">адаптированную</a> в 1985 году Ричардом Хоаром.</p>
  <blockquote>
  <p>В древние времена богатые филантропы пригласили погостить пятерых выдающихся философов. Им выделили каждому по комнате, в которой они могли заниматься своей профессиональной деятельностью — мышлением. Также была общая столовая, где стоял большой круглый стол, а вокруг него пять стульев. Каждый стул имел табличку с именем философа, который должен был сидеть на нем. Слева от каждого философа лежала золотая вилка, а в центре стола стояла большая миска со спагетти, которая постоянно пополнялась. Как подобает философам, они большую часть своего времени проводили в раздумьях. Но однажды они почувствовали голод и отправились в столовую. Каждый сел на свой стул, взял по вилке и воткнул её в миску со спагетти. Но сущность запутанных спагетти такова, что необходима вторая вилка, чтобы отправлять спагетти в рот. То есть философу требовалась еще и вилка справа от него. Философы положили свои вилки и встали из-за стола, продолжая думать. Ведь вилка может быть использована только одним философом одновременно. Если другой философ захочет её взять, то ему придется ждать когда она освободится.</p>
  </blockquote>
  <p>Эта классическая задача показывает различные элементы параллелизма. Сложность реализации задачи состоит в том, что простая реализация может зайти в безвыходное состояние. Давайте рассмотрим простой пример решения этой проблемы:</p>
  <ol type="1">
  <li>Философ берет вилку в свою левую руку.</li>
  <li>Затем берет вилку в свою правую руку.</li>
  <li>Ест.</li>
  <li>Кладет вилки на место.</li>
  </ol>
  <p>Теперь представим это как последовательность действий философов:</p>
  <ol type="1">
  <li>Философ 1 начинает выполнять алгоритм, берет вилку в левую руку.</li>
  <li>Философ 2 начинает выполнять алгоритм, берет вилку в левую руку.</li>
  <li>Философ 3 начинает выполнять алгоритм, берет вилку в левую руку.</li>
  <li>Философ 4 начинает выполнять алгоритм, берет вилку в левую руку.</li>
  <li>Философ 5 начинает выполнять алгоритм, берет вилку в левую руку.</li>
  <li>…? Все вилки заняты и никто не может начать есть! Безвыходное состояние.</li>
  </ol>
  <p>Есть различные пути решения этой задачи. Мы в этом руководстве покажем свое решение. Сначала давайте начнем с моделирования задачи. Начнем с философов:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Philosopher {
      name: String,
  }
  
  <span class="kw">impl</span> Philosopher {
      <span class="kw">fn</span> new(name: &amp;<span class="kw">str</span>) -&gt; Philosopher {
          Philosopher {
              name: name.to_string(),
          }
      }
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> p1 = Philosopher::new(<span class="st">&quot;Джудит Батлер&quot;</span>);
      <span class="kw">let</span> p2 = Philosopher::new(<span class="st">&quot;Рая Дунаевская&quot;</span>);
      <span class="kw">let</span> p3 = Philosopher::new(<span class="st">&quot;Зарубина Наталья&quot;</span>);
      <span class="kw">let</span> p4 = Philosopher::new(<span class="st">&quot;Эмма Гольдман&quot;</span>);
      <span class="kw">let</span> p5 = Philosopher::new(<span class="st">&quot;Анна Шмидт&quot;</span>);
  }</code></pre>
  <p>Здесь мы создаем <a href="#sec--structs"><code>struct</code></a>, представляющую философа. На данный момент нам нужно всего лишь имя. Мы выбрали тип <a href="#sec--strings"><code>String</code></a>, а не <code>&amp;str</code> для хранения имени. Обычно проще работать с типом, владеющим данными, чем с типом, использующим ссылки.</p>
  <p>Продолжим:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">impl</span> Philosopher {
      <span class="kw">fn</span> new(name: &amp;<span class="kw">str</span>) -&gt; Philosopher {
          Philosopher {
              name: name.to_string(),
          }
      }
  }</code></pre>
  <p>Этот блок <code>impl</code> позволяет объявить что-либо для структуры <code>Philosopher</code>. В нашем случае мы объявляем «статическую функцию» <code>new</code>. Первая строка этой функции выглядит так:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> new(name: &amp;<span class="kw">str</span>) -&gt; Philosopher {</code></pre>
  <p>Она принимает один аргумент, <code>name</code>, типа <code>&amp;str</code>. Это ссылка на другую строку. Она возвращает новый экземпляр нашей структуры <code>Philosopher</code>.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">Philosopher {
      name: name.to_string(),
  }</code></pre>
  <p>Этот код создаёт новый экземпляр <code>Philosopher</code> и присваивает его полю <code>name</code> значение переданного аргумента <code>name</code>. Но используется не сам аргумент, а результат вызова его метода <code>.to_string()</code>. Этот вызов создаёт копию строки, на которую указывает наш <code>&amp;str</code>, и возвращает новый экземпляр <code>String</code>, который и будет присвоен полю <code>name</code> структуры <code>Philosopher</code>.</p>
  <p>Почему бы сразу не передавать строку типа <code>String</code> напрямую? Так легче ее вызывать. Если бы мы принимали тип <code>String</code>, а тот, кто вызывает функцию, имел бы ссылку на строку, <code>&amp;str</code>, то ему пришлось бы приводить ее к типу <code>String</code> перед каждым вызовом. Это уменьшит гибкость кода, и мы будем вынуждены <em>каждый раз</em> создавать копию строки. Для этой небольшой программы это не очень важно, так как мы знаем, что будем использовать только короткие строки.</p>
  <p>И последнее на что следует обратить внимание: мы просто объявляем структуру <code>Philosopher</code> и кажется, что ничего больше не делаем. Rust — это язык программирования, «ориентированный на выражения», что означает, что каждое выражение возвращает значение. Это верно и для функций, у которых автоматически возвращается последнее выражение. Так как в нашем примере в последнем выражении функции мы создаем структуру <code>Philosopher</code>, то она и будет возвращена функцией.</p>
  <p>Имя функции <code>new()</code> не регламентируется Rust. Это просто соглашение об именовании функций, которые возвращают новые экземпляры структур. Давайте снова посмотрим на функцию <code>main()</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="kw">let</span> p1 = Philosopher::new(<span class="st">&quot;Джудит Батлер&quot;</span>);
      <span class="kw">let</span> p2 = Philosopher::new(<span class="st">&quot;Рая Дунаевская&quot;</span>);
      <span class="kw">let</span> p3 = Philosopher::new(<span class="st">&quot;Зарубина Наталья&quot;</span>);
      <span class="kw">let</span> p4 = Philosopher::new(<span class="st">&quot;Эмма Гольдман&quot;</span>);
      <span class="kw">let</span> p5 = Philosopher::new(<span class="st">&quot;Анна Шмидт&quot;</span>);
  }</code></pre>
  <p>Здесь мы связываем пять имен переменных с пятью новыми философами. Здесь указаны имена некоторых известных философов, но вы можете указать любые другие. Если бы мы <em>не объявили</em> свою реализацию функции <code>new()</code>, то наш код выглядел бы так:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="kw">let</span> p1 = Philosopher { name: <span class="st">&quot;Джудит Батлер&quot;</span>.to_string() };
      <span class="kw">let</span> p2 = Philosopher { name: <span class="st">&quot;Рая Дунаевская&quot;</span>.to_string() };
      <span class="kw">let</span> p3 = Philosopher { name: <span class="st">&quot;Зарубина Наталья&quot;</span>.to_string() };
      <span class="kw">let</span> p4 = Philosopher { name: <span class="st">&quot;Эмма Гольдман&quot;</span>.to_string() };
      <span class="kw">let</span> p5 = Philosopher { name: <span class="st">&quot;Анна Шмидт&quot;</span>.to_string() };
  }</code></pre>
  <p>Этот код выглядит не слишком изящно. Использование статической функции <code>new</code> имеет и другие преимущества, но даже в этом простом случае, её использование было оправдано.</p>
  <p>Теперь у нас уже есть каркас программы, и можно заняться решением задачи с обедающими философами. Начнем с конца: сделаем так, чтобы философ сообщал нам, когда он закончит есть. Для этого потребуется метод, сообщающий нам об окончании приема пищи, и цикл, запускающий этот метод для каждого философа.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Philosopher {
      name: String,
  }   
  
  <span class="kw">impl</span> Philosopher { 
      <span class="kw">fn</span> new(name: &amp;<span class="kw">str</span>) -&gt; Philosopher {
          Philosopher {
              name: name.to_string(),
          }
      }
      
      <span class="kw">fn</span> eat(&amp;<span class="kw">self</span>) {
          <span class="ot">println!</span>(<span class="st">&quot;{} закончила есть.&quot;</span>, <span class="kw">self</span>.name);
      }
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> philosophers = <span class="ot">vec!</span>[
          Philosopher::new(<span class="st">&quot;Джудит Батлер&quot;</span>),
          Philosopher::new(<span class="st">&quot;Рая Дунаевская&quot;</span>),
          Philosopher::new(<span class="st">&quot;Зарубина Наталья&quot;</span>),
          Philosopher::new(<span class="st">&quot;Эмма Гольдман&quot;</span>),
          Philosopher::new(<span class="st">&quot;Анна Шмидт&quot;</span>),
      ];
  
      <span class="kw">for</span> p in &amp;philosophers {
          p.eat();
      }
  }</code></pre>
  <p>Давайте сначала рассмотрим функцию <code>main()</code>. Вместо того чтобы создавать пять отдельных связанных имен для философов, мы создаем для них <code>Vec&lt;T&gt;</code>. <code>Vec&lt;T&gt;</code> называют «вектор», он является расширяемой версией массива. Затем в цикле <a href="#for"><code>for</code></a> мы перебираем вектор, получая ссылку на очередного философа на каждой итерации.</p>
  <p>В теле цикла мы вызываем метод <code>p.eat()</code>, который объявлен выше:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> eat(&amp;<span class="kw">self</span>) {
      <span class="ot">println!</span>(<span class="st">&quot;{} закончила есть.&quot;</span>, <span class="kw">self</span>.name);
  }</code></pre>
  <p>В Rust методы явно получают параметр <code>self</code>. Вот почему <code>eat()</code> является методом, а <code>new</code> — статической функцией: <code>new()</code> не получает параметр <code>self</code>. Для нашей первой версии метода <code>eat()</code> мы выводим только имя философа и сообщение о том, что он закончил есть. Запустив эту программу вы получите:</p>
  <pre class="text"><code>Джудит Батлер закончила есть.
  Рая Дунаевская закончила есть.
  Зарубина Наталья закончила есть.
  Эмма Гольдман закончила есть.
  Анна Шмидт закончила есть.</code></pre>
  <p>Это было не сложно! Осталось чуть-чуть и приступим к самой задаче.</p>
  <p>Дальше нам нужно сделать так, чтобы философы не только заканчивали, но и начинали есть. Это новая версия программы:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::thread;
  
  <span class="kw">struct</span> Philosopher {
      name: String,
  }   
  
  <span class="kw">impl</span> Philosopher { 
      <span class="kw">fn</span> new(name: &amp;<span class="kw">str</span>) -&gt; Philosopher {
          Philosopher {
              name: name.to_string(),
          }
      }
      
      <span class="kw">fn</span> eat(&amp;<span class="kw">self</span>) {
          <span class="ot">println!</span>(<span class="st">&quot;{} начала есть.&quot;</span>, <span class="kw">self</span>.name);
  
          thread::sleep_ms(<span class="dv">1000</span>);
  
          <span class="ot">println!</span>(<span class="st">&quot;{} закончила есть.&quot;</span>, <span class="kw">self</span>.name);
      }
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> philosophers = <span class="ot">vec!</span>[
          Philosopher::new(<span class="st">&quot;Джудит Батлер&quot;</span>),
          Philosopher::new(<span class="st">&quot;Рая Дунаевская&quot;</span>),
          Philosopher::new(<span class="st">&quot;Зарубина Наталья&quot;</span>),
          Philosopher::new(<span class="st">&quot;Эмма Гольдман&quot;</span>),
          Philosopher::new(<span class="st">&quot;Анна Шмидт&quot;</span>),
      ];
  
      <span class="kw">for</span> p in &amp;philosophers {
          p.eat();
      }
  }</code></pre>
  <p>Появились некоторые небольшие изменения. Давайте посмотрим, что же изменилось:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::thread;</code></pre>
  <p>Конструкция <code>use</code> предоставляет доступ к области видимости модуля <code>thread</code> из стандартной библиотеки. Мы собираемся использовать этот модуль далее в коде, и поэтому нам нужно объявить о его использовании.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">    <span class="kw">fn</span> eat(&amp;<span class="kw">self</span>) {
          <span class="ot">println!</span>(<span class="st">&quot;{} начала есть.&quot;</span>, <span class="kw">self</span>.name);
  
          thread::sleep_ms(<span class="dv">1000</span>);
  
          <span class="ot">println!</span>(<span class="st">&quot;{} закончила есть.&quot;</span>, <span class="kw">self</span>.name);
      }</code></pre>
  <p>Здесь мы выводим на экран два сообщения и вызываем функцию <code>sleep_ms</code> между ними. Эта функция останавливает рабочий поток на 1000 миллисекунд, что симулирует процесс приема пищи философа.</p>
  <p>Если вы запустите программу теперь, то увидите, что каждый философ, по очереди, начинает есть, ест какое-то время и заканчивает есть:</p>
  <pre class="text"><code>Джудит Батлер начала есть.
  Джудит Батлер закончила есть.
  Рая Дунаевская начала есть.
  Рая Дунаевская закончила есть.
  Зарубина Наталья начала есть.
  Зарубина Наталья закончила есть.
  Эмма Гольдман начала есть.
  Эмма Гольдман закончила есть.
  Анна Шмидт начала есть.
  Анна Шмидт закончила есть.</code></pre>
  <p>Превосходно! Теперь у нас осталась только одна проблема: наши философы едят по очереди, а не одновременно, то есть мы пока не решили задачу параллелизма.</p>
  <p>Для того, чтобы наши философы начали есть одновременно, нам нужно внести некоторые изменения в код:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::thread;
  
  <span class="kw">struct</span> Philosopher {
      name: String,
  }   
  
  <span class="kw">impl</span> Philosopher { 
      <span class="kw">fn</span> new(name: &amp;<span class="kw">str</span>) -&gt; Philosopher {
          Philosopher {
              name: name.to_string(),
          }
      }
  
      <span class="kw">fn</span> eat(&amp;<span class="kw">self</span>) {
          <span class="ot">println!</span>(<span class="st">&quot;{} начала есть.&quot;</span>, <span class="kw">self</span>.name);
  
          thread::sleep_ms(<span class="dv">1000</span>);
  
          <span class="ot">println!</span>(<span class="st">&quot;{} закончила есть.&quot;</span>, <span class="kw">self</span>.name);
      }
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> philosophers = <span class="ot">vec!</span>[
          Philosopher::new(<span class="st">&quot;Джудит Батлер&quot;</span>),
          Philosopher::new(<span class="st">&quot;Рая Дунаевская&quot;</span>),
          Philosopher::new(<span class="st">&quot;Зарубина Наталья&quot;</span>),
          Philosopher::new(<span class="st">&quot;Эмма Гольдман&quot;</span>),
          Philosopher::new(<span class="st">&quot;Анна Шмидт&quot;</span>),
      ];
  
      <span class="kw">let</span> handles: Vec&lt;_&gt; = philosophers.into_iter().map(|p| {
          thread::spawn(move || {
              p.eat();
          })
      }).collect();
  
      <span class="kw">for</span> h in handles {
          h.join().unwrap();
      }
  }</code></pre>
  <p>Мы добавили еще один цикл в функцию <code>main()</code>. Теперь она выглядит так:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> handles: Vec&lt;_&gt; = philosophers.into_iter().map(|p| {
      thread::spawn(move || {
          p.eat();
      })
  }).collect();</code></pre>
  <p>Тут добавились трудные к пониманию пять строк кода. Давайте разбираться.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> handles: Vec&lt;_&gt; = </code></pre>
  <p>Объявляем новое связанное имя <code>handles</code>. Мы задали такое имя, потому что собираемся создать несколько потоков, в результате чего получим для них дескрипторы, с помощью которых сможем контролировать их выполнение. Здесь нам нужно явно указать тип, а зачем это необходимо, мы расскажем чуть позже. <code>_</code> - это заполнитель типа. Мы говорим компилятору «<code>handles</code> — это вектор, содержащий элементы, тип которых Rust должен вывести самостоятельно».</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">philosophers.into_iter().map(|p| {</code></pre>
  <p>Мы берем наш список философов и вызываем метод <code>into_iter()</code>. Этот метод создаёт итератор, который при каждой итерации забирает право владения на соответствующий элемент. Это нужно для передачи элемента вектора в поток. Мы берем этот итератор и вызываем метод <code>map</code>, который принимает замыкание в качестве аргумента и вызывает это замыкание для каждого из элементов итератора.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">    thread::spawn(move || {
          p.eat();
      })</code></pre>
  <p>Вот здесь происходит сам параллелизм. Функция <code>thread::spawn</code> принимает в качестве аргумента замыкание и исполняет это замыкание в новом потоке. Это замыкание дополнительно нуждается в указании ключевого слова <code>move</code>, которое сообщает, что это замыкание получает владение переменными, которые оно захватывает. В данном случае — переменной <code>p</code> функции <code>map</code>.</p>
  <p>Внутри потока мы всего лишь вызываем метод <code>eat()</code> переменной <code>p</code>. Также обратите внимание, что вызов <code>thread::spawn</code> не оканчивается точкой с запятой, что превращает его в выражение. Этот нюанс важен, так как возвращается правильное значение. Для получения более подробной информации, прочитайте главу <a href="functions.html#expressions-vs.-statements">Выражения и операторы</a>.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">}).collect();</code></pre>
  <p>По завершении мы получаем результат вызова <code>map</code> и собираем полученный результат в коллекцию с помощью метода <code>collect()</code>. Метод <code>collect()</code> создаёт коллекцию какого-то типа, и для того, чтобы Rust понял, коллекцию какого типа мы хотим получить, мы указали для <code>handle</code> тип принимаемого значения <code>Vec&lt;T&gt;</code>. Элементами коллекции будут возвращаемые из методов <code>thread::spawn</code> значения, которые являются дескрипторами этих потоков. Вот так!</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">for</span> h in handles {
      h.join().unwrap();
  }</code></pre>
  <p>В конце функции <code>main()</code> мы в цикле перебираем каждый дескриптор и вызываем для него метод <code>join()</code>, который блокирует дальнейшее исполнение основного потока, пока не завершится дочерний поток. Это позволяет нам быть уверенными, что потоки завершат работу до того как произойдет выход из программы.</p>
  <p>Если вы запустите эту программу, то вы увидите, что философы едят не дожидаясь своей очереди! У нас многопоточность!</p>
  <pre class="text"><code>Джудит Батлер начала есть.
  Рая Дунаевская начала есть.
  Зарубина Наталья начала есть.
  Эмма Гольдман начала есть.
  Анна Шмидт начала есть.
  Джудит Батлер закончила есть.
  Рая Дунаевская закончила есть.
  Зарубина Наталья закончила есть.
  Эмма Гольдман закончила есть.
  Анна Шмидт закончила есть.</code></pre>
  <p>Но как же быть с вилками? Их мы пока ещё не смоделировали.</p>
  <p>Давайте же начнем. Сначала сделаем новую структуру:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::sync::Mutex;
  
  <span class="kw">struct</span> Table {
      forks: Vec&lt;Mutex&lt;()&gt;&gt;,
  }</code></pre>
  <p>Структура <code>Table</code> содержит вектор мьютексов (<code>Mutex</code>). Мьютекс — способ управления доступом к данным для параллельно выполняющихся потоков: только один поток может получить доступ к данным в конкретный момент времени. Это именно то свойство, которое нужно для реализации наших вилок. В коде мы используем пустой кортеж, <code>()</code>, внутри мьютекса, так как не собираемся использовать это значение, а мьютекс используется только для организации доступа.</p>
  <p>Давайте изменим программу, используя структуру <code>Table</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::thread;
  <span class="kw">use</span> std::sync::{Mutex, Arc};
  
  <span class="kw">struct</span> Philosopher {
      name: String,
      left: usize,
      right: usize,
  }
  
  <span class="kw">impl</span> Philosopher {
      <span class="kw">fn</span> new(name: &amp;<span class="kw">str</span>, left: usize, right: usize) -&gt; Philosopher {
          Philosopher {
              name: name.to_string(),
              left: left,
              right: right,
          }
      }
  
      <span class="kw">fn</span> eat(&amp;<span class="kw">self</span>, table: &amp;Table) {
          <span class="kw">let</span> _left = table.forks[<span class="kw">self</span>.left].lock().unwrap();
          <span class="kw">let</span> _right = table.forks[<span class="kw">self</span>.right].lock().unwrap();
  
          <span class="ot">println!</span>(<span class="st">&quot;{} начала есть.&quot;</span>, <span class="kw">self</span>.name);
  
          thread::sleep_ms(<span class="dv">1000</span>);
  
          <span class="ot">println!</span>(<span class="st">&quot;{} закончила есть.&quot;</span>, <span class="kw">self</span>.name);
      }
  }
  
  <span class="kw">struct</span> Table {
      forks: Vec&lt;Mutex&lt;()&gt;&gt;,
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> table = Arc::new(Table { forks: <span class="ot">vec!</span>[
          Mutex::new(()),
          Mutex::new(()),
          Mutex::new(()),
          Mutex::new(()),
          Mutex::new(()),
      ]});
  
      <span class="kw">let</span> philosophers = <span class="ot">vec!</span>[
          Philosopher::new(<span class="st">&quot;Джудит Батлер&quot;</span>, <span class="dv">0</span>, <span class="dv">1</span>),
          Philosopher::new(<span class="st">&quot;Рая Дунаевская&quot;</span>, <span class="dv">1</span>, <span class="dv">2</span>),
          Philosopher::new(<span class="st">&quot;Зарубина Наталья&quot;</span>, <span class="dv">2</span>, <span class="dv">3</span>),
          Philosopher::new(<span class="st">&quot;Эмма Гольдман&quot;</span>, <span class="dv">3</span>, <span class="dv">4</span>),
          Philosopher::new(<span class="st">&quot;Анна Шмидт&quot;</span>, <span class="dv">0</span>, <span class="dv">4</span>),
      ];
  
      <span class="kw">let</span> handles: Vec&lt;_&gt; = philosophers.into_iter().map(|p| {
          <span class="kw">let</span> table = table.clone();
  
          thread::spawn(move || {
              p.eat(&amp;table);
          })
      }).collect();
  
      <span class="kw">for</span> h in handles {
          h.join().unwrap();
      }
  }</code></pre>
  <p>Много изменений! Однако, с этими изменениями мы получили корректно работающую программу. Приступим к рассмотрению:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::sync::{Mutex, Arc};</code></pre>
  <p>Нам далее понадобится структура <code>Arc&lt;T&gt;</code> из модуля стандартной библиотеки <code>std::sync</code>. Мы поговорим о ней чуть позже.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Philosopher {
      name: String,
      left: usize,
      right: usize,
  }</code></pre>
  <p>Нам понадобилось добавить еще два поля в нашу структуру <code>Philosopher</code>. Каждый философ должен иметь две вилки: одну — для левой руки, другую — для правой руки. Мы используем тип <code>usize</code> для идентификации каждой вилки. Мы используем его при создании философа, передавая идентификаторы двух вилок. Эти два значения будут использоваться полем <code>forks</code> структуры <code>Table</code>.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> new(name: &amp;<span class="kw">str</span>, left: usize, right: usize) -&gt; Philosopher {
      Philosopher {
          name: name.to_string(),
          left: left,
          right: right,
      }
  }</code></pre>
  <p>Мы используем функцию <code>new()</code> для задания значений <code>left</code> и <code>right</code>.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> eat(&amp;<span class="kw">self</span>, table: &amp;Table) {
      <span class="kw">let</span> _left = table.forks[<span class="kw">self</span>.left].lock().unwrap();
      <span class="kw">let</span> _right = table.forks[<span class="kw">self</span>.right].lock().unwrap();
  
      <span class="ot">println!</span>(<span class="st">&quot;{} начала есть.&quot;</span>, <span class="kw">self</span>.name);
  
      thread::sleep_ms(<span class="dv">1000</span>);
  
      <span class="ot">println!</span>(<span class="st">&quot;{} закончила есть.&quot;</span>, <span class="kw">self</span>.name);
  }</code></pre>
  <p>Здесь появились две новые строки. Мы также добавили один аргумент, <code>table</code>. Мы получаем доступ к списку вилок через структуру <code>Table</code>. Затем используем идентификаторы вилок <code>self.left</code> и <code>self.right</code> для получения доступа к вилке по определенному индексу. В результате чего мы получаем <code>Mutex</code>, который регулирует доступ к вилке, и вызываем для него метод <code>lock()</code>, блокируя доступ к вилке. Если в настоящее время доступ к вилке уже предоставлен кому-то еще, то мы будем блокированы, пока вилка не станет доступной.</p>
  <p>Вызов метода <code>lock()</code> может потерпеть неудачу, и если это случается, то мы аварийно завершаем работу программы. Может возникнуть ситуация, когда поток аварийно завершит свою работу, а мьютекс при этом останется заблокированным. Такой мьютекс называется «<a href="https://doc.rust-lang.org/stable/std/sync/struct.Mutex.html#poisoning">отравленным (poisoned)</a>». Но в нашем случае это не может произойти, потому как мы просто используем метод <code>unwrap()</code>.</p>
  <p>Результаты выполнения этих двух строк имеют имена <code>_left</code> и <code>_right</code> соответственно. Зачем мы используем знаки подчеркивания в начале имён? Это для того, чтобы сказать компилятору, что мы хотим получить значения, которые далее <em>не планируем использовать</em>. Таким образом Rust не будет выводить предупреждение о неиспользуемых именах.</p>
  <p>Когда же мьютекс будет освобождён? Это произойдет автоматически, когда <code>_left</code> и <code>_right</code> выйдут из области видимости, то есть по окончании работы функции.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">    <span class="kw">let</span> table = Arc::new(Table { forks: <span class="ot">vec!</span>[
          Mutex::new(()),
          Mutex::new(()),
          Mutex::new(()),
          Mutex::new(()),
          Mutex::new(()),
      ]});</code></pre>
  <p>Далее в <code>main()</code> мы создаем новый экземпляр структуры <code>Table</code> и оборачиваем его в <code>Arc&lt;T&gt;</code>. Это «атомарный счетчик ссылок» (atomic reference count). Он нужен для обеспечения доступа к нашей структуре <code>Table</code> из нескольких потоков. Когда он передается в новый поток, то счетчик увеличивается, а когда этот поток завершает работу, то счетчик уменьшается.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> philosophers = <span class="ot">vec!</span>[
      Philosopher::new(<span class="st">&quot;Джудит Батлер&quot;</span>, <span class="dv">0</span>, <span class="dv">1</span>),
      Philosopher::new(<span class="st">&quot;Рая Дунаевская&quot;</span>, <span class="dv">1</span>, <span class="dv">2</span>),
      Philosopher::new(<span class="st">&quot;Зарубина Наталья&quot;</span>, <span class="dv">2</span>, <span class="dv">3</span>),
      Philosopher::new(<span class="st">&quot;Эмма Гольдман&quot;</span>, <span class="dv">3</span>, <span class="dv">4</span>),
      Philosopher::new(<span class="st">&quot;Анна Шмидт&quot;</span>, <span class="dv">0</span>, <span class="dv">4</span>),
  ];</code></pre>
  <p>Мы добавили наши значения <code>left</code> и <code>right</code> при создании структуры <code>Philosopher</code>. Здесь есть <em>очень важная</em> деталь, на которую следует обратить внимание. Посмотрите на последнюю строку создания <code>Philosopher</code>. Конструктор Анны Шмидт должен был бы принимать в качестве аргументов значения <code>4</code> и <code>0</code>, но вместо этого он принимает значения <code>0</code> и <code>4</code>. Это помешает нашей программе попасть в безвыходное состояние, если каждый возьмет по одной вилке одновременно. Так что давайте представим, что один из философов у нас левша! Это один из способов решить данную проблему, и, на мой взгляд, самый простой.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> handles: Vec&lt;_&gt; = philosophers.into_iter().map(|p| {
      <span class="kw">let</span> table = table.clone();
  
      thread::spawn(move || {
          p.eat(&amp;table);
      })
  }).collect();</code></pre>
  <p>Внутри нашего цикла <code>map()</code>/<code>collect()</code> мы вызываем метод <code>table.clone()</code>. Метод <code>clone()</code> структуры <code>Arc&lt;T&gt;</code> клонирует значение и инкрементирует счетчик, который автоматически декрементируется, когда клонированное значение покинет область видимости. Это необходимо для того, чтобы мы знали, как много ссылок на <code>table</code> существуют в рамках наших потоков на данный момент времени. Если бы у нас не было подсчета ссылок, то мы бы не знали, как и когда освободить хранимое значение.</p>
  <p>Вы можете заметить, что здесь мы выполняем новое связывание с именем <code>table</code>, затеняя старое связанное имя <code>table</code>. Это позволяет нам не вводить новое уникальное имя.</p>
  <p>Теперь наша программа работает! Только два философа могут обедать одновременно. После запуска программы вы можете получить такой результат.</p>
  <pre class="text"><code>Рая Дунаевская начала есть.
  Эмма Гольдман начала есть.
  Эмма Гольдман закончила есть.
  Рая Дунаевская закончила есть.
  Джудит Батлер начала есть.
  Зарубина Наталья начала есть.
  Джудит Батлер закончила есть.
  Анна Шмидт начала есть.
  Зарубина Наталья закончила есть.
  Анна Шмидт закончила есть.</code></pre>
  <p>Поздравляем! Вы реализовали классическую задачу параллелизма на языке Rust.</p>
  </section>
  <section id="sec--rust-inside-other-languages" class="level2">
  <h2>Вызов кода на Rust из других языков</h2>
  <p>Для нашего третьего проекта мы собираемся выбрать что-то, что подчеркнёт одну из самых сильных сторон в Rust: фактическое отсутствие среды исполнения.</p>
  <p>По мере роста организации, программисты все больше полагаются на множество языков программирования. У каждого языка программирования есть свои сильные и слабые стороны, а знание нескольких языков позволяет использовать определенный язык там, где проявляется его сильные стороны, и использовать другой язык там, где первый не очень хорош.</p>
  <p>Существует несколько областей, где многие языки программирования слабы в плане производительности выполнения программ. Часто компромисс заключается в том, чтобы использовать более медленный язык, который взамен способствует повышению производительности программиста. Чтобы решить эту проблему, часть кода системы можно написать на C, а затем вызвать этот код, написанный на C, как если бы он был написан на языке высокого уровня. Это называется «интерфейс внешних функций» (foreign function interface), часто сокращается до FFI.</p>
  <p>Rust включает поддержку FFI в обоих направлениях: он легко может вызвать C код, и он так же легко, как и C код, может быть вызван <em>извне</em>. Rust сочетает в себе отсутствие сборщика мусора и низкие требования к среде исполнения, что делает Rust отличным кандидатом на роль вызываемого из других языков, когда нужны некоторые дополнительные возможности.</p>
  <p>В этой книге есть целая <a href="#sec--ffi">глава, посвящённая FFI</a> и его специфике, а в этой главе мы рассмотрим именно конкретный частный случай FFI, с тремя примерами, на Ruby, Python и JavaScript.</p>
  <section id="проблема" class="level3">
  <h3>Проблема</h3>
  <p>Есть много различных проектов, которые мы могли бы выбрать, но мы хотим подобрать такой пример, который продемонстрирует явное преимущество Rust над многими другими языками: сложные вычисления и многопоточность.</p>
  <p>Во многих языках числа размещаются в куче, а не в стеке. Это обеспечивает целостность поведения языка при работе с числами и с другими объектами. Особенно в языках, которые сосредотачиваются на объектно-ориентированном программировании и использовании сборщика мусора, по умолчанию память выделяется из кучи. Иногда, при оптимизации, для конкретных чисел память может выделяться в стеке, но вместо того, чтобы полагаться на работу оптимизации, мы можем захотеть убедиться в том, что мы используем примитивные типы чисел, а не какой-либо тип объекта.</p>
  <p>Во-вторых, многие языки имеют «глобальную блокировку интерпретатора» (global interpreter lock), которая ограничивает параллелизм во многих ситуациях. Это делается во имя безопасности, что оказывает положительный эффект, но это также и ограничивает объем работ, который может быть выполнен одновременно, что, в свою очередь, оказывает большой отрицательный эффект.</p>
  <p>Чтобы подчеркнуть эти два аспекта, мы собираемся создать небольшой проект, который в значительной степени их использует. Поскольку внимание в этом примере сфокусировано на встраивание Rust в другие языки, а не самой проблеме, мы будем использовать игрушечный пример:</p>
  <blockquote>
  <p>Запустить десять потоков. Внутри каждого потока считать от одного до пяти миллионов. После того как все десять потоков завершатся, напечатать “сделано!”.</p>
  </blockquote>
  <p>Мы выбрали пять миллионов руководствуясь тем, сколько времени занимает эта работа на современном компьютере. Вот пример этого кода на Ruby:</p>
  <pre class="sourceCode ruby"><code class="sourceCode ruby">threads = []
  
  <span class="dv">10</span>.times <span class="kw">do</span>
    threads &lt;&lt; <span class="dt">Thread</span>.new <span class="kw">do</span>
      count = <span class="dv">0</span>
  
      <span class="dv">5_000_000</span>.times <span class="kw">do</span>
        count += <span class="dv">1</span>
      <span class="kw">end</span>
    <span class="kw">end</span>
  <span class="kw">end</span>
  
  threads.each { |t| t.join }
  puts <span class="st">&quot;сделано!&quot;</span></code></pre>
  <p>Попробуйте запустить этот пример, и подберите число, которое обеспечит работу в течение нескольких секунд. В зависимости от аппаратного обеспечения компьютера, возможно, придется увеличить или уменьшить это число.</p>
  <p>На выбранной нами системе эта программа работает <code>2.156</code> секунд. И если мы воспользуемся какой-нибудь утилитой для мониторинга процессов (например, <code>top</code>), то увидим, что она использует только одно ядро. Это GIL делает свое дело.</p>
  <p>Хотя это и игрушечная программа, на ее примере можно продемонстрировать много проблем, аналогичных этой, характерных для реального мира. Для наших целей, долго крутящиеся занятые потоки представляют собой параллельные, требующие больших затрат, вычисления.</p>
  </section>
  <section id="библиотека-на-rust" class="level3">
  <h3>Библиотека на Rust</h3>
  <p>Давайте перепишем эту задачу на Rust. Во-первых, давайте сделаем новый проект с помощью Cargo:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> new embed
  $ <span class="kw">cd</span> embed</code></pre>
  <p>Эту программу легко переписать на Rust:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::thread;
  
  <span class="kw">fn</span> process() {
      <span class="kw">let</span> handles: Vec&lt;_&gt; = (<span class="dv">0.</span>.<span class="dv">10</span>).map(|_| {
          thread::spawn(|| {
              <span class="kw">let</span> <span class="kw">mut</span> x = <span class="dv">0</span>;
              <span class="kw">for</span> _ in (<span class="dv">0.</span>.<span class="dv">5_000_000</span>) {
                  x += <span class="dv">1</span>
              }
          x
          })
      }).collect();
  
      <span class="kw">for</span> h in handles {
          <span class="ot">println!</span>(<span class="st">&quot;Thread finished with count={}&quot;</span>,
          h.join().map_err(|_| <span class="st">&quot;Could not join a thread!&quot;</span>).unwrap());
      }
      <span class="ot">println!</span>(<span class="st">&quot;done!&quot;</span>);</code></pre>
  <p>Мы уже знакомы с частью этого кода из предыдущих примеров. Мы создаем десять потоков, собирая их в вектор <code>handles</code>. Внутри каждого потока мы осуществляем пять миллионов повторений в цикле, и прибавляем к <code>x</code> единицу каждый раз. Наконец, мы воссоединяем все потоки.</p>
  <p>Сейчас, однако, это просто библиотека Rust, которая не включает все необходимое для успешного вызова из другого языка. Если мы попытаемся подключить её к другому языку в том виде, в котором она сейчас, то это не будет работать. Нам нужно сделать два небольших изменения, чтобы исправить это. Первое, что мы должны сделать, это изменить начало нашего кода:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="ot">#[</span>no_mangle<span class="ot">]</span>
  <span class="kw">pub</span> <span class="kw">extern</span> <span class="kw">fn</span> process() {</code></pre>
  <p>Мы добавили новый атрибут, <code>no_mangle</code>. В процессе создания библиотеки Rust, в выходном скомпилированном файле происходит изменение имени функции. Причины этого выходят за рамки данного руководства, но для того, чтобы и другие языки знали, как вызвать функцию, мы должны не делать этого. Указанный атрибут выключает такое поведение.</p>
  <p>Другим изменением, которое мы добавили, является <code>pub extern</code>. <code>pub</code> означает, что эта функция может быть вызвана за пределами этого модуля, а <code>extern</code> говорит, что её возможно вызвать из С. Вот и все! Не так и много изменений.</p>
  <p>Второе, что мы должны сделать, это изменить настройки в <code>Cargo.toml</code>. Добавьте это в конец файла:</p>
  <pre class="toml"><code>[lib]
  name = &quot;embed&quot;
  crate-type = [&quot;dylib&quot;]</code></pre>
  <p>Это говорит Rust, что мы хотим скомпилировать нашу библиотеку в виде стандартной динамической библиотеки. По умолчанию, Rust компилирует в rlib, Rust- специфичный формат.</p>
  <p>Давайте теперь соберем проект:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> build --release
     <span class="kw">Compiling</span> embed v0.1.0 (file:///home/steve/src/embed)</code></pre>
  <p>Мы ввели команду <code>cargo build --release</code>, которая выполняет сборку с включенной оптимизацией. Мы хотим, чтобы код был как можно более быстрым! Вы можете найти собранную библиотеку в <code>target/release</code>:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">ls</span> target/release/
  <span class="kw">build</span>  deps  examples  libembed.so  native</code></pre>
  <p>Файл <code>libembed.so</code> — и есть наша динамическая библиотека (shared object). Мы можем использовать этот файл также как и любую другую динамическую библиотеку, написанную на C! Попутно следует отметить, это может быть <code>embed.dll</code> или <code>libembed.dylib</code>, в зависимости от платформы.</p>
  <p>Теперь, когда мы получили нашу собранную библиотеку Rust, давайте используем её из нашего кода на Ruby.</p>
  </section>
  <section id="ruby" class="level3">
  <h3>Ruby</h3>
  <p>Откройте файл <code>embed.rb</code> внутри нашего проекта, и сделайте следующее:</p>
  <pre class="sourceCode ruby"><code class="sourceCode ruby">require <span class="st">'ffi'</span>
  
  <span class="kw">module</span> <span class="dt">Hello</span>
    extend <span class="dt">FFI</span>::<span class="dt">Library</span>
    ffi_lib <span class="st">'target/release/libembed.so'</span>
    attach_function <span class="st">:process</span>, [], <span class="st">:void</span>
  <span class="kw">end</span>
  
  <span class="dt">Hello</span>.process
  
  puts <span class="st">'сделано!'</span></code></pre>
  <p>Прежде чем мы сможем запустить этот код, нам нужно установить пакет <code>ffi</code>:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">gem</span> install ffi <span class="co"># this may need sudo</span>
  <span class="kw">Fetching</span>: ffi-1.9.8.gem (100%)
  <span class="kw">Building</span> native extensions.  This could take a while...
  <span class="kw">Successfully</span> installed ffi-1.9.8
  <span class="kw">Parsing</span> documentation for ffi-1.9.8
  <span class="kw">Installing</span> ri documentation for ffi-1.9.8
  <span class="kw">Done</span> installing documentation for ffi after 0 seconds
  <span class="kw">1</span> gem installed</code></pre>
  <p>И, наконец, мы можем попробовать запустить его:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">ruby</span> embed.rb
  <span class="kw">сдела</span>н<span class="kw">о</span>!
  $</code></pre>
  <p>Ничего себе, это было быстро! На моей системе это заняло <code>0.086</code> секунд, а не две секунды как это было на чистом Ruby. Давайте разберем этот Ruby код:</p>
  <pre class="sourceCode ruby"><code class="sourceCode ruby">require <span class="st">'ffi'</span></code></pre>
  <p>Первый делом, нам надо объявить пакет <code>ffi</code>. Он предоставляет нам интерфейс для использования нашей библиотеки на Rust, как библиотеку на C.</p>
  <pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">module</span> <span class="dt">Hello</span>
    extend <span class="dt">FFI</span>::<span class="dt">Library</span>
    ffi_lib <span class="st">'target/release/libembed.so'</span></code></pre>
  <p>Автор пакета <code>ffi</code> рекомендует использовать модуль, чтобы ограничить область действия функции, которую мы импортировали из разделяемой библиотеки. Внутри мы указали <code>extend</code>, чтобы воспользоваться необходимым модулем <code>FFI::Library</code>, а затем вызвали <code>ffi_lib</code>, чтобы подгрузить нашу библиотеку. Мы просто передаем путь к библиотеке, который мы уже видели раньше, это <code>target/release/libembed.so</code>.</p>
  <pre class="sourceCode ruby"><code class="sourceCode ruby">attach_function <span class="st">:process</span>, [], <span class="st">:void</span></code></pre>
  <p>Метод <code>attach_function</code> предоставляется пакетом <code>FFI</code>. Здесь соединяются наша функция <code>process()</code>, написанная на Rust, и одноименная функция на Ruby. Так как <code>process()</code> не принимает аргументов, второй параметр является пустым массивом, и поскольку функция ничего не возвращает, мы передаем <code>:void</code> в качестве завершающего аргумента.</p>
  <pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="dt">Hello</span>.process</code></pre>
  <p>Здесь мы совершаем вызов нашей Rust функции. Сочетание нашего <code>module</code> и вызова к <code>attach_function</code> завершает подготовку. Это выглядит как функция Ruby, но на самом деле это Rust!</p>
  <pre class="sourceCode ruby"><code class="sourceCode ruby">puts <span class="st">'сделано!'</span></code></pre>
  <p>Наконец, в соответствие с нашими требованиями к проекту, мы пишем <code>сделано!</code> по окончанию работы программы.</p>
  <p>Вот и все! Как мы увидели, совместить два языка очень просто, и взамен мы получили большую производительность.</p>
  <p>Теперь давайте попробуем на Python!</p>
  </section>
  <section id="python" class="level3">
  <h3>Python</h3>
  <p>Создайте файл <code>embed.py</code> в этой директории и поместите в него следующее:</p>
  <pre class="sourceCode python"><code class="sourceCode python"><span class="ch">from</span> ctypes <span class="ch">import</span> cdll
  
  lib = cdll.LoadLibrary(<span class="st">&quot;target/release/libembed.so&quot;</span>)
  
  lib.process()
  
  <span class="dt">print</span>(<span class="st">&quot;сделано!&quot;</span>)</code></pre>
  <p>Довольно просто! Мы импортируем <code>cdll</code> из модуля <code>ctypes</code>. Затем вызваем <code>LoadLibrary</code>. И теперь мы можем вызвать <code>process()</code>.</p>
  <p>На моей системе это заняло <code>0.017</code> секунд. Быстро!</p>
  </section>
  <section id="node.js" class="level3">
  <h3>Node.js</h3>
  <p>Node — это не язык, но, в настоящее время, это доминирующая реализация исполнения JavaScript на сервере.</p>
  <p>Для того, чтобы сделать FFI в Node, нам сначала надо установить библиотеку:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">npm</span> install ffi</code></pre>
  <p>После установки, мы можем ей воспользоваться:</p>
  <pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> ffi = <span class="fu">require</span>(<span class="st">'ffi'</span>);
  
  <span class="kw">var</span> lib = <span class="ot">ffi</span>.<span class="fu">Library</span>(<span class="st">'target/release/libembed'</span>, {
    <span class="st">'process'</span>: [<span class="st">'void'</span>, []]
  });
  
  <span class="ot">lib</span>.<span class="fu">process</span>();
  
  <span class="ot">console</span>.<span class="fu">log</span>(<span class="st">&quot;сделано!&quot;</span>);</code></pre>
  <p>Пример больше похож на Ruby, чем на Python. Мы используем модуль <code>ffi</code>, чтобы получить доступ к <code>ffi.Library()</code>, который загружает нашу библиотеку. Нам нужно указать тип возвращаемого значения и типы аргументов функции: <code>void</code> для возвращаемого значения и пустой массив для указания отсутствия аргументов. После этого мы просто вызываем функцию и печатаем результат.</p>
  <p>На моей системе это заняло <code>0.092</code> секунды.</p>
  </section>
  <section id="заключение-1" class="level3">
  <h3>Заключение</h3>
  <p>Как вы можете видеть, основы, рассмотренные здесь, являются <em>очень</em> простыми. Конечно, мы могли бы сделать куда больше того, что мы здесь показали. Посмотрите главу <a href="#sec--ffi">FFI</a> для более подробной информации.</p>
  </section>
  </section>
  </section>
  <section id="sec--effective-rust" class="level1">
  <h1>Эффективное использование Rust</h1>
  <p>Итак, вы узнали, как писать код на Rust. Но есть разница между написанием <em>какого-то</em> кода на Rust и написанием <em>хорошего</em> кода на Rust.</p>
  <p>Этот раздел состоит из относительно самостоятельных уроков, которые показывают, как повысить уровень вашего кода на Rust. В нем представлены общие шаблоны и стандартные функции библиотеки. Главы в этом разделе могут быть прочитаны в любом порядке по вашему выбору.</p>
  <section id="sec--the-stack-and-the-heap" class="level2">
  <h2>Стек и куча</h2>
  <p>Как любой системный язык программирования, Rust работает на низком уровне. Если вы пришли из языка высокого уровня, то вам могут быть незнакомы некоторые аспекты системного программирования. Наиболее важными из них являются те, которые касаются работы с памятью в стеке и в куче. Если вы уже знакомы с тем, как в C-подобных языках используется выделение памяти в стеке, то эта глава освежит ваши знания. Если же вы еще не знакомы с этим, то в общих чертах узнаете об этом понятии, но с акцентом на Rust.</p>
  <section id="управление-памятью" class="level3">
  <h3>Управление памятью</h3>
  <p>Эти два термина касаются управления памятью. Стек и куча — это абстракции, которые помогают вам определить, когда требуется выделение и освобождение памяти.</p>
  <p>Вот высокоуровневое сравнение.</p>
  <p>Стек работает очень быстро; в Rust память выделяется в стеке по умолчанию. Выделение памяти в стеке является локальным по отношению к вызову функции, и имеет ограниченный размер. Куча, с другой стороны, работает медленнее, а выделение памяти в куче осуществляется в программе явно. Но такая память имеет теоретически неограниченный размер, и доступна глобально.</p>
  </section>
  <section id="стек" class="level3">
  <h3>Стек</h3>
  <p>Давайте поговорим о следующей программе на Rust:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="kw">let</span> x = <span class="dv">42</span>;
  }</code></pre>
  <p>Эта программа имеет одно связанное имя, <code>x</code>. Память для него необходимо где-то выделить. Rust по умолчанию «выделяет память в стеке», что означает, что переменные «помещаются в стеке». Что это значит?</p>
  <p>Когда функция вызывается, то выделяется некоторый объем памяти для всех её локальных переменных и некоторой дополнительной информации. Это называется «стековый кадр» (stack frame). В этом руководстве мы будем игнорировать эту дополнительную информацию, и будем рассматривать лишь локальные переменные, которые мы определяем. Таким образом, в этом случае, когда выполняется <code>main()</code>, мы выделяем одно 32-битное целое число в нашем кадре стека. Как вы можете видеть, это происходит автоматически — мы не должны писать какой-либо специальный код на Rust для этого.</p>
  <p>Когда функция завершается, её стековый кадр освобождается. Это происходит автоматически — для этого нам не надо предпринимать никаких действий.</p>
  <p>Вот и все, что касается этой простой программы. Главное, что здесь нужно понять — это что выделение в стеке очень, очень быстро. Поскольку все локальные переменные известны нам заранее, мы можем выделить память для них всех сразу. И так как они, как правило, одновременно выходят из области видимости, мы можем очень быстро освободить выделенную память.</p>
  <p>Недостатком является то, что мы не можем хранить необходимые значения дольше, чем в рамках одной функции.</p>
  <p>А ещё мы не говорили о том, что же означает название «стек». Для этого мы должны привести немного более сложный пример:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo() {
      <span class="kw">let</span> y = <span class="dv">5</span>;
      <span class="kw">let</span> z = <span class="dv">100</span>;
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> x = <span class="dv">42</span>;
  
      foo();
  }</code></pre>
  <p>Эта программа имеет в общей сложности три переменные: две в <code>foo()</code> и одну в <code>main()</code>. Так же как и раньше, когда вызывается <code>main()</code>, в её стековом кадре выделяется одно целое число. Но, прежде чем мы сможем показать, что происходит, когда вызывается <code>foo()</code>, мы должны визуализировать то, что происходит с памятью. Ваша операционная система представляет отображение памяти для вашей программы. Это довольно просто: огромный список адресов, от 0 до большого числа, представляющего количество оперативной памяти у вашего компьютера. Например, если у вас есть гигабайт оперативной памяти, то ваши адреса будут от <code>0</code> до <code>1 073 741 823</code>. Это число равно 2<sup>30</sup>, количеству байтов в гигабайте.</p>
  <p>Эта память вроде гигантского массива: адреса начинаются с нуля и продолжаются до конечного числа. Так вот схема нашего первого кадра стека:</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Адрес</th>
  <th style="text-align: left;">Имя</th>
  <th style="text-align: left;">Значение</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">42</td>
  </tr>
  </tbody>
  </table>
  <p>У нас есть переменная <code>x</code>, расположенная по адресу <code>0</code>, имеющая значение <code>42</code>.</p>
  <p>Когда вызывается <code>foo()</code>, выделяется новый стековый кадр:</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Адрес</th>
  <th style="text-align: left;">Имя</th>
  <th style="text-align: left;">Значение</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">2</td>
  <td style="text-align: left;">z</td>
  <td style="text-align: left;">100</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">y</td>
  <td style="text-align: left;">5</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">42</td>
  </tr>
  </tbody>
  </table>
  <p>Поскольку <code>0</code> было задействовано в первом кадре, для кадра <code>foo()</code> используются <code>1</code> и <code>2</code>. При дальнейших вызовах функций стек будет расти вверх.</p>
  <p>Здесь необходимо принять к сведению некоторые важные замечания. Адреса 0, 1 и 2 приведены исключительно в иллюстративных целях, и не имеют никакого отношения к фактическим адресам, которые компьютер будет использовать. В частности, набор адресов в действительности включает выравнивающие разделители, состоящие из некоторого числа байтов, которые отделяют каждый из адресов. Размер этого разделителя может даже превышать размер хранящегося значения.</p>
  <p>После того, как <code>foo()</code> завершается, её кадр будет освобожден:</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Адрес</th>
  <th style="text-align: left;">Имя</th>
  <th style="text-align: left;">Значение</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">42</td>
  </tr>
  </tbody>
  </table>
  <p>А потом, после <code>main()</code>, даже это последнее значение уходит. Легко!</p>
  <p>Это называется «стек» (по-русски, стопка), потому что он работает как стопка тарелок: первая тарелка, которую вы положили, будет последней тарелкой, которую вы возьмете обратно. По этой причине стек иногда называют очередью «последним пришел, первым вышел». Последнее значение, которое вы положили в стек, будет первым, которое вы получите из него.</p>
  <p>Давайте попробуем трёх-уровневый пример:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> bar() {
      <span class="kw">let</span> i = <span class="dv">6</span>;
  }
  
  <span class="kw">fn</span> foo() {
      <span class="kw">let</span> a = <span class="dv">5</span>;
      <span class="kw">let</span> b = <span class="dv">100</span>;
      <span class="kw">let</span> c = <span class="dv">1</span>;
  
      bar();
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> x = <span class="dv">42</span>;
  
      foo();
  }</code></pre>
  <p>Сначала вызывается <code>main()</code>:</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Адрес</th>
  <th style="text-align: left;">Имя</th>
  <th style="text-align: left;">Значение</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">42</td>
  </tr>
  </tbody>
  </table>
  <p>Затем из <code>main()</code> вызывается <code>foo()</code>:</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Адрес</th>
  <th style="text-align: left;">Имя</th>
  <th style="text-align: left;">Значение</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">3</td>
  <td style="text-align: left;">c</td>
  <td style="text-align: left;">1</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">2</td>
  <td style="text-align: left;">b</td>
  <td style="text-align: left;">100</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">a</td>
  <td style="text-align: left;">5</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">42</td>
  </tr>
  </tbody>
  </table>
  <p>И затем из <code>foo()</code> вызывается <code>bar()</code>:</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Адрес</th>
  <th style="text-align: left;">Имя</th>
  <th style="text-align: left;">Значение</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">4</td>
  <td style="text-align: left;">i</td>
  <td style="text-align: left;">6</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">3</td>
  <td style="text-align: left;">c</td>
  <td style="text-align: left;">1</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">2</td>
  <td style="text-align: left;">b</td>
  <td style="text-align: left;">100</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">a</td>
  <td style="text-align: left;">5</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">42</td>
  </tr>
  </tbody>
  </table>
  <p>Вот что мы имели ввиду раньше, говоря, что наш стек растет вверх.</p>
  <p>После того, как <code>bar()</code> завершается, её кадр будет освобожден, оставляя только <code>foo()</code> и <code>main()</code>:</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Адрес</th>
  <th style="text-align: left;">Имя</th>
  <th style="text-align: left;">Значение</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">3</td>
  <td style="text-align: left;">c</td>
  <td style="text-align: left;">1</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">2</td>
  <td style="text-align: left;">b</td>
  <td style="text-align: left;">100</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">a</td>
  <td style="text-align: left;">5</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">42</td>
  </tr>
  </tbody>
  </table>
  <p>А затем завершается <code>foo()</code>, оставляя только <code>main()</code>:</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Адрес</th>
  <th style="text-align: left;">Имя</th>
  <th style="text-align: left;">Значение</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">42</td>
  </tr>
  </tbody>
  </table>
  <p>И вот мы закончили. Уловили суть? Это как стопка тарелок: вы кладете наверх, и берёте сверху.</p>
  </section>
  <section id="куча" class="level3">
  <h3>Куча</h3>
  <p>Такой способ выделения памяти работает очень хорошо, но он может быть использован не всегда. Иногда вам необходимо передать некоторую память между различными функциями или сохранить её валидность после окончания выполнения функции. Для этого мы можем использовать кучу.</p>
  <p>В Rust, вы можете выделить память в куче с помощью упаковки, т.е. <a href="http://doc.rust-lang.org/std/boxed/index.html">типа <code>Box&lt;T&gt;</code></a>. (Примечание переводчика: мы называем <code>Box&lt;T&gt;</code> упаковкой, потому что <code>T</code> как бы «упакован» в <code>Box</code>: упаковка знает размер того, что лежит внутри. Эта информация закодирована в типе <code>T</code>, поэтому во время исполнения, для размерных типов, это просто указатель.) Вот пример:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="kw">let</span> x = Box::new(<span class="dv">5</span>);
      <span class="kw">let</span> y = <span class="dv">42</span>;
  }</code></pre>
  <p>Вот что происходит с памятью, когда вызывается <code>main()</code>:</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Адрес</th>
  <th style="text-align: left;">Имя</th>
  <th style="text-align: left;">Значение</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">y</td>
  <td style="text-align: left;">42</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">??????</td>
  </tr>
  </tbody>
  </table>
  <p>Мы выделяем место для двух переменных в стеке. <code>y</code> представляет собой <code>42</code>, тут всё как обычно. Но что насчёт <code>x</code>? Наш <code>x</code> представляет собой <code>Box&lt;i32&gt;</code>, а упаковка выделяет память в куче. Фактическое значение упаковки — структура, которая хранит указатель на «кучу». Когда начинает выполняться функция, осуществляется вызов <code>Box::new()</code>, который выделяет некоторый объем памяти в куче, и кладет туда <code>5</code>. Теперь память выглядит следующим образом:</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Адрес</th>
  <th style="text-align: left;">Имя</th>
  <th style="text-align: left;">Значение</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">(2<sup>30</sup>) - 1</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">5</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">…</td>
  <td style="text-align: left;">…</td>
  <td style="text-align: left;">…</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">y</td>
  <td style="text-align: left;">42</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">→ (2<sup>30</sup>) - 1</td>
  </tr>
  </tbody>
  </table>
  <p>В нашем гипотетическом компьютере c 1Гб оперативной памяти имеется 2<sup>30</sup> адресов. А так как наш стек растет от нуля, то проще всего выделить память с другого конца. Таким образом, наше первое значение находится на самом высоком месте в памяти. Поскольку структура <code>x</code> хранит <a href="#sec--raw-pointers">сырой указатель (raw pointer)</a> на адрес, который мы выделили в куче, то значение <code>x</code> равно (2<sup>30</sup>) - 1 — это то самое местоположение в памяти.</p>
  <p>Мы не слишком много говорили о том, что на самом деле означает «выделить» и «освободить память» в этом контексте. Чрезмерное углубление в детали по этому вопросу выходит за рамки данного руководства, но важно отметить, что куча — это не просто стек, который растет с противоположного конца. Как мы увидим в дальнейших примерах в этой книге, память из кучи может быть выделена и освобождена в любом порядке, что в конечном итоге может привести к «дыркам». Вот схема размещения памяти программы, проработавшей в течение некоторого времени:</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Адрес</th>
  <th style="text-align: left;">Имя</th>
  <th style="text-align: left;">Значение</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">(2<sup>30</sup>) - 1</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">5</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">(2<sup>30</sup>) - 2</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;"></td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">(2<sup>30</sup>) - 3</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;"></td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">(2<sup>30</sup>) - 4</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">42</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">…</td>
  <td style="text-align: left;">…</td>
  <td style="text-align: left;">…</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">3</td>
  <td style="text-align: left;">y</td>
  <td style="text-align: left;">→ (2<sup>30</sup>) - 4</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">2</td>
  <td style="text-align: left;">y</td>
  <td style="text-align: left;">42</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">y</td>
  <td style="text-align: left;">42</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">→ (2<sup>30</sup>) - 1</td>
  </tr>
  </tbody>
  </table>
  <p>В этом примере мы выделили четыре элемента в куче, но освободили лишь два из них. Отсюда разрыв между (2<sup>30</sup>) - 1 и (2<sup>30</sup>) - 4, который в настоящее время не используется. Конкретные детали того, как и почему это происходит, зависят от того, какую стратегию вы используете для управления кучей. Различные программы могут использовать различные «распределители памяти», которые представляют собой библиотеки, которые управляют памятью за вас. Программы на Rust используют для этого <a href="http://www.canonware.com/jemalloc/">jemalloc</a>.</p>
  <p>Ладно, вернемся к нашему примеру. Так как эта память расположена в куче, то она может оставаться валидной дольше, чем функция, которая выделяет упаковку. В данном случае, однако, это не так.[^the-stack-and-the-heap.md--moving] Когда функция завершается, мы должны освободить кадр стека для <code>main()</code>. Хотя у <code>Box&lt;T&gt;</code> для этого есть свой трюк: <a href="#sec--drop">Drop</a>. Реализация <code>Drop</code> для <code>Box</code> освобождает память, которая была выделена при создании. Отлично! Поэтому, когда <code>x</code> уходит, сначала освобождается память, выделенная в куче:</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Адрес</th>
  <th style="text-align: left;">Имя</th>
  <th style="text-align: left;">Значение</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">y</td>
  <td style="text-align: left;">42</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">??????</td>
  </tr>
  </tbody>
  </table>
  <pre><code>      собственности, что иногда называют «перемещение из упаковки» («moving
        out of the box»). Более сложные примеры будут рассмотрены позже.</code></pre>
  <p>А потом кадр стека уходит, освобождая всю нашу память.</p>
  </section>
  <section id="аргументы-и-заимствование" class="level3">
  <h3>Аргументы и заимствование</h3>
  <p>У нас есть некоторые простые примеры со стеком и кучей, но что насчёт аргументов функции и заимствования? Вот небольшая программа на Rust:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo(i: &amp;<span class="kw">i32</span>) {
      <span class="kw">let</span> z = <span class="dv">42</span>;
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> x = <span class="dv">5</span>;
      <span class="kw">let</span> y = &amp;x;
  
      foo(y);
  }</code></pre>
  <p>Когда мы входим в <code>main()</code>, память выглядит следующим образом:</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Адрес</th>
  <th style="text-align: left;">Имя</th>
  <th style="text-align: left;">Значение</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">y</td>
  <td style="text-align: left;">→ 0</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">5</td>
  </tr>
  </tbody>
  </table>
  <p>Значением <code>x</code> является <code>5</code>, а <code>y</code> представляет собой ссылку на <code>x</code>. То есть, ее значением является адрес памяти, по которому расположен <code>x</code>. В данном случае это <code>0</code>.</p>
  <p>А что насчёт случая, когда мы вызываем <code>foo()</code>, передавая <code>y</code> в качестве аргумента?</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Адрес</th>
  <th style="text-align: left;">Имя</th>
  <th style="text-align: left;">Значение</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">3</td>
  <td style="text-align: left;">z</td>
  <td style="text-align: left;">42</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">2</td>
  <td style="text-align: left;">i</td>
  <td style="text-align: left;">→ 0</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">y</td>
  <td style="text-align: left;">→ 0</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">5</td>
  </tr>
  </tbody>
  </table>
  <p>Кадры стека используются не только для локальных имён, но также и для аргументов. Таким образом, в этом случае, наш кадр должен содержать как <code>i</code>, наш аргумент, так и <code>z</code>, наше локальное имя. <code>i</code> — это копия аргумента <code>y</code>. Соответственно, значением <code>i</code>, как и значением <code>y</code>, является <code>0</code>.</p>
  <p>Это одна из причин, почему заимствование переменной не освобождает какую-либо память: значением ссылки является просто указатель на область памяти. Если мы освободим находящуюся по этому указателю память, то это может привести к ошибкам в дальнейшей работе.</p>
  </section>
  <section id="сложный-пример" class="level3">
  <h3>Сложный пример</h3>
  <p>Хорошо, давайте рассмотрим следующую, более сложную программу шаг за шагом:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo(x: &amp;<span class="kw">i32</span>) {
      <span class="kw">let</span> y = <span class="dv">10</span>;
      <span class="kw">let</span> z = &amp;y;
  
      baz(z);
      bar(x, z);
  }
  
  <span class="kw">fn</span> bar(a: &amp;<span class="kw">i32</span>, b: &amp;<span class="kw">i32</span>) {
      <span class="kw">let</span> c = <span class="dv">5</span>;
      <span class="kw">let</span> d = Box::new(<span class="dv">5</span>);
      <span class="kw">let</span> e = &amp;d;
  
      baz(e);
  }
  
  <span class="kw">fn</span> baz(f: &amp;<span class="kw">i32</span>) {
      <span class="kw">let</span> g = <span class="dv">100</span>;
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> h = <span class="dv">3</span>;
      <span class="kw">let</span> i = Box::new(<span class="dv">20</span>);
      <span class="kw">let</span> j = &amp;h;
  
      foo(j);
  }</code></pre>
  <p>Сначала мы вызываем <code>main()</code>:</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Адрес</th>
  <th style="text-align: left;">Имя</th>
  <th style="text-align: left;">Значение</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">(2<sup>30</sup>) - 1</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">20</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">…</td>
  <td style="text-align: left;">…</td>
  <td style="text-align: left;">…</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">2</td>
  <td style="text-align: left;">j</td>
  <td style="text-align: left;">→ 0</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">i</td>
  <td style="text-align: left;">→ (2<sup>30</sup>) - 1</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">h</td>
  <td style="text-align: left;">3</td>
  </tr>
  </tbody>
  </table>
  <p>Мы выделяем память для <code>j</code>, <code>i</code>, и <code>h</code>. <code>i</code> выделена в куче и поэтому содержит указатель на значение в куче.</p>
  <p>Далее, в конце вызова <code>main()</code>, вызывается <code>foo()</code>:</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Адрес</th>
  <th style="text-align: left;">Имя</th>
  <th style="text-align: left;">Значение</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">(2<sup>30</sup>) - 1</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">20</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">…</td>
  <td style="text-align: left;">…</td>
  <td style="text-align: left;">…</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">5</td>
  <td style="text-align: left;">z</td>
  <td style="text-align: left;">→ 4</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">4</td>
  <td style="text-align: left;">y</td>
  <td style="text-align: left;">10</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">3</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">→ 0</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">2</td>
  <td style="text-align: left;">j</td>
  <td style="text-align: left;">→ 0</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">i</td>
  <td style="text-align: left;">→ (2<sup>30</sup>) - 1</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">h</td>
  <td style="text-align: left;">3</td>
  </tr>
  </tbody>
  </table>
  <p>Пространство выделяется для <code>x</code>, <code>y</code> и <code>z</code>. Аргумент <code>x</code> имеет такое же значение, как и <code>j</code>, так как мы передали <code>j</code> в качестве аргумента. Это указатель на адрес <code>0</code>, так как <code>j</code> указывает на <code>h</code>.</p>
  <p>Далее, <code>foo()</code> вызывает <code>baz()</code>, передавая <code>z</code>:</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Адрес</th>
  <th style="text-align: left;">Имя</th>
  <th style="text-align: left;">Значение</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">(2<sup>30</sup>) - 1</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">20</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">…</td>
  <td style="text-align: left;">…</td>
  <td style="text-align: left;">…</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">7</td>
  <td style="text-align: left;">g</td>
  <td style="text-align: left;">100</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">6</td>
  <td style="text-align: left;">f</td>
  <td style="text-align: left;">→ 4</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">5</td>
  <td style="text-align: left;">z</td>
  <td style="text-align: left;">→ 4</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">4</td>
  <td style="text-align: left;">y</td>
  <td style="text-align: left;">10</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">3</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">→ 0</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">2</td>
  <td style="text-align: left;">j</td>
  <td style="text-align: left;">→ 0</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">i</td>
  <td style="text-align: left;">→ (2<sup>30</sup>) - 1</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">h</td>
  <td style="text-align: left;">3</td>
  </tr>
  </tbody>
  </table>
  <p>Мы выделили память для <code>f</code> и <code>g</code>. <code>baz()</code> очень короткая, и когда она завершается, мы избавляемся от её кадра стека:</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Адрес</th>
  <th style="text-align: left;">Имя</th>
  <th style="text-align: left;">Значение</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">(2<sup>30</sup>) - 1</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">20</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">…</td>
  <td style="text-align: left;">…</td>
  <td style="text-align: left;">…</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">5</td>
  <td style="text-align: left;">z</td>
  <td style="text-align: left;">→ 4</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">4</td>
  <td style="text-align: left;">y</td>
  <td style="text-align: left;">10</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">3</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">→ 0</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">2</td>
  <td style="text-align: left;">j</td>
  <td style="text-align: left;">→ 0</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">i</td>
  <td style="text-align: left;">→ (2<sup>30</sup>) - 1</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">h</td>
  <td style="text-align: left;">3</td>
  </tr>
  </tbody>
  </table>
  <p>Далее <code>foo()</code> вызывает <code>bar()</code> с аргументами <code>x</code> и <code>z</code>:</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Адрес</th>
  <th style="text-align: left;">Имя</th>
  <th style="text-align: left;">Значение</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">(2<sup>30</sup>) - 1</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">20</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">(2<sup>30</sup>) - 2</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">5</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">…</td>
  <td style="text-align: left;">…</td>
  <td style="text-align: left;">…</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">10</td>
  <td style="text-align: left;">e</td>
  <td style="text-align: left;">→ 9</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">9</td>
  <td style="text-align: left;">d</td>
  <td style="text-align: left;">→ (2<sup>30</sup>) - 2</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">8</td>
  <td style="text-align: left;">c</td>
  <td style="text-align: left;">5</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">7</td>
  <td style="text-align: left;">b</td>
  <td style="text-align: left;">→ 4</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">6</td>
  <td style="text-align: left;">a</td>
  <td style="text-align: left;">→ 0</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">5</td>
  <td style="text-align: left;">z</td>
  <td style="text-align: left;">→ 4</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">4</td>
  <td style="text-align: left;">y</td>
  <td style="text-align: left;">10</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">3</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">→ 0</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">2</td>
  <td style="text-align: left;">j</td>
  <td style="text-align: left;">→ 0</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">i</td>
  <td style="text-align: left;">→ (2<sup>30</sup>) - 1</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">h</td>
  <td style="text-align: left;">3</td>
  </tr>
  </tbody>
  </table>
  <p>Тут мы выделяем другое значение в куче, и поэтому мы вычитаем единицу из (2<sup>30</sup>) - 1. Это выражение написать легче, чем <code>1 073 741 822</code>. В любом случае, переменные создаются, как обычно.</p>
  <p>В конце <code>bar()</code> вызывает <code>baz()</code>:</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Адрес</th>
  <th style="text-align: left;">Имя</th>
  <th style="text-align: left;">Значение</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">(2<sup>30</sup>) - 1</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">20</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">(2<sup>30</sup>) - 2</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">5</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">…</td>
  <td style="text-align: left;">…</td>
  <td style="text-align: left;">…</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">12</td>
  <td style="text-align: left;">g</td>
  <td style="text-align: left;">100</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">11</td>
  <td style="text-align: left;">f</td>
  <td style="text-align: left;">→ 9</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">10</td>
  <td style="text-align: left;">e</td>
  <td style="text-align: left;">→ 9</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">9</td>
  <td style="text-align: left;">d</td>
  <td style="text-align: left;">→ (2<sup>30</sup>) - 2</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">8</td>
  <td style="text-align: left;">c</td>
  <td style="text-align: left;">5</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">7</td>
  <td style="text-align: left;">b</td>
  <td style="text-align: left;">→ 4</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">6</td>
  <td style="text-align: left;">a</td>
  <td style="text-align: left;">→ 0</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">5</td>
  <td style="text-align: left;">z</td>
  <td style="text-align: left;">→ 4</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">4</td>
  <td style="text-align: left;">y</td>
  <td style="text-align: left;">10</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">3</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">→ 0</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">2</td>
  <td style="text-align: left;">j</td>
  <td style="text-align: left;">→ 0</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">i</td>
  <td style="text-align: left;">→ (2<sup>30</sup>) - 1</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">h</td>
  <td style="text-align: left;">3</td>
  </tr>
  </tbody>
  </table>
  <p>Сейчас мы на наибольшей глубине! Поздравляем с достижением данной точки.</p>
  <p>После завершения <code>baz()</code>, мы избавляемся от <code>f</code> и <code>g</code>:</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Адрес</th>
  <th style="text-align: left;">Имя</th>
  <th style="text-align: left;">Значение</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">(2<sup>30</sup>) - 1</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">20</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">(2<sup>30</sup>) - 2</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">5</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">…</td>
  <td style="text-align: left;">…</td>
  <td style="text-align: left;">…</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">10</td>
  <td style="text-align: left;">e</td>
  <td style="text-align: left;">→ 9</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">9</td>
  <td style="text-align: left;">d</td>
  <td style="text-align: left;">→ (2<sup>30</sup>) - 2</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">8</td>
  <td style="text-align: left;">c</td>
  <td style="text-align: left;">5</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">7</td>
  <td style="text-align: left;">b</td>
  <td style="text-align: left;">→ 4</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">6</td>
  <td style="text-align: left;">a</td>
  <td style="text-align: left;">→ 0</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">5</td>
  <td style="text-align: left;">z</td>
  <td style="text-align: left;">→ 4</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">4</td>
  <td style="text-align: left;">y</td>
  <td style="text-align: left;">10</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">3</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">→ 0</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">2</td>
  <td style="text-align: left;">j</td>
  <td style="text-align: left;">→ 0</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">i</td>
  <td style="text-align: left;">→ (2<sup>30</sup>) - 1</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">h</td>
  <td style="text-align: left;">3</td>
  </tr>
  </tbody>
  </table>
  <p>Далее мы выполняем возврат из <code>bar()</code>. В этом случае <code>d</code> представляет собой <code>Box&lt;T&gt;</code>, поэтому он также освобождает и то, на что он указывает: (2<sup>30</sup>) - 2.</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Адрес</th>
  <th style="text-align: left;">Имя</th>
  <th style="text-align: left;">Значение</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">(2<sup>30</sup>) - 1</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">20</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">…</td>
  <td style="text-align: left;">…</td>
  <td style="text-align: left;">…</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">5</td>
  <td style="text-align: left;">z</td>
  <td style="text-align: left;">→ 4</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">4</td>
  <td style="text-align: left;">y</td>
  <td style="text-align: left;">10</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">3</td>
  <td style="text-align: left;">x</td>
  <td style="text-align: left;">→ 0</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">2</td>
  <td style="text-align: left;">j</td>
  <td style="text-align: left;">→ 0</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">i</td>
  <td style="text-align: left;">→ (2<sup>30</sup>) - 1</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">h</td>
  <td style="text-align: left;">3</td>
  </tr>
  </tbody>
  </table>
  <p>И после этого происходит возврат из <code>foo()</code>:</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">Адрес</th>
  <th style="text-align: left;">Имя</th>
  <th style="text-align: left;">Значение</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">(2<sup>30</sup>) - 1</td>
  <td style="text-align: left;"></td>
  <td style="text-align: left;">20</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">…</td>
  <td style="text-align: left;">…</td>
  <td style="text-align: left;">…</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">2</td>
  <td style="text-align: left;">j</td>
  <td style="text-align: left;">→ 0</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">i</td>
  <td style="text-align: left;">→ (2<sup>30</sup>) - 1</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">h</td>
  <td style="text-align: left;">3</td>
  </tr>
  </tbody>
  </table>
  <p>И вот, наконец, <code>main()</code>, которая очищает все остальное. Когда освобождается <code>i</code> (<code>Drop</code>), будет также очищен и конец кучи.</p>
  </section>
  <section id="а-что-делают-другие-языки" class="level3">
  <h3>А что делают другие языки?</h3>
  <p>Большинство языков со сборщиком мусора по умолчанию выделяет память из кучи. Это означает, что каждое значение будет упаковано. Есть ряд причин, почему делается именно так, но они выходят за рамки данного руководства. Есть несколько возможных оптимизаций, которые, правда, не достигают своей цели во всех случаях. Вместо того чтобы полагаться на стек и <code>Drop</code> в вопросах очистки памяти, сборщик мусора работает с кучей.</p>
  </section>
  <section id="что-использовать" class="level3">
  <h3>Что использовать?</h3>
  <p>Но, если стек быстрее и проще в управлении, зачем тогда нужна куча? Весомая причина заключается в том, что память в стеке может выделяться только по принципу «первым пришёл — последним вышел». Таким образом, место из-под кадра стека предыдущего вызова функции будет переиспользовано под следующий вызов. Выделение в куче — более общая техника. Она позволяет выделение и освобождение памяти в любом порядке. Однако, это достигается ценой увеличения сложности реализации механизма выделения памяти.</p>
  <p>В общем случае, следует предпочитать выделение в стеке, и поэтому, Rust использует выделение в стеке по умолчанию. LIFO модель стека («последним пришёл — первым вышел») фундаментально проще. Это значит, что программа быстрее исполняется, и проще по смыслу.</p>
  <section id="эффективность-во-время-выполнения" class="level4">
  <h4>Эффективность во время выполнения</h4>
  <p>Управление памятью для стека тривиально: машина просто увеличивает или уменьшает одно значение, так называемый «указатель стека» (stack pointer). Управление памятью для кучи сложнее: память, выделенная в куче, освобождается в произвольные моменты, а каждая область выделенной в куче памяти может быть произвольного размера. Распределителю памяти, как правило, требуется приложить гораздо больше усилий для определения областей, которые можно использовать заново.</p>
  <p>Если вы хотите изучить эту тему более подробно, то <a href="http://www.cs.northwestern.edu/~pdinda/icsclass/doc/dsa.pdf">эта статья</a> будет отличным введением.</p>
  </section>
  <section id="простота-программы" class="level4">
  <h4>Простота программы</h4>
  <p>Выделение памяти в стеке воздействует как на сам язык Rust, так и на модель мышления разработчиков. Стековая семантика — ключевое понятие Rust. Мы получаем автоматическое управление памятью без усложнения среды исполнения. Именно этот механизм позволяет освободить память в куче, как только её владелец вышел из области видимости — по сути, как только схлопнулся стек кадра, на котором он жил. К сожалению, в некоторых ситуациях стека недостаточно. Если нужна большая гибкость во владении памятью, можно воспользоваться счётчиками ссылок <code>Rc&lt;T&gt;</code> и <code>Arc&lt;T&gt;</code>.</p>
  <p>Желание более удобно пользоваться памятью в куче может доходить до крайности. С одной стороны, можно реализовать сборщик мусора — но это сильно увеличивает сложность среды исполнения. С другой стороны, полностью ручное управление памятью с явным вызовом процедуры освобождения часто приводит к ошибкам, предотвратить которые компилятор Rust не в силах.</p>
  </section>
  </section>
  </section>
  <section id="sec--testing" class="level2">
  <h2>Тестирование</h2>
  <blockquote>
  <p>Program testing can be a very effective way to show the presence of bugs, but it is hopelessly inadequate for showing their absence.</p>
  <p>Edsger W. Dijkstra, “The Humble Programmer” (1972)</p>
  </blockquote>
  <blockquote>
  <p>Тестирование программы может быть очень эффективным способом показать наличие ошибок, но оно безнадёжно неподходяще для доказательства их отсутствия.</p>
  <p>Дейкстра, Эдсгер Вибе, «The Humble Programmer» (1972)</p>
  </blockquote>
  <p>Давайте поговорим о том, как тестировать код на Rust. Мы не будем рассказывать о том, какой подход к тестированию Rust кода является верным. Есть много подходов, каждый из которых имеет свое представление о правильном написании тестов. Но все эти подходы используют одни и те же основные инструменты, и мы покажем вам синтаксис их использования.</p>
  <section id="тесты-с-атрибутом-test" class="level3">
  <h3>Тесты с атрибутом <code>test</code></h3>
  <p>В самом простом случае, тест в Rust — это функция, аннотированная атрибутом <code>test</code>. Давайте создадим новый проект Cargo, который будет называться <code>adder</code>:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> new adder
  $ <span class="kw">cd</span> adder</code></pre>
  <p>При создании нового проекта, Cargo автоматически сгенерирует простой тест. Ниже представлено содержимое <code>src/lib.rs</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="ot">#[</span>test<span class="ot">]</span>
  <span class="kw">fn</span> it_works() {
  }</code></pre>
  <p>Обратите внимание на <code>#[test]</code>. Этот атрибут указывает, что это тестовая функция. В этом примере она не имеет тела. Но такого вида функции достаточно, чтобы удачно выполнить тест. Запуск тестов осуществляется командой <code>cargo test</code>.</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> test
     <span class="kw">Compiling</span> adder v0.0.1 (file:///home/you/projects/adder)
       <span class="kw">Running</span> target/adder-91b3e234d4ed382a
  
  <span class="kw">running</span> 1 test
  <span class="kw">test</span> it_works ... ok
  
  <span class="kw">test</span> result: ok. 1 passed<span class="kw">;</span> <span class="kw">0</span> failed<span class="kw">;</span> <span class="kw">0</span> ignored<span class="kw">;</span> <span class="kw">0</span> measured
  
     <span class="kw">Doc-tests</span> adder
  
  <span class="kw">running</span> 0 tests
  
  <span class="kw">test</span> result: ok. 0 passed<span class="kw">;</span> <span class="kw">0</span> failed<span class="kw">;</span> <span class="kw">0</span> ignored<span class="kw">;</span> <span class="kw">0</span> measured</code></pre>
  <p>Cargo скомпилировал и запустил наши тесты. В результате мы получили выходные данные, поделенные на два раздела: один содержит информацию о тесте, который мы написали, а другой — информацию о тестах из документации. Но об этом позже. А сейчас посмотрим на эту строку:</p>
  <pre class="text"><code>test it_works ... ok</code></pre>
  <p>Обратите внимание на <code>it_works</code>. Это название нашей функции:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> it_works() {</code></pre>
  <p>Мы также получили итоговую строку:</p>
  <pre class="text"><code>test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured</code></pre>
  <p>Так почему же наш ничего не делающий тест был выполнен удачно? Любой тест, который не вызывает <code>panic!</code>, выполняется удачно, а любой тест, который вызывает <code>panic!</code>, выполняется неудачно. Давайте сделаем тест, который выполнится неудачно:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="ot">#[</span>test<span class="ot">]</span>
  <span class="kw">fn</span> it_works() {
      <span class="ot">assert!</span>(<span class="kw">false</span>);
  }</code></pre>
  <p><code>assert!</code> — это макрос, определенный в Rust, и принимающий один аргумент: если аргумент имеет значение <code>true</code>, то ничего не происходит; если аргумент является <code>false</code>, то вызывается <code>panic!</code>. Давайте запустим наши тесты снова:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> test
     <span class="kw">Compiling</span> adder v0.0.1 (file:///home/you/projects/adder)
       <span class="kw">Running</span> target/adder-91b3e234d4ed382a
  
  <span class="kw">running</span> 1 test
  <span class="kw">test</span> it_works ... FAILED
  
  <span class="kw">failures</span>:
  
  <span class="kw">----</span> it_works stdout ----
          <span class="kw">thread</span> <span class="st">'it_works'</span> panicked at <span class="st">'assertion failed: false'</span>, /home/steve/tmp/adder
  ↳ <span class="kw">/src</span>/lib.rs:<span class="kw">3</span>
  
  
  
  <span class="kw">failures</span>:
      <span class="kw">it_works</span>
  
  <span class="kw">test</span> result: FAILED. 0 passed<span class="kw">;</span> <span class="kw">1</span> failed<span class="kw">;</span> <span class="kw">0</span> ignored<span class="kw">;</span> <span class="kw">0</span> measured
  
  <span class="kw">thread</span> <span class="st">'&lt;main&gt;'</span> panicked at <span class="st">'Some tests failed'</span>, /home/steve/src/rust/src/libtest/lib.
  ↳ <span class="kw">rs</span>:247</code></pre>
  <p>Rust сообщает, что наш тест выполнен неудачно:</p>
  <pre class="text"><code>test it_works ... FAILED</code></pre>
  <p>Это же отражается в итоговой строке:</p>
  <pre class="text"><code>test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured</code></pre>
  <p>Мы также получаем ненулевой код состояния. Можно использовать <code>$?</code> на OS X и Linux:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">echo</span> <span class="ot">$?</span>
  <span class="kw">101</span></code></pre>
  <p>На Windows, если вы используете <code>cmd</code>:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">    <span class="kw">echo</span> %ERRORLEVEL%</code></pre>
  <p>И если вы используете PowerShell:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">    <span class="kw">echo</span> <span class="ot">$LASTEXITCODE</span> <span class="co"># сам код</span>
      <span class="kw">echo</span> <span class="ot">$?</span> <span class="co"># логическое, успешно или не успешно</span></code></pre>
  <p>Это бывает полезно, если вы хотите интегрировать <code>cargo test</code> в сторонний инструмент.</p>
  <p>Можно инвертировать ожидаемый результат теста с помощью атрибута: <code>should_panic</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="ot">#[</span>test<span class="ot">]</span>
  <span class="ot">#[</span>should_panic<span class="ot">]</span>
  <span class="kw">fn</span> it_works() {
      <span class="ot">assert!</span>(<span class="kw">false</span>);
  }</code></pre>
  <p>Теперь этот тест будет выполнен удачно, если вызывается <code>panic!</code>, и неудачно, если <code>panic!</code> не вызывается. Давайте попробуем:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> test
     <span class="kw">Compiling</span> adder v0.0.1 (file:///home/you/projects/adder)
       <span class="kw">Running</span> target/adder-91b3e234d4ed382a
  
  <span class="kw">running</span> 1 test
  <span class="kw">test</span> it_works ... ok
  
  <span class="kw">test</span> result: ok. 1 passed<span class="kw">;</span> <span class="kw">0</span> failed<span class="kw">;</span> <span class="kw">0</span> ignored<span class="kw">;</span> <span class="kw">0</span> measured
  
     <span class="kw">Doc-tests</span> adder
  
  <span class="kw">running</span> 0 tests
  
  <span class="kw">test</span> result: ok. 0 passed<span class="kw">;</span> <span class="kw">0</span> failed<span class="kw">;</span> <span class="kw">0</span> ignored<span class="kw">;</span> <span class="kw">0</span> measured</code></pre>
  <p>Rust предоставляет и другой макрос, <code>assert_eq!</code>, который проверяет равенство двух аргументов:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="ot">#[</span>test<span class="ot">]</span>
  <span class="ot">#[</span>should_panic<span class="ot">]</span>
  <span class="kw">fn</span> it_works() {
      <span class="ot">assert_eq!</span>(<span class="st">&quot;Hello&quot;</span>, <span class="st">&quot;world&quot;</span>);
  }</code></pre>
  <p>А теперь этот тест будет выполнен удачно или неудачно? Из-за атрибута <code>should_panic</code> он завершится удачно:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> test
     <span class="kw">Compiling</span> adder v0.0.1 (file:///home/you/projects/adder)
       <span class="kw">Running</span> target/adder-91b3e234d4ed382a
  
  <span class="kw">running</span> 1 test
  <span class="kw">test</span> it_works ... ok
  
  <span class="kw">test</span> result: ok. 1 passed<span class="kw">;</span> <span class="kw">0</span> failed<span class="kw">;</span> <span class="kw">0</span> ignored<span class="kw">;</span> <span class="kw">0</span> measured
  
     <span class="kw">Doc-tests</span> adder
  
  <span class="kw">running</span> 0 tests
  
  <span class="kw">test</span> result: ok. 0 passed<span class="kw">;</span> <span class="kw">0</span> failed<span class="kw">;</span> <span class="kw">0</span> ignored<span class="kw">;</span> <span class="kw">0</span> measured</code></pre>
  <p>Тесты <code>should_panic</code> могут быть хрупкими, поскольку трудно гарантировать, что тест не вызовет панику по неожиданной причине. Чтобы помочь в этом аспекте, к атрибуту <code>should_panic</code> может быть добавлен необязательный параметр <code>expected</code>. Тогда тест также будет проверять, что сообщение об ошибке содержит ожидаемый текст. Ниже представлен более безопасный вариант приведенного выше примера:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="ot">#[</span>test<span class="ot">]</span>
  <span class="ot">#[</span>should_panic<span class="ot">(</span>expected <span class="ot">=</span> <span class="st">&quot;assertion failed&quot;</span><span class="ot">)]</span>
  <span class="kw">fn</span> it_works() {
      <span class="ot">assert_eq!</span>(<span class="st">&quot;Hello&quot;</span>, <span class="st">&quot;world&quot;</span>);
  }</code></pre>
  <p>Вот и все, что касается основ! Давайте напишем один «настоящий» тест:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">fn</span> add_two(a: <span class="kw">i32</span>) -&gt; <span class="kw">i32</span> {
      a + <span class="dv">2</span>
  }
  
  <span class="ot">#[</span>test<span class="ot">]</span>
  <span class="kw">fn</span> it_works() {
      <span class="ot">assert_eq!</span>(<span class="dv">4</span>, add_two(<span class="dv">2</span>));
  }</code></pre>
  <p>Это распространенное использование макроса <code>assert_eq!</code>: вызывать некоторую функцию с известными аргументами и сравнить результат её вызова с ожидаемым результатом.</p>
  </section>
  <section id="тесты-с-атрибутом-ignore" class="level3">
  <h3>Тесты с атрибутом <code>ignore</code></h3>
  <p>Некоторые тесты могу занимать много времени на выполнение. Такие тесты могут быть отключены по умолчанию с помощью атрибута <code>ignore</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> it_works() {
      <span class="ot">assert_eq!</span>(<span class="dv">4</span>, add_two(<span class="dv">2</span>));
  }
  
  <span class="ot">#[</span>test<span class="ot">]</span>
  <span class="ot">#[</span>ignore<span class="ot">]</span>
  <span class="kw">fn</span> expensive_test() {
      <span class="co">// код, который занимает час на выполнение</span>
  }</code></pre>
  <p>Теперь запустим наши тесты и видим, что <code>it_works</code> запускается, а <code>expensive_test</code> нет:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> test
     <span class="kw">Compiling</span> adder v0.0.1 (file:///home/you/projects/adder)
       <span class="kw">Running</span> target/adder-91b3e234d4ed382a
  
  <span class="kw">running</span> 2 tests
  <span class="kw">test</span> expensive_test ... ignored
  <span class="kw">test</span> it_works ... ok
  
  <span class="kw">test</span> result: ok. 1 passed<span class="kw">;</span> <span class="kw">0</span> failed<span class="kw">;</span> <span class="kw">1</span> ignored<span class="kw">;</span> <span class="kw">0</span> measured
  
     <span class="kw">Doc-tests</span> adder
  
  <span class="kw">running</span> 0 tests
  
  <span class="kw">test</span> result: ok. 0 passed<span class="kw">;</span> <span class="kw">0</span> failed<span class="kw">;</span> <span class="kw">0</span> ignored<span class="kw">;</span> <span class="kw">0</span> measured</code></pre>
  <p>Дорогостоящие тесты могут быть запущены с помощью команды <code>cargo test -- --ignored</code>:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> test -- --ignored
       <span class="kw">Running</span> target/adder-91b3e234d4ed382a
  
  <span class="kw">running</span> 1 test
  <span class="kw">test</span> expensive_test ... ok
  
  <span class="kw">test</span> result: ok. 1 passed<span class="kw">;</span> <span class="kw">0</span> failed<span class="kw">;</span> <span class="kw">0</span> ignored<span class="kw">;</span> <span class="kw">0</span> measured
  
     <span class="kw">Doc-tests</span> adder
  
  <span class="kw">running</span> 0 tests
  
  <span class="kw">test</span> result: ok. 0 passed<span class="kw">;</span> <span class="kw">0</span> failed<span class="kw">;</span> <span class="kw">0</span> ignored<span class="kw">;</span> <span class="kw">0</span> measured</code></pre>
  <p>Аргумент <code>--ignored</code> — это аргумент для тестового исполняемого файла, а не для Cargo, именно поэтому команда выглядит так <code>cargo test -- --ignored</code>.</p>
  </section>
  <section id="тесты-в-модуле-test" class="level3">
  <h3>Тесты в модуле <code>test</code></h3>
  <p>Есть один нюанс, из-за которого наш пример нельзя назвать идиоматичным: отсутствует модуль тестирования. Идиоматичный вариант нашего примера будет выглядеть примерно так:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">fn</span> add_two(a: <span class="kw">i32</span>) -&gt; <span class="kw">i32</span> {
      a + <span class="dv">2</span>
  }
  
  <span class="ot">#[</span>cfg<span class="ot">(</span>test<span class="ot">)]</span>
  <span class="kw">mod</span> test {
      <span class="kw">use</span> <span class="kw">super</span>::add_two;
  
      <span class="ot">#[</span>test<span class="ot">]</span>
      <span class="kw">fn</span> it_works() {
          <span class="ot">assert_eq!</span>(<span class="dv">4</span>, add_two(<span class="dv">2</span>));
      }
  }</code></pre>
  <p>Здесь есть несколько изменений. Первое — это введение <code>mod test</code> с атрибутом <code>cfg</code>. Модуль позволяет сгруппировать все наши тесты вместе, а также, если нужно, определить вспомогательные функции, которые будут отделены от остальной части контейнера. Атрибут <code>cfg</code> указывает на то, что тест будет скомпилирован, только когда мы попытаемся запустить тесты. Это может сэкономить время компиляции, а также гарантирует, что наши тесты полностью исключены из обычной сборки.</p>
  <p>Второе изменение заключается в объявлении <code>use</code>. Так как мы находимся во внутреннем модуле, то мы должны объявить использование тестируемой функции в его области видимости. Это может раздражать, если у вас большой модуль, и поэтому обычно используют возможность <code>glob</code>. Давайте изменим <code>src/lib.rs</code> соответствующим образом:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">
  <span class="kw">pub</span> <span class="kw">fn</span> add_two(a: <span class="kw">i32</span>) -&gt; <span class="kw">i32</span> {
      a + <span class="dv">2</span>
  }
  
  <span class="ot">#[</span>cfg<span class="ot">(</span>test<span class="ot">)]</span>
  <span class="kw">mod</span> test {
      <span class="kw">use</span> <span class="kw">super</span>::*;
  
      <span class="ot">#[</span>test<span class="ot">]</span>
      <span class="kw">fn</span> it_works() {
          <span class="ot">assert_eq!</span>(<span class="dv">4</span>, add_two(<span class="dv">2</span>));
      }
  }</code></pre>
  <p>Обратите внимание на различие в строке с <code>use</code>. Теперь запустим наши тесты:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> test
      <span class="kw">Updating</span> registry <span class="kw">`https</span>://github.com/rust-lang/crates.io-index<span class="kw">`</span>
     <span class="kw">Compiling</span> adder v0.0.1 (file:///home/you/projects/adder)
       <span class="kw">Running</span> target/adder-91b3e234d4ed382a
  
  <span class="kw">running</span> 1 test
  <span class="kw">test</span> test::it_works ... ok
  
  <span class="kw">test</span> result: ok. 1 passed<span class="kw">;</span> <span class="kw">0</span> failed<span class="kw">;</span> <span class="kw">0</span> ignored<span class="kw">;</span> <span class="kw">0</span> measured
  
     <span class="kw">Doc-tests</span> adder
  
  <span class="kw">running</span> 0 tests
  
  <span class="kw">test</span> result: ok. 0 passed<span class="kw">;</span> <span class="kw">0</span> failed<span class="kw">;</span> <span class="kw">0</span> ignored<span class="kw">;</span> <span class="kw">0</span> measured</code></pre>
  <p>Работает!</p>
  <p>Данный подход представляет собой использование модуля <code>test</code>, содержащего модульные тесты (unit tests). Любой код, задачей которого является только лишь тестирование небольшого кусочка функциональности, имеет смысл перенести в этот модуль. Но что если мы хотим написать «интеграционные тесты» (integration tests)? Для этого следует использовать директорию <code>tests</code>.</p>
  </section>
  <section id="тесты-в-директории-tests" class="level3">
  <h3>Тесты в директории <code>tests</code></h3>
  <p>Чтобы написать интеграционный тест, давайте создадим директорию <code>tests</code>, и положим в нее файл <code>tests/lib.rs</code> со следующим содержимым:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> crate adder;
  
  <span class="ot">#[</span>test<span class="ot">]</span>
  <span class="kw">fn</span> it_works() {
      <span class="ot">assert_eq!</span>(<span class="dv">4</span>, adder::add_two(<span class="dv">2</span>));
  }</code></pre>
  <p>Выглядит примерно так же, как и наши предыдущие тесты, но есть некоторые отличия. Теперь сверху у нас <code>extern crate adder</code>. Это потому, что тесты в директории <code>tests</code> — это отдельный контейнер, и, следовательно, мы должны компоноваться с нашей библиотекой. Это также объясняет, почему директория <code>tests</code> — наиболее подходящее место для написания интеграционных тестов: они используют библиотеку, как это делал бы любой другой потребитель.</p>
  <p>Давайте запустим их:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> test
     <span class="kw">Compiling</span> adder v0.0.1 (file:///home/you/projects/adder)
       <span class="kw">Running</span> target/adder-91b3e234d4ed382a
  
  <span class="kw">running</span> 1 test
  <span class="kw">test</span> test::it_works ... ok
  
  <span class="kw">test</span> result: ok. 1 passed<span class="kw">;</span> <span class="kw">0</span> failed<span class="kw">;</span> <span class="kw">0</span> ignored<span class="kw">;</span> <span class="kw">0</span> measured
  
       <span class="kw">Running</span> target/lib-c18e7d3494509e74
  
  <span class="kw">running</span> 1 test
  <span class="kw">test</span> it_works ... ok
  
  <span class="kw">test</span> result: ok. 1 passed<span class="kw">;</span> <span class="kw">0</span> failed<span class="kw">;</span> <span class="kw">0</span> ignored<span class="kw">;</span> <span class="kw">0</span> measured
  
     <span class="kw">Doc-tests</span> adder
  
  <span class="kw">running</span> 0 tests
  
  <span class="kw">test</span> result: ok. 0 passed<span class="kw">;</span> <span class="kw">0</span> failed<span class="kw">;</span> <span class="kw">0</span> ignored<span class="kw">;</span> <span class="kw">0</span> measured</code></pre>
  <p>Теперь у нас появилось три раздела: запускается старый модульный тест, а также новый интеграционный тест.</p>
  <p>Это все, что касается директории <code>tests</code>. Модуль <code>test</code> здесь не нужен, так как здесь всё относится к тестам.</p>
  <p>Давайте, наконец, перейдем к третьей части: тесты в документации.</p>
  </section>
  <section id="тесты-в-документации" class="level3">
  <h3>Тесты в документации</h3>
  <p>Нет ничего лучше, чем документация с примерами. Нет ничего хуже, чем примеры, которые на самом деле не работают, потому что код изменился с тех пор, как была написана документация. Для того, чтобы такой ситуации не возникало, Rust поддерживает автоматический запуск примеров в документации (имейте ввиду, что это работает только с библиотеками). Вот дополненный <code>src/lib.rs</code> с примерами:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">//! Контейнер `adder` предоставляет функции сложения чисел.</span>
  <span class="co">//!</span>
  <span class="co">//! # Examples</span>
  <span class="co">//!</span>
  <span class="co">//! ```</span>
  <span class="co">//! assert_eq!(4, adder::add_two(2));</span>
  <span class="co">//! ```</span>
  
  <span class="co">/// Эта функция прибавляет 2 к своему аргументу.</span>
  <span class="co">///</span>
  <span class="co">/// # Examples</span>
  <span class="co">///</span>
  <span class="co">/// ```</span>
  <span class="co">/// use adder::add_two;</span>
  <span class="co">///</span>
  <span class="co">/// assert_eq!(4, add_two(2));</span>
  <span class="co">/// ```</span>
  <span class="kw">pub</span> <span class="kw">fn</span> add_two(a: <span class="kw">i32</span>) -&gt; <span class="kw">i32</span> {
      a + <span class="dv">2</span>
  }
  
  <span class="ot">#[</span>cfg<span class="ot">(</span>test<span class="ot">)]</span>
  <span class="kw">mod</span> test {
      <span class="kw">use</span> <span class="kw">super</span>::*;
  
      <span class="ot">#[</span>test<span class="ot">]</span>
      <span class="kw">fn</span> it_works() {
          <span class="ot">assert_eq!</span>(<span class="dv">4</span>, add_two(<span class="dv">2</span>));
      }
  }</code></pre>
  <p>Обратите внимание на документацию уровня модуля, начинающуюся с <code>//!</code> и на документацию уровня функции, начинающуюся с <code>///</code>. Документация Rust поддерживает Markdown в комментариях, поэтому блоки кода помечают тройными символами `. В комментарии документации обычно включают раздел <code># Examples</code>, содержащий примеры, такие как этот. (Примечание переводчика: заголовок <code># Examples</code> имеет особое значение: его нельзя написать по-другому или написать на русском языке, иначе Rust не найдёт примеров кода в документации.)</p>
  <p>Давайте запустим тесты снова:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> test
     <span class="kw">Compiling</span> adder v0.0.1 (file:///home/steve/tmp/adder)
       <span class="kw">Running</span> target/adder-91b3e234d4ed382a
  
  <span class="kw">running</span> 1 test
  <span class="kw">test</span> test::it_works ... ok
  
  <span class="kw">test</span> result: ok. 1 passed<span class="kw">;</span> <span class="kw">0</span> failed<span class="kw">;</span> <span class="kw">0</span> ignored<span class="kw">;</span> <span class="kw">0</span> measured
  
       <span class="kw">Running</span> target/lib-c18e7d3494509e74
  
  <span class="kw">running</span> 1 test
  <span class="kw">test</span> it_works ... ok
  
  <span class="kw">test</span> result: ok. 1 passed<span class="kw">;</span> <span class="kw">0</span> failed<span class="kw">;</span> <span class="kw">0</span> ignored<span class="kw">;</span> <span class="kw">0</span> measured
  
     <span class="kw">Doc-tests</span> adder
  
  <span class="kw">running</span> 2 tests
  <span class="kw">test</span> add_two_0 ... ok
  <span class="kw">test</span> _0 ... ok
  
  <span class="kw">test</span> result: ok. 2 passed<span class="kw">;</span> <span class="kw">0</span> failed<span class="kw">;</span> <span class="kw">0</span> ignored<span class="kw">;</span> <span class="kw">0</span> measured</code></pre>
  <p>Теперь у нас запускаются все три вида тестов! Обратите внимание на имена тестов из документации: <code>_0</code> генерируется для модульных тестов, и <code>add_two_0</code> — для функциональных тестов. Цифры на конце будут увеличиваться автоматически, если вы добавите еще примеров. Например, при добавлении ещё одного функционального теста, он получит имя <code>add_two_1</code>.</p>
  <p>Мы не рассмотрели все детали написания тестов в документации. Подробнее смотрите главу <a href="#sec--documentation">Документация</a>.</p>
  <p>Последнее замечание: тесты в документации <em>не работают</em> для исполняемых файлов. Подробнее об организации файлов можно узнать в главе <a href="#sec--crates-and-modules">Контейнеры и модули</a>.</p>
  </section>
  </section>
  <section id="sec--conditional-compilation" class="level2">
  <h2>Условная компиляция</h2>
  <p>В Rust есть специальный атрибут, <code>#[cfg]</code>, который позволяет компилировать код в зависимости от флагов, переданных компилятору. Он имеет две формы:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="ot">#[</span>cfg<span class="ot">(</span>foo<span class="ot">)]</span>
  
  <span class="ot">#[</span>cfg<span class="ot">(</span>bar <span class="ot">=</span> <span class="st">&quot;baz&quot;</span><span class="ot">)]</span></code></pre>
  <p>Над атрибутами конфигурации определены логические операции:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="ot">#[</span>cfg<span class="ot">(</span>any<span class="ot">(</span>unix<span class="ot">,</span> windows<span class="ot">))]</span>
  
  <span class="ot">#[</span>cfg<span class="ot">(</span>all<span class="ot">(</span>unix<span class="ot">,</span> target_pointer_width <span class="ot">=</span> <span class="st">&quot;32&quot;</span><span class="ot">))]</span>
  
  <span class="ot">#[</span>cfg<span class="ot">(</span>not<span class="ot">(</span>foo<span class="ot">))]</span></code></pre>
  <p>Они могут быть как угодно вложены:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="ot">#[</span>cfg<span class="ot">(</span>any<span class="ot">(</span>not<span class="ot">(</span>unix<span class="ot">),</span> all<span class="ot">(</span>target_os<span class="ot">=</span><span class="st">&quot;macos&quot;</span><span class="ot">,</span> target_arch <span class="ot">=</span> <span class="st">&quot;powerpc&quot;</span><span class="ot">)))]</span></code></pre>
  <p>Что же касается того, как включить или отключить эти флаги: если вы используете Cargo, то они устанавливаются в <a href="http://doc.crates.io/manifest.html#the-[features]-section">разделе <code>[features]</code></a> вашего <code>Cargo.toml</code>:</p>
  <pre class="toml"><code>[features]
  # по умолчанию, никаких дополнительных возможностей
  default = []
  
  # возможность «secure-password» зависит от пакета bcrypt
  secure-password = [&quot;bcrypt&quot;]</code></pre>
  <p>Если вы определите такие возможности, Cargo передаст флаг в <code>rustc</code>:</p>
  <pre class="text"><code>--cfg feature=&quot;${feature_name}&quot;</code></pre>
  <p>Совокупность этих флагов конфигурации (<code>cfg</code>) будет определять, какие из них будут активны, и, следовательно, какой код будет скомпилирован. Давайте рассмотрим такой код:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="ot">#[</span>cfg<span class="ot">(</span>feature <span class="ot">=</span> <span class="st">&quot;foo&quot;</span><span class="ot">)]</span>
  <span class="kw">mod</span> foo {
  }</code></pre>
  <p>Если скомпилировать его с помощью <code>cargo build --features &quot;foo&quot;</code>, то в <code>rustc</code> будет передан флаг <code>--cfg feature=&quot;foo&quot;</code>, и результат будет содержать модуль <code>mod foo</code>. Если скомпилировать его с помощью обычной команды <code>cargo build</code>, то никаких дополнительных флагов передано не будет, и поэтому, модуль <code>mod foo</code> будет отсутствовать.</p>
  <section id="cfg_attr" class="level3">
  <h3>cfg_attr</h3>
  <p>Вы также можете установить другой атрибут в зависимости от переменной <code>cfg</code> с помощью атрибута <code>cfg_attr</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="ot">#[</span>cfg_attr<span class="ot">(</span>a<span class="ot">,</span> b<span class="ot">)]</span></code></pre>
  <p>Этот код будет равносилен атрибуту <code>#[b]</code>, если в атрибуте <code>cfg</code> установлен флаг <code>a</code>, или «без атрибута» в противном случае.</p>
  </section>
  <section id="cfg" class="level3">
  <h3>cfg!</h3>
  <p><a href="#sec--compiler-plugins">Расширение синтаксиса</a> <code>cfg!</code> позволяет использовать данные виды флагов и в другом месте в коде:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">if</span> <span class="ot">cfg!</span>(target_os = <span class="st">&quot;macos&quot;</span>) || <span class="ot">cfg!</span>(target_os = <span class="st">&quot;ios&quot;</span>) {
      <span class="ot">println!</span>(<span class="st">&quot;Think Different!&quot;</span>);
  }</code></pre>
  <p>Значение флага будет заменено на <code>true</code> или <code>false</code> во время компиляции, в зависимости от настройки конфигурации.</p>
  </section>
  </section>
  <section id="sec--documentation" class="level2">
  <h2>Документация</h2>
  <p>Документация является важной частью любого программного проекта, и в Rust ей уделяется не меньше внимания, чем самому коду. Давайте поговорим об инструментах Rust, предназначенных для создания документации к проекту.</p>
  <section id="о-rustdoc" class="level4">
  <h4>О <code>rustdoc</code></h4>
  <p>Дистрибутив Rust включает в себя инструмент, <code>rustdoc</code>, который генерирует документацию. <code>rustdoc</code> также используется Cargo через <code>cargo doc</code>.</p>
  <p>Документация может быть сгенерирована двумя методами: из исходного кода, и из отдельных файлов в формате Markdown.</p>
  </section>
  <section id="документирование-исходного-кода" class="level4">
  <h4>Документирование исходного кода</h4>
  <p>Основной способ документирования проекта на Rust заключается в комментировании исходного кода. Для этой цели вы можете использовать документирующие комментарии:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">/// Создаёт новый `Rc&lt;T&gt;`.</span>
  <span class="co">///</span>
  <span class="co">/// # Examples</span>
  <span class="co">///</span>
  <span class="co">/// ```</span>
  <span class="co">/// use std::rc::Rc;</span>
  <span class="co">///</span>
  <span class="co">/// let five = Rc::new(5);</span>
  <span class="co">/// ```</span>
  <span class="kw">pub</span> <span class="kw">fn</span> new(value: T) -&gt; Rc&lt;T&gt; {
      <span class="co">// здесь реализация</span>
  }</code></pre>
  <p>Этот код генерирует документацию, которая выглядит <a href="http://doc.rust-lang.org/std/rc/struct.Rc.html#method.new">так</a>. В приведенном коде реализация метода была заменена на обычный комментарий. Первое, на что следует обратить внимание в этом примере, это на использование <code>///</code> вместо <code>//</code>. Символы <code>///</code> указывают, что это документирующий комментарий.</p>
  <p>Документирующие комментарии пишутся на Markdown.</p>
  <p>Rust отслеживает такие комментарии, и использует их при создании документации.</p>
  <p>При документировании таких вещей, как перечисления, нужно учитывать некоторые особенности работы <code>rustdoc</code>. Такой код работает:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">/// Тип `Option`. Подробнее смотрите [документацию уровня модуля](http://doc.rust-lang</span>
  ↳ .org/).
  <span class="kw">enum</span> <span class="kw">Option</span>&lt;T&gt; {
      <span class="co">/// Нет значения</span>
      <span class="kw">None</span>,
      <span class="co">/// Некоторое значение `T`</span>
      <span class="kw">Some</span>(T),
  }</code></pre>
  <p>А такой — нет:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">/// Тип `Option`. Подробнее смотрите [документацию уровня модуля](http://doc.rust-lang</span>
  ↳ .org/).
  <span class="kw">enum</span> <span class="kw">Option</span>&lt;T&gt; {
      <span class="kw">None</span>, <span class="co">/// Нет значения</span>
      <span class="kw">Some</span>(T), <span class="co">/// Некоторое значение `T`</span>
  }</code></pre>
  <p>Вы получите ошибку:</p>
  <pre class="text"><code>hello.rs:4:1: 4:2 error: expected ident, found `}`
  hello.rs:4 }
             ^</code></pre>
  <p>Эта досадная <a href="https://github.com/rust-lang/rust/issues/22547">ошибка</a> заключается в следующем: комментарии документации распространяются на элементы, расположенные за ними, а в данном примере нет элемента, расположенного после последнего комментария.</p>
  <section id="написание-комментариев-документации" class="level5">
  <h5>Написание комментариев документации</h5>
  <p>Давайте рассмотрим каждую часть приведенного комментария в деталях:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">/// Создаёт новый `Rc&lt;T&gt;`.</span></code></pre>
  <p>Первая строка документирующего комментария должна представлять из себя краткую информацию о функциональности. Одно предложение. Только самое основное. Высокоуровневое.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">///</span>
  <span class="co">/// Подробности создания `Rc&lt;T&gt;`, возможно, описывающие сложности семантики,</span>
  <span class="co">/// дополнительные опции, и всё остальное.</span>
  <span class="co">///</span></code></pre>
  <p>Наш исходный пример включал только строку с краткой информацией, но если бы у нас было больше информации, о которой следует сказать, мы могли бы добавить эту информацию в новом параграфе.</p>
  <section id="специальные-разделы" class="level6">
  <h6>Специальные разделы</h6>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">/// # Examples</span></code></pre>
  <p>Далее идут специальные разделы. Они обознаются заголовком, который начинается с <code>#</code>. Существуют три вида заголовков, которые обычно используются. Они не являются каким-либо специальным синтаксисом, на данный момент это просто соглашение.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">/// # Panics</span></code></pre>
  <p>Раздел <code>Panics</code>. Неустранимые ошибки при неправильном вызове функции (так называемые ошибки программирования) в Rust, как правило, вызывают панику, которая, в крайнем случае, убивает весь текущий поток (thread). Если ваша функция имеет подобное нетривиальное поведение — т.е. обнаруживает/вызывает панику, то очень важно задокументировать это.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">/// # Failures</span></code></pre>
  <p>Раздел <code>Failures</code>. Если ваша функция или метод возвращает <code>Result&lt;T, E&gt;</code>, то хорошим тоном является описание условий, при которых она возвращает <code>Err(E)</code>. Это чуть менее важно, чем описание <code>Panics</code>, потому как неудача кодируется в системе типов, но это не значит, что стоит пренебрегать данной возможностью.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">/// # Safety</span></code></pre>
  <p>Раздел <code>Safety</code>. Если ваша функция является <code>unsafe</code>, необходимо пояснить, какие инварианты вызова должны поддерживаться.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">/// # Examples</span>
  <span class="co">///</span>
  <span class="co">/// ```</span>
  <span class="co">/// use std::rc::Rc;</span>
  <span class="co">///</span>
  <span class="co">/// let five = Rc::new(5);</span>
  <span class="co">/// ```</span></code></pre>
  <p>Раздел <code>Examples</code>. Включите в этот раздел один или несколько примеров использования функции или метода, и ваши пользователи будут вам благодарны. Примеры должны размещаться внутри блоков кода, о которых мы сейчас поговорим. Этот раздел может иметь более одного подраздела:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">/// # Examples</span>
  <span class="co">///</span>
  <span class="co">/// Простые образцы типа `&amp;str`:</span>
  <span class="co">///</span>
  <span class="co">/// ```</span>
  <span class="co">/// let v: Vec&lt;&amp;str&gt; = &quot;И была у них курочка Ряба&quot;.split(' ').collect();</span>
  <span class="co">/// assert_eq!(v, vec![&quot;И&quot;, &quot;была&quot;, &quot;у&quot;, &quot;них&quot;, &quot;курочка&quot;, &quot;Ряба&quot;]);</span>
  <span class="co">/// ```</span>
  <span class="co">///</span>
  <span class="co">/// Более сложные образцы с замыканиями:</span>
  <span class="co">///</span>
  <span class="co">/// ```</span>
  <span class="co">/// let v: Vec&lt;&amp;str&gt; = &quot;абв1где2жзи&quot;.split(|c: char| c.is_numeric()).collect();</span>
  <span class="co">/// assert_eq!(v, vec![&quot;абв&quot;, &quot;где&quot;, &quot;жзи&quot;]);</span>
  <span class="co">/// ```</span></code></pre>
  <p>Давайте подробно обсудим блоки кода.</p>
  </section>
  <section id="блок-кода" class="level6">
  <h6>Блок кода</h6>
  <p>Чтобы написать код на Rust в комментарии, используйте символы ```:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">/// ```</span>
  <span class="co">/// println!(&quot;Привет, мир&quot;);</span>
  <span class="co">/// ```</span></code></pre>
  <p>Если вы хотите написать код на любом другом языке (не на Rust), вы можете добавить аннотацию:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">/// ```c</span>
  <span class="co">/// printf(&quot;Hello, world\n&quot;);</span>
  <span class="co">/// ```</span></code></pre>
  <p>Это позволит использовать подсветку синтаксиса, соответствующую тому языку, который был указан в аннотации. Если же это простой текст, то в аннотации указывается <code>text</code>.</p>
  <p>Важно выбрать правильную аннотацию, потому что <code>rustdoc</code> использует ее интересным способом: Rust может выполнять проверку работоспособности примеров на момент создания документации. Это позволяет избежать устаревания примеров. Предположим, у вас есть код на C. Если вы опустите аннотацию, указывающую, что это код на C, то <code>rustdoc</code> будет думать, что это код на Rust, поэтому он пожалуется при попытке создания документации.</p>
  </section>
  </section>
  </section>
  <section id="тесты-в-документации-1" class="level4">
  <h4>Тесты в документации</h4>
  <p>Давайте обсудим наш пример документации:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">/// ```</span>
  <span class="co">/// println!(&quot;Привет, мир&quot;);</span>
  <span class="co">/// ```</span></code></pre>
  <p>Заметьте, что здесь нет нужды в <code>fn main()</code> или чём-нибудь подобном. <code>rustdoc</code> автоматически добавит оборачивающий <code>main()</code> вокруг вашего кода в нужном месте. Например:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">/// ```</span>
  <span class="co">/// use std::rc::Rc;</span>
  <span class="co">///</span>
  <span class="co">/// let five = Rc::new(5);</span>
  <span class="co">/// ```</span></code></pre>
  <p>В конечном итоге это будет тест:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="kw">use</span> std::rc::Rc;
      <span class="kw">let</span> five = Rc::new(<span class="dv">5</span>);
  }</code></pre>
  <p>Вот полный алгоритм, который <code>rustdoc</code> использует для обработки примеров:</p>
  <ol type="1">
  <li>Любые ведущие (leading) атрибуты <code>#![foo]</code> остаются без изменений в качестве атрибутов контейнера.</li>
  <li>Будут вставлены некоторые общие атрибуты <code>allow</code>, в том числе: <code>unused_variables</code>, <code>unused_assignments</code>, <code>unused_mut</code>, <code>unused_attributes</code>, <code>dead_code</code>. Небольшие примеры часто приводят к срабатыванию этих анализов.</li>
  <li>Если пример не содержит <code>extern crate</code>, то будет вставлено <code>extern crate    &lt;mycrate&gt;;</code>.</li>
  <li>Наконец, если пример не содержит <code>fn main</code>, то оставшаяся часть текста будет обернута в <code>fn main() { your_code }</code></li>
  </ol>
  <p>Хотя иногда этого не достаточно. Например, что насчёт всех этих примеров кода с <code>///</code>, о которых мы говорили? Простой текст, обработанный <code>rustdoc</code>, выглядит так:</p>
  <pre class="text"><code>/// Некоторая документация.
  # fn foo() {}</code></pre>
  <p>А исходный текст на Rust после обработки выглядит так:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">/// Некоторая документация.</span></code></pre>
  <p>Да, именно так: вы можете добавлять строки, которые начинаются с <code>#</code>, и они будут скрыты в выводе, но при этом будут использоваться во время компиляции кода. Вы можете использовать это в своих интересах. Если в документирующем комментарии необходимо обратиться к какой-то функции, то ниже нужно будет добавить определение этой функции. В то же время, это делается только для того, чтобы удовлетворить компилятор, поэтому сокрытие ненужных строк в выводе делает пример более ясным. Вы можете использовать эту технику, чтобы детально объяснять длинные примеры, сохраняя при этом тестируемость документации. Например, вот код:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">5</span>;
  <span class="kw">let</span> y = <span class="dv">6</span>;
  <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, x + y);</code></pre>
  <p>Ниже приведено отрисованное объяснение этого кода.</p>
  <p>Сперва мы устанавливаем <code>x</code> равным пяти:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">5</span>;</code></pre>
  <p>Затем мы устанавливаем <code>y</code> равным шести:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> y = <span class="dv">6</span>;</code></pre>
  <p>В конце мы печатаем сумму <code>x</code> и <code>y</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, x + y);</code></pre>
  <p>А вот то же самое объяснение, но в виде простого текста:</p>
  <blockquote>
  <p>Сперва мы устанавливаем <code>x</code> равным пяти:</p>
  <pre class="text"><code>let x = 5;
  # let y = 6;
  # println!(&quot;{}&quot;, x + y);</code></pre>
  <p>Затем мы устанавливаем <code>y</code> равным шести:</p>
  <pre class="text"><code># let x = 5;
  let y = 6;
  # println!(&quot;{}&quot;, x + y);</code></pre>
  <p>В конце мы печатаем сумму <code>x</code> и <code>y</code>:</p>
  <pre class="text"><code># let x = 5;
  # let y = 6;
  println!(&quot;{}&quot;, x + y);</code></pre>
  </blockquote>
  <p>Повторяя все части примера, вы можете быть уверены, что ваш пример компилируется, а не просто отображает кусочки кода, которые как-то относятся к той или иной части вашего объяснения.</p>
  <section id="документирование-макросов" class="level5">
  <h5>Документирование макросов</h5>
  <p>Вот пример документирования макроса:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">/// Паниковать с данным сообщением, если только выражение не является истиной.</span>
  <span class="co">///</span>
  <span class="co">/// # Examples</span>
  <span class="co">///</span>
  <span class="co">/// ```</span>
  <span class="co">/// # #[macro_use] extern crate foo;</span>
  <span class="co">/// # fn main() {</span>
  <span class="co">/// panic_unless!(1 + 1 == 2, &quot;Математика сломалась.&quot;);</span>
  <span class="co">/// # }</span>
  <span class="co">/// ```</span>
  <span class="co">///</span>
  <span class="co">/// ```should_panic</span>
  <span class="co">/// # #[macro_use] extern crate foo;</span>
  <span class="co">/// # fn main() {</span>
  <span class="co">/// panic_unless!(true == false, &quot;Я сломан.&quot;);</span>
  <span class="co">/// # }</span>
  <span class="co">/// ```</span>
  <span class="ot">#[</span>macro_export<span class="ot">]</span>
  <span class="ot">macro_rules!</span> panic_unless {
      ($condition:expr, $($rest:expr),+) =&gt; ({ <span class="kw">if</span> ! $condition { <span class="ot">panic!</span>($($rest),+); } }
  ↳ );
  }</code></pre>
  <p>В нем вы можете заметить три вещи. Во-первых, мы должны собственноручно добавить строку с <code>extern crate</code> для того, чтобы мы могли указать атрибут <code>#[macro_use]</code>. Во-вторых, мы также собственноручно должны добавить <code>main()</code>. И наконец, разумно будет использовать <code>#</code>, чтобы закомментировать все, что мы добавили в первых двух пунктах, что бы оно не отображалось в генерируемом выводе.</p>
  </section>
  <section id="запуск-тестов-в-документации" class="level5">
  <h5>Запуск тестов в документации</h5>
  <p>Для запуска тестов можно использовать одну из двух комманд</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">rustdoc</span> --test path/to/my/crate/root.rs
  <span class="co"># или</span>
  $ <span class="kw">cargo</span> test</code></pre>
  <p>Все верно, <code>cargo test</code> также выполняет тесты, встроенные в документацию. Тем не менее, <code>cargo test</code> не будет тестировать исполняемые контейнеры, только библиотечные. Это связано с тем, как работает <code>rustdoc</code>: он компонуется с библиотекой, которую надо протестировать, но в случае с исполняемым файлом компоноваться не с чем.</p>
  <p>Есть еще несколько полезных аннотаций, которые помогают <code>rustdoc</code> работать правильно при тестировании кода:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">/// ```ignore</span>
  <span class="co">/// fn foo() {</span>
  <span class="co">/// ```</span></code></pre>
  <p>Аннотация <code>ignore</code> указывает Rust, что код должен быть проигнорирован. Почти во всех случаях это не то, что вам нужно, так как эта директива носит очень общий характер. Вместо неё лучше использовать аннотацию <code>text</code>, если это не код, или <code>#</code>, чтобы получить рабочий пример, отображающий только ту часть, которая вам нужна.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">/// ```should_panic</span>
  <span class="co">/// assert!(false);</span>
  <span class="co">/// ```</span></code></pre>
  <p>Аннотация <code>should_panic</code> указывает <code>rustdoc</code>, что код должен компилироваться, но выполнение теста должно завершиться ошибкой.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">/// ```no_run</span>
  <span class="co">/// loop {</span>
  <span class="co">///     println!(&quot;Привет, мир&quot;);</span>
  <span class="co">/// }</span>
  <span class="co">/// ```</span></code></pre>
  <p>Аннотация <code>no_run</code> указывает, что код должен компилироваться, но запускать его на выполнение не требуется. Это важно для таких примеров, которые должны успешно компилироваться, но выполнение которых оказывается бесконечным циклом! Например: «Вот как запустить сетевой сервис».</p>
  </section>
  <section id="документирование-модулей" class="level5">
  <h5>Документирование модулей</h5>
  <p>Rust предоставляет ещё один вид документирующих комментариев, <code>//!</code>. Этот комментарий относится не к следующему за ним элементу, а к элементу, который его включает. Другими словами:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">mod</span> foo {
      <span class="co">//! Это документация для модуля `foo`.</span>
      <span class="co">//!</span>
      <span class="co">//! # Examples</span>
  
      <span class="co">// ...</span>
  }</code></pre>
  <p>Приведённый пример демонстрирует наиболее распространённое использование <code>//!</code>: документирование модуля. Если же модуль расположен в файле <code>foo.rs</code>, то вы, открывая его код, часто будете видеть следующее:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">//! Модуль использования разных `foo`.</span>
  <span class="co">//!</span>
  <span class="co">//! Модуль `foo` содержит много полезной функциональности ла-ла-ла</span></code></pre>
  </section>
  <section id="стиль-документирующих-комментариев" class="level5">
  <h5>Стиль документирующих комментариев</h5>
  <p>Изучите <a href="https://github.com/rust-lang/rfcs/blob/master/text/0505-api-comment-conventions.md">RFC 505</a> для получения полных сведений о соглашениях по стилю и формату документации.</p>
  </section>
  </section>
  <section id="другая-документация" class="level4">
  <h4>Другая документация</h4>
  <p>Все эти правила поведения также применимы и в отношении исходных файлов не на Rust. Так как комментарии пишутся на Markdown, то часто эти файлы имеют расширение <code>.md</code>.</p>
  <p>Когда вы пишете документацию в файлах Markdown, вам не нужно добавлять префикс документирующего комментария, <code>///</code>. Например:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">/// # Examples</span>
  <span class="co">///</span>
  <span class="co">/// ```</span>
  <span class="co">/// use std::rc::Rc;</span>
  <span class="co">///</span>
  <span class="co">/// let five = Rc::new(5);</span>
  <span class="co">/// ```</span></code></pre>
  <p>преобразуется в</p>
  <pre class="sourceCode markdown"><code class="sourceCode markdown"><span class="fu">### Examples</span>
  
  ```
  use std::rc::Rc;
  
  let five = Rc::new(5);
  ```</code></pre>
  <p>когда он находится в файле Markdown. Однако есть один недостаток: файлы Markdown должны иметь заголовок наподобие этого:</p>
  <pre class="sourceCode markdown"><code class="sourceCode markdown">% Заголовок
  
  Это пример документации.</code></pre>
  <p>Строка, начинающаяся с <code>%</code>, должна быть самой первой строкой файла.</p>
  </section>
  <section id="атрибуты-doc" class="level4">
  <h4>Атрибуты <code>doc</code></h4>
  <p>На более глубоком уровне, комментарии документации — это синтаксический сахар для атрибутов документации:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">/// this</span>
  
  <span class="ot">#[</span>doc<span class="ot">=</span><span class="st">&quot;this&quot;</span><span class="ot">]</span></code></pre>
  <p>Т.е. представленные выше комментарии идентичны, также как и ниже:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">//! this</span>
  
  #![doc=<span class="st">&quot;/// this&quot;</span>]</code></pre>
  <p>Вы не часто будете видеть этот атрибут, используемый для написания документации, но он может быть полезен для изменения некоторых настроек, или при написании макроса.</p>
  <section id="ре-экспорт" class="level5">
  <h5>Ре-экспорт</h5>
  <p><code>rustdoc</code> будет показывать документацию для общедоступного (public) ре-экспорта в двух местах:</p>
  <pre class="ignore"><code>extern crate foo;
  
  pub use foo::bar;</code></pre>
  <p>Это создаст документацию для <code>bar</code> как в документации для контейнера <code>foo</code>, так и в документации к вашему контейнеру. То есть в обоих местах будет использована одна и та же документация.</p>
  <p>Такое поведение может быть подавлено с помощью <code>no_inline</code>:</p>
  <pre class="ignore"><code>extern crate foo;
  
  #[doc(no_inline)]
  pub use foo::bar;</code></pre>
  </section>
  <section id="управление-html" class="level5">
  <h5>Управление HTML</h5>
  <p>Вы можете управлять некоторыми аспектами HTML, который генерирует <code>rustdoc</code>, через атрибут <code>#![doc]</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">#![doc(html_logo_url = <span class="st">&quot;http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png&quot;</span>,
         html_favicon_url = <span class="st">&quot;http://www.rust-lang.org/favicon.ico&quot;</span>,
         html_root_url = <span class="st">&quot;http://doc.rust-lang.org/&quot;</span>)];</code></pre>
  <p>В этом примере устанавливается несколько различных опций: логотип, иконка и корневой URL.</p>
  </section>
  </section>
  <section id="опции-генерации" class="level4">
  <h4>Опции генерации</h4>
  <p><code>rustdoc</code> также содержит несколько опций командной строки для дальнейшей настройки:</p>
  <ul>
  <li><code>--html-in-header FILE</code>: включить содержимое FILE в конец раздела <code>&lt;head&gt;...&lt;/head&gt;</code>.</li>
  <li><code>--html-before-content FILE</code>: включить содержимое FILE сразу после <code>&lt;body&gt;</code>, перед отображаемым содержимым (в том числе строки поиска).</li>
  <li><code>--html-after-content FILE</code>: включить содержимое FILE после всего отображаемого содержимого.</li>
  </ul>
  </section>
  <section id="замечание-по-безопасности" class="level4">
  <h4>Замечание по безопасности</h4>
  <p>Комментарии в документации в формате Markdown помещаются в конечную веб-страницу без обработки. Будьте осторожны с HTML-литералами:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">/// &lt;script&gt;alert(document.cookie)&lt;/script&gt;</span></code></pre>
  </section>
  </section>
  <section id="sec--iterators" class="level2">
  <h2>Итераторы</h2>
  <p>Давайте поговорим о циклах.</p>
  <p>Помните цикл <code>for</code> в Rust? Вот пример:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">for</span> x in <span class="dv">0.</span>.<span class="dv">10</span> {
      <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, x);
  }</code></pre>
  <p>Теперь, когда вы знаете о Rust немного больше, мы можем детально обсудить, как же это работает. Диапазоны (<code>0..10</code>) являются «итераторами». Итератор — это сущность, для которой мы можем неоднократно вызвать метод <code>.next()</code>, в результате чего мы получим последовательность элементов.</p>
  <p>Как представлено ниже:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> range = <span class="dv">0.</span>.<span class="dv">10</span>;
  
  <span class="kw">loop</span> {
      <span class="kw">match</span> range.next() {
          <span class="kw">Some</span>(x) =&gt; {
              <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, x);
          },
          <span class="kw">None</span> =&gt; { <span class="kw">break</span> }
      }
  }</code></pre>
  <p>Мы связываем с диапазоном изменяемое имя, которая и является нашим итератором. Затем мы используем цикл <code>loop</code> с внутренней конструкцией <code>match</code>. Здесь <code>match</code> применяется к результату <code>range.next()</code>, который выдает нам ссылку на следующее значение итератора. В данном случае <code>next</code> возвращает <code>Option&lt;i32&gt;</code>, который представляет собой <code>Some(i32)</code> когда у нас есть значение и <code>None</code> когда перебор элементов закончен. Если мы получаем <code>Some(i32)</code>, то печатаем его, а если <code>None</code>, то прекращаем выполнение цикла оператором <code>break</code>.</p>
  <p>Этот пример, по большому счету, делает то же самое, что и пример с циклом <code>for</code>. Цикл <code>for</code> — просто удобный способ записи конструкции <code>loop</code>/<code>match</code>/<code>break</code>.</p>
  <p>Однако, цикл <code>for</code> не является единственной конструкцией, которая использует итераторы. Написание своего собственного итератора заключается в реализации типажа <code>Iterator</code>. Хотя эта тема и выходит за рамки данного руководства, Rust предоставляет ряд полезных итераторов для выполнения различных задач. Прежде чем мы поговорим о них, мы должны рассказать о плохой практике в Rust, связанной с использованием диапазонов. Она продемонстрирована в примере ниже.</p>
  <p>Вот, только что мы говорили о том, какие диапазоны крутые. Но диапазоны также и очень примитивны. Например, если вам нужно перебрать содержимое вектора, у вас может возникнуть желание написать так:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> nums = <span class="ot">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  
  <span class="kw">for</span> i in <span class="dv">0.</span>.nums.len() {
      <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, nums[i]);
  }</code></pre>
  <p>Это намного хуже, чем если бы мы использовали итератор непосредственно. Вы можете пройти по элементам векторов напрямую, как показано ниже:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> nums = <span class="ot">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  
  <span class="kw">for</span> num in &amp;nums {
      <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, num);
  }</code></pre>
  <p>Есть две причины предпочесть прямое использование итератора. Во-первых, это яснее выражает наше намерение. Мы обходим элементы вектора, а не индексы с последующей индексацией вектора. Во-вторых, эта версия является более эффективной: первая версия будет выполнять дополнительные проверки границ, потому что используется индексация, <code>nums[i]</code>. Во втором примере нет никаких проверок границ, поскольку мы получаем ссылки на каждый элемент вектора, одну за одной, по мере итерирования. Это очень распространенный прием работы с итераторами: мы можем игнорировать ненужные проверки границ, но все еще быть уверенными, что мы в безопасности.</p>
  <p>Остается неясной еще одна деталь работы <code>println!</code>. На самом деле <code>num</code> имеет тип <code>&amp;i32</code>. То есть, это ссылка на <code>i32</code>, а не сам <code>i32</code>. <code>println!</code> выполняет разыменование переменной за нас, поэтому мы не видим его в исходном коде. Этот код также прекрасно работает:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> nums = <span class="ot">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  
  <span class="kw">for</span> num in &amp;nums {
      <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, *num);
  }</code></pre>
  <p>Здесь мы явно разыменовываем <code>num</code>. Почему <code>&amp;nums</code> выдает нам ссылки? Во-первых, потому что мы явно попросили его об этом с помощью <code>&amp;</code>. Во-вторых, если он будет выдавать нам сами данные, то мы должны быть их владельцем, что подразумевает создание копии данных и выдачу этой копии нам. Со ссылками же мы просто заимствуем ссылку на данные, и поэтому будет выдана просто ссылка, без необходимости перемещать данные.</p>
  <p>Теперь, когда мы установили, что зачастую диапазоны — это не то, что нужно, давайте поговорим о том, что же можно использовать вместо диапазонов.</p>
  <p>Есть три основных класса объектов, которые имеют отношение к данному вопросу: <em>итераторы</em>, <em>адаптеры итераторов</em> и <em>потребители</em>. Вот некоторые определения:</p>
  <ul>
  <li><em>итераторы</em> выдают последовательность значений;</li>
  <li><em>адаптеры итераторов</em> применяются к итератору и выдают новый итератор с другой выходной последовательностью;</li>
  <li><em>потребители</em> применяются к итератору, выдающему некоторый конечный набор значений.</li>
  </ul>
  <p>Давайте сначала поговорим о потребителях, так как итераторы вы уже видели — это диапазоны.</p>
  <section id="потребители" class="level4">
  <h4>Потребители</h4>
  <p><em>Потребитель</em> применяется к итератору, возвращая какое-то значение или значения. Наиболее распространенным потребителем является <code>collect()</code>. Этот код не компилируется, но он показывает идею:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> one_to_one_hundred = (<span class="dv">1.</span>.<span class="dv">101</span>).collect();</code></pre>
  <p>Как вы можете видеть, мы вызываем <code>collect()</code> для нашего итератора. <code>collect()</code> принимает столько значений, сколько выдаст итератор, и возвращает коллекцию результатов. Так почему же этот код не компилируется? Rust не может определить, в какую коллекцию (например, вектор, список, и т.д.) вы хотите собрать элементы, и поэтому тип необходимо указать явно. Вот версия, которая компилируется:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> one_to_one_hundred = (<span class="dv">1.</span>.<span class="dv">101</span>).collect::&lt;Vec&lt;<span class="kw">i32</span>&gt;&gt;();</code></pre>
  <p>Если помните, синтаксис <code>::&lt;&gt;</code> позволяет задать подсказку типа. Поэтому в приведенном примере мы указали, что хотим вектор целых чисел. Хотя не всегда бывает нужно задавать весь тип целиком. Использование символа <code>_</code> позволит вам задать частичную подсказку типа:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> one_to_one_hundred = (<span class="dv">1.</span>.<span class="dv">101</span>).collect::&lt;Vec&lt;_&gt;&gt;();</code></pre>
  <p>Эта запись говорит компилятору Rust: «Пожалуйста, собери элементы в <code>Vec&lt;T&gt;</code>, а вывод типа <code>T</code> сделай самостоятельно». По этой причине символ <code>_</code> иногда называют «заполнителем типа».</p>
  <p><code>collect()</code> является наиболее распространенным из потребителей, но есть и другие. Например <code>find()</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> greater_than_forty_two = (<span class="dv">0.</span>.<span class="dv">100</span>)
                               .find(|x| *x &gt; <span class="dv">42</span>);
  
  <span class="kw">match</span> greater_than_forty_two {
      <span class="kw">Some</span>(_) =&gt; <span class="ot">println!</span>(<span class="st">&quot;У нас есть несколько чисел!&quot;</span>),
      <span class="kw">None</span> =&gt; <span class="ot">println!</span>(<span class="st">&quot;Числа не найдены :(&quot;</span>),
  }</code></pre>
  <p><code>find</code> принимает замыкание, которое обрабатывает ссылку на каждый элемент итератора. Замыкание возвращает <code>true</code>, если элемент является искомым элементом, и <code>false</code> в противном случае. Так как нам не всегда удается найти соответствующий элемент, <code>find</code> возвращает <code>Option</code>, а не сам элемент.</p>
  <p>Еще один важный потребитель — <code>fold</code>. Вот как он выглядит:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> sum = (<span class="dv">1.</span>.<span class="dv">4</span>).fold(<span class="dv">0</span>, |sum, x| sum + x);</code></pre>
  <p><code>fold()</code> — это потребитель, который схематично можно представить в виде: <code>fold(base, |accumulator, element| ...)</code>. Он принимает два аргумента: первый - это элемент, называемый <em>базой</em>; второй — это замыкание, которое, в свою очередь, само принимает два аргумента: первый называется <em>аккумулятор</em>, а второй - <em>элемент</em>. На каждой итерации вызывается замыкание, результат выполнения которого становится значением аккумулятора на следующей итерации. На первой итерации значение аккумулятора равно базе.</p>
  <p>Это немного запутанно. Давайте рассмотрим значения всех элементов итератора:</p>
  <table>
  <thead>
  <tr class="header">
  <th style="text-align: left;">база</th>
  <th style="text-align: left;">аккумулятор</th>
  <th style="text-align: left;">элемент</th>
  <th style="text-align: left;">результат замыкания</th>
  </tr>
  </thead>
  <tbody>
  <tr class="odd">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">1</td>
  </tr>
  <tr class="even">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">1</td>
  <td style="text-align: left;">2</td>
  <td style="text-align: left;">3</td>
  </tr>
  <tr class="odd">
  <td style="text-align: left;">0</td>
  <td style="text-align: left;">3</td>
  <td style="text-align: left;">3</td>
  <td style="text-align: left;">6</td>
  </tr>
  </tbody>
  </table>
  <p>Мы вызвали <code>fold()</code> с этими аргументами:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">.fold(<span class="dv">0</span>, |sum, x| sum + x);</code></pre>
  <p>Таким образом, <code>0</code> — это база, <code>sum</code> — это аккумулятор, а <code>x</code> — это элемент. На первой итерации мы устанавливаем <code>sum</code> равной <code>0</code>, а <code>x</code> становится первым элементом <code>nums</code>, <code>1</code>. Затем мы прибавляем <code>x</code> к <code>sum</code>, что дает нам <code>0 + 1 = 1</code>. На второй итерации это значение становится значением аккумулятора, <code>sum</code>, а элемент становится вторым элементом массива, <code>2</code>. <code>1 + 2 = 3</code>, результат этого выражения становится значением аккумулятора на последней итерации. На этой итерации, <code>x</code> становится последним элементом, <code>3</code>, а значение выражения <code>3 + 3 = 6</code> является конечным значением нашей суммы. <code>1 + 2 + 3 = 6</code> — это результат, который мы получили.</p>
  <p>Вот так. <code>fold</code> может показаться немного странным, если вы используете его впервые, но когда вы освоите его, то будете использовать его повсеместно. <code>fold</code> подходит для случаев, когда у вас есть список элементов, а вам нужно получить один единственный результат.</p>
  <p>Потребители имеют очень большое значение в связи с одним свойством итераторов, о котором мы еще не говорили: ленивость. Давайте ещё немного поговорим об итераторах, и вы поймете, почему потребители так важны.</p>
  </section>
  <section id="итераторы" class="level4">
  <h4>Итераторы</h4>
  <p>Как мы уже говорили ранее, итератор являются сущностью, для которой мы можем неоднократно вызвать метод <code>.next()</code>, в результате чего мы получим последовательность элементов. Для получения каждого следующего элемента нужно вызвать метод, а это означает, что итераторы <em>ленивы</em> — они не обязаны создавать все значения заранее. Например, этот код на самом деле не генерирует номера <code>1-99</code>, а просто создает значение, представляющее эту последовательность:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> nums = <span class="dv">1.</span>.<span class="dv">100</span>;</code></pre>
  <p>В этом примере мы никак не использовали диапазон, поэтому он и не создавал последовательность. Давайте добавим потребителя:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> nums = (<span class="dv">1.</span>.<span class="dv">100</span>).collect::&lt;Vec&lt;<span class="kw">i32</span>&gt;&gt;();</code></pre>
  <p>Теперь <code>collect()</code> потребует, чтобы диапазон выдавал ему какие-нибудь числа, поэтому он сгенерирует последовательность.</p>
  <p>Диапазоны — это один из двух основных типов итераторов. Другой часто используемый итератор — <code>iter()</code>. <code>iter()</code> может преобразовать вектор в простой итератор, который выдает вам каждый элемент по очереди:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> nums = <span class="ot">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  
  <span class="kw">for</span> num in nums.iter() {
     <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, num);
  }</code></pre>
  <p>Эти два основных итератора хорошо послужат вам. Есть и более продвинутые итераторы, в том числе и те, которые генерируют бесконечную последовательность.</p>
  <p>Вот и все, что касается итераторов. Последнее понятие в этой теме, о котором мы хотели бы рассказать — адаптеры итераторов. Давайте перейдем к нему!</p>
  </section>
  <section id="адаптеры-итераторов" class="level4">
  <h4>Адаптеры итераторов</h4>
  <p><em>Адаптеры итераторов</em> получают итератор и изменяют его каким-то образом, выдавая новый итератор. Простейший из них называется <code>map</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">(<span class="dv">1.</span>.<span class="dv">100</span>).map(|x| x + <span class="dv">1</span>);</code></pre>
  <p><code>map</code> вызывается для итератора, и создает новый итератор, каждый элемент которого получается в результате вызова замыкания, в качестве аргумента которому передается ссылка на исходный элемент. Так что этот код выдаст нам числа <code>2-100</code>. Ну, почти! Если вы скомпилируете пример, этот код выдаст предупреждение:</p>
  <pre class="text"><code>warning: unused result which must be used: iterator adaptors are lazy and
           do nothing unless consumed, #[warn(unused_must_use)] on by default
  (1..100).map(|x| x + 1);
   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</code></pre>
  <p>Причина этого — ленивость итераторов! То замыкание никогда не будет выполнено. Пример ниже не напечатает ни одного значения:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">(<span class="dv">1.</span>.<span class="dv">100</span>).map(|x| <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, x));</code></pre>
  <p>Если вы пытаетесь выполнить замыкание ради побочных эффектов (вроде печати), то вместо этого просто используйте <code>for</code>.</p>
  <p>Есть масса интересных адаптеров итераторов. <code>take(n)</code> вернет итератор, представляющий следующие <code>n</code> элементов исходного итератора. Обратите внимание, что это не оказывает никакого влияния на оригинальный итератор. Давайте попробуем применить его для бесконечных итераторов, которые мы упоминали раньше:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">for</span> i in (<span class="dv">1.</span>.).step_by(<span class="dv">5</span>).take(<span class="dv">5</span>) {
      <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, i);
  }</code></pre>
  <p>Этот код напечатает</p>
  <pre class="text"><code>1
  6
  11
  16
  21</code></pre>
  <p><code>filter()</code> представляет собой адаптер, который принимает замыкание в качестве аргумента. Это замыкание возвращает <code>true</code> или <code>false</code>. Новый итератор, полученный применением <code>filter()</code>, будет выдавать только те элементы, для которых замыкание возвращает <code>true</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">for</span> i in (<span class="dv">1.</span>.<span class="dv">100</span>).filter(|&amp;x| x % <span class="dv">2</span> == <span class="dv">0</span>) {
      <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, i);
  }</code></pre>
  <p>Этот пример будет печатать все четные числа от одного до ста. (Обратите внимание, что мы используем образец <code>&amp;x</code>, чтобы извлечь само целое число. Это необходимо, поскольку <code>filter</code> не потребляет элементы, которые выдаются во время итерации, а лишь выдаёт ссылку.)</p>
  <p>Вы можете соединить все три понятия вместе: начать с итератора, адаптировать его несколько раз, а затем потребить результат. Например:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">(<span class="dv">1.</span>.)
      .filter(|&amp;x| x % <span class="dv">2</span> == <span class="dv">0</span>)
      .filter(|&amp;x| x % <span class="dv">3</span> == <span class="dv">0</span>)
      .take(<span class="dv">5</span>)
      .collect::&lt;Vec&lt;<span class="kw">i32</span>&gt;&gt;();</code></pre>
  <p>Этот код выдаст вектор, содержащий <code>6</code>, <code>12</code>, <code>18</code>, <code>24</code>, <code>30</code>.</p>
  <p>Это просто небольшой обзор того, как итераторы, адаптеры итераторов и потребители могут помочь вам. Уже написано множество действительно полезных итераторов, и вы также можете написать свой собственный итератор. Итераторы обеспечивают безопасный и эффективный способ работы со всеми видами списков. Сперва работать с ними немного непривычно, но чем больше вы с ними сталкиваетесь, тем больше они вас цепляют. Для получения полного списка различных итераторов, адаптеров и потребителей смотрите <a href="http://doc.rust-lang.org/std/iter/index.html">документацию модуля iter</a>.</p>
  </section>
  </section>
  <section id="sec--concurrency" class="level2">
  <h2>Многозадачность</h2>
  <p>Многозадачность и параллелизм являются невероятно важными проблемами в информатике. Это актуальная тема для современной индустрии. У компьютеров все больше и больше ядер, но многие программисты не готовы в полной мере использовать их.</p>
  <p>Средства Rust для безопасной работы с памятью в полной мере применимы и при работе в многозадачной среде. Даже многозадачные программы на Rust должны безопасно работать с памятью, и не создавать состояний гонок по данным. Система типов Rust достаточно мощна, чтобы справиться с этими задачами на этапе компиляции.</p>
  <p>Прежде чем мы поговорим об особенностях многозадачности в Rust, важно понять вот что: Rust — достаточно низкоуровневый язык, поэтому вся поддержка многозадачности реализована в стандартной библиотеке, а не в самом языке. Это означает, что если вам не нравится какой-то аспект реализации многозадачности в Rust, вы всегда можете создать альтернативную библиотеку. <a href="https://github.com/carllerche/mio">mio</a> — реально существующий пример такого подхода.</p>
  <section id="справочная-информация-send-и-sync" class="level4">
  <h4>Справочная информация: <code>Send</code> и <code>Sync</code></h4>
  <p>Рассуждать о многозадачности довольно трудно. Rust строго статически типизирован, и это помогает нам делать выводы о коде. В связи с этим Rust предоставляет два типажа, помогающих нам разбираться в любом коде, который вообще может быть многозадачным.</p>
  <section id="send" class="level5">
  <h5><code>Send</code></h5>
  <p>Первый типаж, о котором мы будем говорить, называется <a href="http://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a>. Когда тип <code>T</code> реализует <code>Send</code>, это указывает компилятору, что владение переменными этого типа можно безопасно перемещать между потоками.</p>
  <p>Это важно для соблюдения некоторых ограничений. Например, это имеет значение, когда у нас есть канал, соединяющий два потока, и мы хотим отправлять некоторые данные по каналу из одного потока в другой. Следовательно, мы должны гарантировать, что для отправляемого типа данных реализован типаж <code>Send</code>.</p>
  <p>И наоборот, если мы оборачиваем библиотеку чужого кода (FFI), и она не является потокобезопасной, то нам не следует реализовывать типаж <code>Send</code>, и компилятор поможет нам убедиться в невозможности покинуть текущий поток.</p>
  </section>
  <section id="sync" class="level5">
  <h5><code>Sync</code></h5>
  <p>Второй из этих типажей называется <a href="http://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a>. Когда тип <code>T</code> реализует <code>Sync</code>, это указывает компилятору, что использование переменных этого типа не приводит к небезопасной работе с памятью в многопоточной среде.</p>
  <p>Например, совместное использование неизменяемых данных с помощью атомарного счетчика ссылок является потокобезопасным. Rust обеспечивает такой тип, <code>Arc&lt;T&gt;</code>, и он реализует <code>Sync</code>, так что при помощи этого типа можно безопасно обмениваться данными между потоками.</p>
  <p>Эти два типажа позволяют использовать систему типов, чтобы получить надежные гарантии о свойствах вашего кода в условиях многозадачности. Прежде чем мы покажем, как этого достигнуть, сначала мы должны узнать, как вообще написать многозадачную программу в Rust!</p>
  </section>
  </section>
  <section id="потоки" class="level4">
  <h4>Потоки</h4>
  <p>Стандартная библиотека Rust предоставляет библиотеку многопоточности, которая позволяет запускать код на Rust параллельно. Вот простой пример использования <code>std::thread</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::thread;
  
  <span class="kw">fn</span> main() {
      thread::spawn(|| {
          <span class="ot">println!</span>(<span class="st">&quot;Hello from a thread!&quot;</span>);
      });
  }</code></pre>
  <p>Метод <code>thread::spawn()</code> в качестве единственного аргумента принимает замыкание, которое выполняется в новом потоке. Он возвращает дескриптор потока, который используется для ожидания завершения этого потока и извлечения его результата:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::thread;
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> handle = thread::spawn(|| {
          <span class="st">&quot;Hello from a thread!&quot;</span>
      });
  
      <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, handle.join().unwrap());
  }</code></pre>
  <p>Многие языки имеют возможность выполнять потоки, но это дико опасно. Есть целые книги о том, как избежать ошибок, которые происходят от совместного использования изменяемого состояния. В Rust снова помогает система типов, которая предотвращает гонки данных на этапе компиляции. Давайте поговорим о том, как же на самом деле обеспечивается совместное использование чего-либо в условиях нескольких потоков.</p>
  </section>
  <section id="безопасное-совместное-использование-изменяемого-состояния" class="level4">
  <h4>Безопасное совместное использование изменяемого состояния</h4>
  <p>Вчитайтесь: «безопасное совместное использование изменяемого состояния». Похоже на ложь, не так ли? Многие программисты считают, что организовать многопоточную работу с изменяемым состоянием очень сложно и почти невозможно. Но благодаря системе типов Rust, это всё же правда — безопасно работать с изменяемыми данными можно.</p>
  <p>Кто-то однажды сказал это:</p>
  <blockquote>
  <p>Совместно используемое изменяемое состояние является корнем всех зол. Большинство языков пытаются решить эту проблему через часть, отвечающую за «изменяемое», но Rust решает ее через часть, отвечающую за «совместно используемое».</p>
  </blockquote>
  <p>Та же самая <a href="#sec--ownership">система владения</a>, которая помогает предотвратить неправильное использование указателей, также помогает исключить гонки по данным, один из худших видов ошибок многозадачности.</p>
  <p>В качестве примера приведем программу на Rust, которая входила бы в состояние гонки по данным на многих языках. На Rust она не скомпилируется:</p>
  <pre class="ignore"><code>use std::thread;
  
  fn main() {
      let mut data = vec![1u32, 2, 3];
  
      for i in 0..3 {
          thread::spawn(move || {
              data[i] += 1;
          });
      }
  
      thread::sleep_ms(50);
  }</code></pre>
  <p>Она выдает ошибку:</p>
  <pre class="text"><code>8:17 error: capture of moved value: `data`
          data[i] += 1;
          ^~~~</code></pre>
  <p>В данном случае мы знаем, что наш код <em>должен</em> быть безопасным, но Rust в этом не уверен. И, на самом деле, он не является безопасным: мы работаем с <code>data</code> в каждом потоке. При этом, поток становится владельцем того, что он получает как часть окружения замыкания. А это значит, что у нас есть три владельца! Это плохо. Мы можем исправить это с помощью типа <code>Arc&lt;T&gt;</code>, который является атомарным указателем со счетчиком ссылок. «Атомарный» означает, что им безопасно обмениваться между потоками.</p>
  <p>Чтобы гарантировать, что его можно безопасно использовать из нескольких потоков, <code>Arc&lt;T&gt;</code> предполагает наличие еще одного свойства у вложенного типа. Он предполагает, что <code>T</code> реализует типаж <code>Sync</code>. В нашем случае мы также хотим, чтобы была возможность изменять вложенное значение. Нам нужен тип, который может обеспечить изменение своего содержимого лишь одним пользователем одновременно. Для этого мы можем использовать тип <code>Mutex&lt;T&gt;</code>. Вот вторая версия нашего кода. Она по-прежнему не работает, но по другой причине:</p>
  <pre class="ignore"><code>use std::thread;
  use std::sync::Mutex;
  
  fn main() {
      let mut data = Mutex::new(vec![1u32, 2, 3]);
  
      for i in 0..3 {
          let data = data.lock().unwrap();
          thread::spawn(move || {
              data[i] += 1;
          });
      }
  
      thread::sleep_ms(50);
  }</code></pre>
  <p>Вот ошибка:</p>
  <pre class="text"><code>&lt;anon&gt;:9:9: 9:22 error: the trait `core::marker::Send` is not implemented for the type
  ↳  `std::sync::mutex::MutexGuard&lt;'_, collections::vec::Vec&lt;u32&gt;&gt;` [E0277]
  &lt;anon&gt;:11         thread::spawn(move || {
                    ^~~~~~~~~~~~~
  &lt;anon&gt;:9:9: 9:22 note: `std::sync::mutex::MutexGuard&lt;'_, collections::vec::Vec&lt;u32&gt;&gt;` 
  ↳ cannot be sent between threads safely
  &lt;anon&gt;:11         thread::spawn(move || {
                    ^~~~~~~~~~~~~</code></pre>
  <p>Вы можете видеть, что <a href="http://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a> содержит метод <a href="http://doc.rust-lang.org/std/sync/struct.Mutex.html#method.lock"><code>lock</code></a>, который имеет следующую сигнатуру:</p>
  <pre class="ignore"><code>fn lock(&amp;self) -&gt; LockResult&lt;MutexGuard&lt;T&gt;&gt;</code></pre>
  <p>Так как типаж <code>Send</code> не был реализован для <code>MutexGuard&lt;T&gt;</code>, мы не можем перемещать охранное значение мьютекса через границы потоков, что и сказано в сообщении об ошибке.</p>
  <p>Мы можем использовать <code>Arc&lt;T&gt;</code>, чтобы исправить это. Вот рабочая версия:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::sync::{Arc, Mutex};
  <span class="kw">use</span> std::thread;
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> data = Arc::new(Mutex::new(<span class="ot">vec!</span>[<span class="dv">1u32</span>, <span class="dv">2</span>, <span class="dv">3</span>]));
  
      <span class="kw">for</span> i in <span class="dv">0.</span>.<span class="dv">3</span> {
          <span class="kw">let</span> data = data.clone();
          thread::spawn(move || {
              <span class="kw">let</span> <span class="kw">mut</span> data = data.lock().unwrap();
              data[i] += <span class="dv">1</span>;
          });
      }
  
      thread::sleep_ms(<span class="dv">50</span>);
  }</code></pre>
  <p>Теперь мы вызываем <code>clone()</code> для нашего <code>Arc</code>, что увеличивает внутренний счетчик. Затем полученная ссылка перемещается в новый поток. Давайте более подробно рассмотрим тело потока:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">thread::spawn(move || {
      <span class="kw">let</span> <span class="kw">mut</span> data = data.lock().unwrap();
      data[i] += <span class="dv">1</span>;
  });</code></pre>
  <p>Во-первых, мы вызываем метод <code>lock()</code>, который захватывает блокировку мьютекса. Так как вызов данного метода может потерпеть неудачу, он возвращает <code>Result&lt;T, E&gt;</code>, но, поскольку это просто пример, мы используем <code>unwrap()</code>, чтобы получить ссылку на данные. Реальный код должен иметь более надежную обработку ошибок в такой ситуации. После этого мы свободно изменяем данные, так как у нас есть блокировка.</p>
  <p>Под конец мы ждём какое-то время, пока потоки отработают. Это не идеальный способ дождаться окончания их работы: возможно, мы выбрали разумное время ожидания но, скорее всего, мы будем ждать либо больше чем нужно, либо меньше чем нужно, в зависимости от того, сколько на самом деле времени потребуется потокам, чтобы закончить вычисления.</p>
  <p>Есть более точные способы синхронизации потоков, и несколько из них реализовано в стандартной библиотеке Rust. Давайте поговорим об одном из них: каналах.</p>
  </section>
  <section id="каналы" class="level4">
  <h4>Каналы</h4>
  <p>Вот версия нашего кода, которая использует для синхронизации каналы, вместо того, чтобы ждать в течение определенного времени:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::sync::{Arc, Mutex};
  <span class="kw">use</span> std::thread;
  <span class="kw">use</span> std::sync::mpsc;
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> data = Arc::new(Mutex::new(<span class="dv">0u32</span>));
  
      <span class="kw">let</span> (tx, rx) = mpsc::channel();
  
      <span class="kw">for</span> _ in <span class="dv">0.</span>.<span class="dv">10</span> {
          <span class="kw">let</span> (data, tx) = (data.clone(), tx.clone());
  
          thread::spawn(move || {
              <span class="kw">let</span> <span class="kw">mut</span> data = data.lock().unwrap();
              *data += <span class="dv">1</span>;
  
              tx.send(());
          });
      }
  
      <span class="kw">for</span> _ in <span class="dv">0.</span>.<span class="dv">10</span> {
          rx.recv();
      }
  }</code></pre>
  <p>Мы используем метод <code>mpsc::channel()</code>, чтобы создать новый канал. В этом примере мы в каждом из десяти потоков вызываем метод <code>send</code>, который передает по каналу пустой кортеж <code>()</code>, а затем в главном потоке ждем, пока не будут приняты все десять значений.</p>
  <p>Хотя по этому каналу посылается просто сигнал (пустой кортеж <code>()</code> не несёт никаких данных), в общем случае мы можем отправить по каналу любое значение, которое реализует типаж <code>Send</code>!</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::thread;
  <span class="kw">use</span> std::sync::mpsc;
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> (tx, rx) = mpsc::channel();
  
      <span class="kw">for</span> _ in <span class="dv">0.</span>.<span class="dv">10</span> {
          <span class="kw">let</span> tx = tx.clone();
  
          thread::spawn(move || {
              <span class="kw">let</span> answer = <span class="dv">42u32</span>;
  
              tx.send(answer);
          });
      }
  
     rx.recv().ok().expect(<span class="st">&quot;Could not receive answer&quot;</span>);
  }</code></pre>
  <p><code>u32</code> реализует <code>Send</code>, потому что мы можем сделать копию. Итак, создаётся поток, в котором вычисляется ответ, а затем этот ответ с помощью метода <code>send()</code> передаётся обратно по каналу.</p>
  </section>
  <section id="паника" class="level4">
  <h4>Паника</h4>
  <p><code>panic!</code> аварийно завершает выполняемый в данный момент поток. Вы можете использовать потоки Rust как простой механизм изоляции:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::thread;
  
  <span class="kw">let</span> result = thread::spawn(move || {
      <span class="ot">panic!</span>(<span class="st">&quot;oops!&quot;</span>);
  }).join();
  
  <span class="ot">assert!</span>(result.is_err());</code></pre>
  <p>Используемый в коде выше метод <code>join()</code> структуры <code>Thread</code> возвращает <code>Result</code>, что позволяет нам проверить, паниковал ли поток, или он завершился нормально.</p>
  </section>
  </section>
  <section id="sec--error-handling" class="level2">
  <h2>Обработка ошибок</h2>
  <p>Как и многие языки программирования, Rust призывает разработчика определенным способом обрабатывать ошибки. Вообще, существует два общих подхода обработки ошибок: с помощью исключений и через возвращаемые значения. И Rust предпочитает возвращаемые значения.</p>
  <p>В этой главе мы намерены подробно изложить работу с ошибками в Rust. Более того, мы попробуем раз за разом погружаться в обработку ошибок с различных сторон, так что под конец у вас будет уверенное практическое представление о том, как все это сходится воедино.</p>
  <p>В наивной реализации обработка ошибок в Rust может выглядеть многословной и раздражающей. Мы рассмотрим основные камни преткновения, а также продемонстрируем, как сделать обработку ошибок лаконичной и удобной, пользуясь стандартной библиотекой.</p>
  <section id="содержание" class="level3">
  <h3>Содержание</h3>
  <p>Эта глава очень длинная, в основном потому, что мы начнем с самого начала — рассмотрения типов-сумм (sum type) и комбинаторов, и далее попытаемся последовательно объяснить подход Rust к обработке ошибок. Так что разработчики, которые имеют опыт работы с другими выразительными системами типов, могут свободно перескакивать от раздела к разделу.</p>
  <ul>
  <li><a href="#the-basics">Основы</a>
  <ul>
  <li><a href="#unwrapping-explained">Объяснение <code>unwrap</code></a></li>
  <li><a href="#the-option-type">Тип <code>Option</code></a>
  <ul>
  <li><a href="#composing-optiont-values">Совмещение значений <code>Option&lt;T&gt;</code></a></li>
  </ul></li>
  <li><a href="#the-result-type">Тип <code>Result</code></a>
  <ul>
  <li><a href="#parsing-integers">Преобразование строки в число</a></li>
  <li><a href="#the-result-type-alias-idiom">Создание псевдонима типа <code>Result</code></a></li>
  </ul></li>
  <li><a href="#a-brief-interlude-unwrapping-isnt-evil">Короткое отступление: <code>unwrap</code> — не обязательно зло</a></li>
  </ul></li>
  <li><a href="#working-with-multiple-error-types">Работа с несколькими типами ошибок</a>
  <ul>
  <li><a href="#composing-option-and-result">Совмещение <code>Option</code> и <code>Result</code></a></li>
  <li><a href="#the-limits-of-combinators">Ограничения комбинаторов</a></li>
  <li><a href="#early-returns">Преждевременный <code>return</code></a></li>
  <li><a href="#the-try-macro">Макрос <code>try!</code></a></li>
  <li><a href="#defining-your-own-error-type">Объявление собственного типа ошибки</a></li>
  </ul></li>
  <li><a href="#standard-library-traits-used-for-error-handling">Типажи из стандартной библиотеки, используемые для обработки ошибок</a>
  <ul>
  <li><a href="#the-error-trait">Типаж <code>Error</code></a></li>
  <li><a href="#the-from-trait">Типаж <code>From</code></a></li>
  <li><a href="#the-real-try-macro">Настоящий макрос <code>try!</code></a></li>
  <li><a href="#composing-custom-error-types">Совмещение собственных типов ошибок</a></li>
  <li><a href="#advice-for-library-writers">Рекомендации для авторов библиотек</a></li>
  </ul></li>
  <li>Практический пример: Программа для чтения демографических данных</li>
  <li><a href="#the-short-story">Заключение</a></li>
  </ul>
  <p><a name="the-basics"></a></p>
  </section>
  <section id="основы" class="level3">
  <h3>Основы</h3>
  <p>Обработку ошибок можно рассматривать как <em>вариативный анализ</em> того, было ли некоторое вычисление выполнено успешно или нет. Как будет показано далее, ключом к удобству обработки ошибок является сокращение количества явного вариативного анализа, который должен выполнять разработчик, сохраняя при этом код легко сочетаемым с другим кодом (composability).</p>
  <p><em>(Примечание переводчика: Вариативный анализ – это один из наиболее общеприменимых методов аналитического мышления, который заключается в рассмотрении проблемы, вопроса или некоторой ситуации с точки зрения каждого возможного конкретного случая. При этом рассмотрение по отдельности каждого такого случая является достаточным для того, чтобы решить первоначальный вопрос.</em></p>
  <p><em>Важным аспектом такого подхода к решению проблем является то, что такой анализ должен быть исчерпывающим (exhaustive). Другими словами, при использовании вариативного анализа должны быть рассмотрены все возможные случаи.</em></p>
  <p><em>В Rust вариативный анализ реализуется с помощью синтаксической конструкции <a href="#sec--match"><code>match</code></a>. При этом компилятор гарантирует, что такой анализ будет исчерпывающим: если разработчик не рассмотрит все возможные варианты заданного значения, программа не будет скомпилирована.)</em></p>
  <p>Сохранять сочетаемость кода важно, потому что без этого требования мы могли бы просто получать <a href="http://doc.rust-lang.org/std/macro.panic!.html"><code>panic</code></a> всякий раз, когда мы сталкивались бы с чем-то неожиданным. (<code>panic</code> вызывает прерывание текущего потока и, в большинстве случаев, приводит к завершению всей программы.) Вот пример:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">// Попробуйте угадать число от 1 до 10.</span>
  <span class="co">// Если заданное число соответствует тому, что мы загадали, возвращается true.</span>
  <span class="co">// В противном случае возвращается false.</span>
  <span class="kw">fn</span> guess(n: <span class="kw">i32</span>) -&gt; <span class="kw">bool</span> {
      <span class="kw">if</span> n &lt; <span class="dv">1</span> || n &gt; <span class="dv">10</span> {
          <span class="ot">panic!</span>(<span class="st">&quot;Неверное число: {}&quot;</span>, n);
      }
      n == <span class="dv">5</span>
  }
  
  <span class="kw">fn</span> main() {
      guess(<span class="dv">11</span>);
  }</code></pre>
  <p>Если попробовать запустить этот код, то программа аварийно завершится с сообщением вроде этого:</p>
  <pre class="text"><code>thread '&lt;main&gt;' panicked at 'Неверное число: 11', src/bin/panic-simple.rs:6</code></pre>
  <p>Вот другой, менее надуманный пример. Программа, которая принимает число в качестве аргумента, удваивает его значение и печатает на экране.</p>
  <p><a name="code-unwrap-double"></a></p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::env;
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> <span class="kw">mut</span> argv = env::args();
      <span class="kw">let</span> arg: String = argv.nth(<span class="dv">1</span>).unwrap(); <span class="co">// ошибка 1</span>
      <span class="kw">let</span> n: <span class="kw">i32</span> = arg.parse().unwrap();      <span class="co">// ошибка 2</span>
      <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, <span class="dv">2</span> * n);
  }</code></pre>
  <p>Если вы запустите эту программу без параметров (ошибка 1) или если первый параметр будет не целым числом (ошибка 2), программа завершится паникой, так же, как и в первом примере.</p>
  <p>Обработка ошибок в подобном стиле подобна слону в посудной лавке. Слон будет нестись в направлении, в котором ему вздумается, и крушить все на своем пути.</p>
  <p><a name="unwrapping-explained"></a></p>
  <section id="объяснение-unwrap" class="level4">
  <h4>Объяснение <code>unwrap</code></h4>
  <p>В предыдущем примере мы утверждали, что программа будет просто паниковать, если будет выполнено одно из двух условий для возникновения ошибки, хотя, в отличии от первого примера, в коде программы нет явного вызова <code>panic</code>. Тем не менее, вызов <code>panic</code> встроен в вызов <code>unwrap</code>.</p>
  <p>Вызывать <code>unwrap</code> в Rust подобно тому, что сказать: “Верни мне результат вычислений, а если произошла ошибка, просто паникуй и останавливай программу”. Мы могли бы просто показать исходный код функции <code>unwrap</code>, ведь это довольно просто, но перед этим мы должны разобратся с типами <code>Option</code> и <code>Result</code>. Оба этих типа имеют определенный для них метод <code>unwrap</code>.</p>
  <p><a name="the-option-type"></a></p>
  <section id="тип-option" class="level5">
  <h5>Тип <code>Option</code></h5>
  <p>Тип <code>Option</code> <a href="http://doc.rust-lang.org/std/option/enum.Option.html">объявлен в стандартной библиотеке</a>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">enum</span> <span class="kw">Option</span>&lt;T&gt; {
      <span class="kw">None</span>,
      <span class="kw">Some</span>(T),
  }</code></pre>
  <p>Тип <code>Option</code> — это способ выразить <em>возможность отсутствия</em> чего бы то ни было, используя систему типов Rust. Выражение <em>возможности отсутствия</em> через систему типов является важной концепцией, поскольку такой подход позволяет компилятору требовать от разработчика обрабатывать такое отсутствие. Давайте взглянем на пример, который пытается найти символ в строке:</p>
  <p><a name="code-option-ex-string-find"></a></p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">// Поиск Unicode-символа `needle` в `haystack`. Когда первый символ найден,</span>
  <span class="co">// возвращается побайтовое смещение для этого символа. Иначе возвращается `None`.</span>
  <span class="kw">fn</span> find(haystack: &amp;<span class="kw">str</span>, needle: <span class="kw">char</span>) -&gt; <span class="kw">Option</span>&lt;usize&gt; {
      <span class="kw">for</span> (offset, c) in haystack.char_indices() {
          <span class="kw">if</span> c == needle {
              <span class="kw">return</span> <span class="kw">Some</span>(offset);
          }
      }
      <span class="kw">None</span>
  }</code></pre>
  <p>Обратите внимание, что когда эта функция находит соответствующий символ, она возвращает не просто <code>offset</code>. Вместо этого она возвращает <code>Some(offset)</code>. <code>Some</code> — это вариант или <em>конструктор значения</em> для типа <code>Option</code>. Его можно интерпретировать как функцию типа <code>fn&lt;T&gt;(value: T) -&gt; Option&lt;T&gt;</code>. Соответственно, <code>None</code> — это также конструктор значения, только у него нет параметров. Его можно интерпретировать как функцию типа <code>fn&lt;T&gt;() -&gt; Option&lt;T&gt;</code>.</p>
  <p>Может показаться, что мы подняли много шума из ничего, но это только половина истории. Вторая половина — это <em>использование</em> функции <code>find</code>, которую мы написали. Давайте попробуем использовать ее, чтобы найти расширение в имени файла.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="kw">let</span> file_name = <span class="st">&quot;foobar.rs&quot;</span>;
      <span class="kw">match</span> find(file_name, <span class="ch">'.'</span>) {
          <span class="kw">None</span> =&gt; <span class="ot">println!</span>(<span class="st">&quot;Расширение файла не найдено.&quot;</span>),
          <span class="kw">Some</span>(i) =&gt; <span class="ot">println!</span>(<span class="st">&quot;Расширение файла: {}&quot;</span>, &amp;file_name[i+<span class="dv">1.</span>.]),
      }
  }</code></pre>
  <p>Этот код использует <a href="#sec--patterns">сопоставление с образцом</a> чтобы выполнить <em>вариативный анализ</em> для возвращаемого функцией <code>find</code> значения <code>Option&lt;usize&gt;</code>. На самом деле, вариативный анализ является единственным способом добраться до значения, сохраненного внутри <code>Option&lt;T&gt;</code>. Это означает, что вы, как разработчик, обязаны обработать случай, когда значение <code>Option&lt;T&gt;</code> равно <code>None</code>, а не <code>Some(t)</code>.</p>
  <p>Но подождите, как насчет <code>unwrap</code>, который мы <a href="#code-unwrap-double"><code>до этого</code></a> использовали? Там не было никакого вариативного анализа! Вместо этого, вариативный анализ был перемещен внутрь метода <code>unwrap</code>. Вы можете сделать это самостоятельно, если захотите:</p>
  <p><a name="code-option-def-unwrap"></a></p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">enum</span> <span class="kw">Option</span>&lt;T&gt; {
      <span class="kw">None</span>,
      <span class="kw">Some</span>(T),
  }
  
  <span class="kw">impl</span>&lt;T&gt; <span class="kw">Option</span>&lt;T&gt; {
      <span class="kw">fn</span> unwrap(<span class="kw">self</span>) -&gt; T {
          <span class="kw">match</span> <span class="kw">self</span> {
              <span class="kw">Option</span>::<span class="kw">Some</span>(val) =&gt; val,
              <span class="kw">Option</span>::<span class="kw">None</span> =&gt;
                <span class="ot">panic!</span>(<span class="st">&quot;called `Option::unwrap()` on a `None` value&quot;</span>),
          }
      }
  }</code></pre>
  <p>Метод <code>unwrap</code> <em>абстрагирует вариативный анализ</em>. Это именно то, что делает <code>unwrap</code> удобным в использовании. К сожалению, <code>panic!</code> означает, что <code>unwrap</code> неудобно сочетать с другим кодом: это слон в посудной лавке.</p>
  <p><a name="composing-optiont-values"></a></p>
  </section>
  <section id="совмещение-значений-optiont" class="level5">
  <h5>Совмещение значений <code>Option&lt;T&gt;</code></h5>
  <p>В <a href="#code-option-ex-string-find">предыдущем примере</a> мы рассмотрели, как можно воспользоватся <code>find</code> для того, чтобы получить расширение имени файла. Конечно, не во всех именах файлов можно найти <code>.</code>, так что существует вероятность, что имя некоторого файла не имеет расширения. Эта <em>возможность отсутствия</em> интерпретируется на уровне типов через использование <code>Option&lt;T&gt;</code>. Другими словами, компилятор заставит нас рассмотреть возможность того, что расширение не существует. В нашем случае мы просто печатаем сообщение об этом.</p>
  <p>Получение расширения имени файла — довольно распространенная операция, так что имеет смысл вынести код в отдельную функцию:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">// Возвращает расширение заданного имени файла, а именно все символы,</span>
  <span class="co">// идущие за первым вхождением `.` в имя файла.</span>
  <span class="co">// Если в `file_name` нет ни одного вхождения `.`, возвращается `None`.</span>
  <span class="kw">fn</span> extension_explicit(file_name: &amp;<span class="kw">str</span>) -&gt; <span class="kw">Option</span>&lt;&amp;<span class="kw">str</span>&gt; {
      <span class="kw">match</span> find(file_name, <span class="ch">'.'</span>) {
          <span class="kw">None</span> =&gt; <span class="kw">None</span>,
          <span class="kw">Some</span>(i) =&gt; <span class="kw">Some</span>(&amp;file_name[i+<span class="dv">1.</span>.]),
      }
  }</code></pre>
  <p>(Подсказка: не используйте этот код. Вместо этого используйте метод <a href="http://doc.rust-lang.org/std/path/struct.Path.html#method.extension"><code>extension</code></a> из стандартной библиотеки.)</p>
  <p>Код выглядит простым, но его важный аспект заключается в том, что функция <code>find</code> заставляет нас рассмотреть вероятность отсутствия значения. Это хорошо, поскольку это означает, что компилятор не позволит нам случайно забыть о том варианте, когда в имени файла отсутствует расширение. С другой стороны, каждый раз выполнять явный вариативный анализ, подобно тому, как мы делали это в <code>extension_explicit</code>, может стать немного утомительным.</p>
  <p>На самом деле, вариативный анализ в <code>extension_explicit</code> является очень распространенным паттерном: если <code>Option&lt;T&gt;</code> владеет определенным значением <code>T</code>, то выполнить его преобразование с помощью функции, а если нет — то просто вернуть <code>None</code>.</p>
  <p>Rust поддерживает параметрический полиморфизм, так что можно очень легко объявить комбинатор, который абстрагирует это поведение:</p>
  <p><a name="code-option-map"></a></p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> map&lt;F, T, A&gt;(option: <span class="kw">Option</span>&lt;T&gt;, f: F) -&gt; <span class="kw">Option</span>&lt;A&gt; where F: FnOnce(T) -&gt; A {
      <span class="kw">match</span> option {
          <span class="kw">None</span> =&gt; <span class="kw">None</span>,
          <span class="kw">Some</span>(value) =&gt; <span class="kw">Some</span>(f(value)),
      }
  }</code></pre>
  <p>В действительности, <code>map</code> <a href="http://doc.rust-lang.org/std/option/enum.Option.html#method.map">определен в стандартной библиотеке</a> как метод <code>Option&lt;T&gt;</code>.</p>
  <p>Вооружившись нашим новым комбинатором, мы можем переписать наш метод <code>extension_explicit</code> так, чтобы избавиться от вариативного анализа:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">// Возвращает расширение заданного имени файла, а именно все символы,</span>
  <span class="co">// идущие за первым вхождением `.` в имя файла.</span>
  <span class="co">// Если в `file_name` нет ни одного вхождения `.`, возвращается `None`.</span>
  <span class="kw">fn</span> extension(file_name: &amp;<span class="kw">str</span>) -&gt; <span class="kw">Option</span>&lt;&amp;<span class="kw">str</span>&gt; {
      find(file_name, <span class="ch">'.'</span>).map(|i| &amp;file_name[i+<span class="dv">1.</span>.])
  }</code></pre>
  <p>Есть еще одно поведение, которое можно часто встретить — это использование значения по-умолчанию в случае, когда значение <code>Option</code> равно <code>None</code>. К примеру, ваша программа может считать, что расширение файла равно <code>rs</code> в случае, если на самом деле оно отсутствует.</p>
  <p>Легко представить, что этот случай вариативного анализа не специфичен только для расширений файлов — такой подход может работать с любым <code>Option&lt;T&gt;</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> unwrap_or&lt;T&gt;(option: <span class="kw">Option</span>&lt;T&gt;, default: T) -&gt; T {
      <span class="kw">match</span> option {
          <span class="kw">None</span> =&gt; default,
          <span class="kw">Some</span>(value) =&gt; value,
      }
  }</code></pre>
  <p>Хитрость только в том, что значение по-умолчанию должно иметь тот же тип, что и значение, которое может находится внутри <code>Option&lt;T&gt;</code>. Использование этого метода элементарно:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="ot">assert_eq!</span>(extension(<span class="st">&quot;foobar.csv&quot;</span>).unwrap_or(<span class="st">&quot;rs&quot;</span>), <span class="st">&quot;csv&quot;</span>);
      <span class="ot">assert_eq!</span>(extension(<span class="st">&quot;foobar&quot;</span>).unwrap_or(<span class="st">&quot;rs&quot;</span>), <span class="st">&quot;rs&quot;</span>);
  }</code></pre>
  <p>(Обратите внимание, что <code>unwrap_or</code> <a href="http://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or">объявлен как метод</a> <code>Option&lt;T&gt;</code> в стандартной библиотеке, так что мы воспользовались им вместо функции, которую мы объявили ранее. Не забудьте также изучить более общий метод <a href="http://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or_else"><code>unwrap_or_else</code></a>).</p>
  <p>Существует еще один комбинатор, на который, как мы думаем, стоит обратить особое внимание: <code>and_then</code>. Он позволяет легко сочетать различные вычисления, которые допускают <em>возможность отсутствия</em>. Пример — большая часть кода в этом разделе, который связан с определением расширения заданного имени файла. Чтобы делать это, нам для начала необходимо узнать имя файла, которое как правило извлекается из <em>файлового пути</em>. Хотя большинство файловых путей содержат имя файла, подобное нельзя сказать обо <em>всех</em> файловых путях. Примером могут послужить пути <code>.</code>, <code>..</code> или <code>/</code>.</p>
  <p>Таким образом, мы определили задачу нахождения расширения заданного <em>файлового пути</em>. Начнем с явного вариативного анализа:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> file_path_ext_explicit(file_path: &amp;<span class="kw">str</span>) -&gt; <span class="kw">Option</span>&lt;&amp;<span class="kw">str</span>&gt; {
      <span class="kw">match</span> file_name(file_path) {
          <span class="kw">None</span> =&gt; <span class="kw">None</span>,
          <span class="kw">Some</span>(name) =&gt; <span class="kw">match</span> extension(name) {
              <span class="kw">None</span> =&gt; <span class="kw">None</span>,
              <span class="kw">Some</span>(ext) =&gt; <span class="kw">Some</span>(ext),
          }
      }
  }
  
  <span class="kw">fn</span> file_name(file_path: &amp;<span class="kw">str</span>) -&gt; <span class="kw">Option</span>&lt;&amp;<span class="kw">str</span>&gt; {
    <span class="ot">unimplemented!</span>() <span class="co">// опустим реализацию</span>
  }</code></pre>
  <p>Можно подумать, мы могли бы просто использовать комбинатор <code>map</code>, чтобы уменьшить вариативный анализ, но его тип не совсем подходит. Дело в том, что <code>map</code> принимает функцию, которая делает что-то только с внутренним значением. Результат такой функции <em>всегда</em> <a href="#code-option-map">оборачивается в <code>Some</code></a>. Вместо этого, нам нужен метод, похожий <code>map</code>, но который позволяет вызывающему передать еще один <code>Option</code>. Его общая реализация даже проще, чем <code>map</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> and_then&lt;F, T, A&gt;(option: <span class="kw">Option</span>&lt;T&gt;, f: F) -&gt; <span class="kw">Option</span>&lt;A&gt;
          where F: FnOnce(T) -&gt; <span class="kw">Option</span>&lt;A&gt; {
      <span class="kw">match</span> option {
          <span class="kw">None</span> =&gt; <span class="kw">None</span>,
          <span class="kw">Some</span>(value) =&gt; f(value),
      }
  }</code></pre>
  <p>Теперь мы можем переписать нашу функцию <code>file_path_ext</code> без явного вариативного анализа:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> file_path_ext(file_path: &amp;<span class="kw">str</span>) -&gt; <span class="kw">Option</span>&lt;&amp;<span class="kw">str</span>&gt; {
      file_name(file_path).and_then(extension)
  }</code></pre>
  <p>Тип <code>Option</code> имеет много других комбинаторов <a href="http://doc.rust-lang.org/std/option/enum.Option.html">определенных в стандартной библиотеке</a>. Очень полезно просмотреть этот список и ознакомиться с доступными методами — они не раз помогут вам сократить количество вариативного анализа. Ознакомление с этими комбинаторами окупится еще и потому, что многие из них определены с аналогичной семантикой и для типа <code>Result</code>, о котором мы поговорим далее.</p>
  <p>Комбинаторы упрощают использование типов вроде <code>Option</code>, ведь они сокращают явный вариативный анализ. Они также соответствуют требованиям сочетаемости, поскольку они позволяют вызывающему обрабатывать возможность отсутствия результата собственным способом. Такие методы, как <code>unwrap</code>, лишают этой возможности, ведь они будут паниковать в случае, когда <code>Option&lt;T&gt;</code> равен <code>None</code>.</p>
  <p><a name="the-result-type"></a></p>
  </section>
  </section>
  <section id="тип-result" class="level4">
  <h4>Тип <code>Result</code></h4>
  <p>Тип <code>Result</code> также <a href="http://doc.rust-lang.org/std/result/">определен в стандартной библиотеке</a>:</p>
  <p><a name="code-result-def"></a></p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">enum</span> <span class="kw">Result</span>&lt;T, E&gt; {
      <span class="kw">Ok</span>(T),
      <span class="kw">Err</span>(E),
  }</code></pre>
  <p>Тип <code>Result</code> — это продвинутая версия <code>Option</code>. Вместо того, чтобы выражать возможность <em>отсутствия</em>, как это делает <code>Option</code>, <code>Result</code> выражает возможность <em>ошибки</em>. Как правило, <em>ошибки</em> необходимы для объяснения того, почему результат определенного вычисления не был получен. Строго говоря, это более общая форма <code>Option</code>. Рассмотрим следующий псевдоним типа, который во всех смыслах семантически эквивалентен реальному <code>Option&lt;T&gt;</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">type</span> Option&lt;T&gt; = <span class="kw">Result</span>&lt;T, ()&gt;;</code></pre>
  <p>Здесь второй параметр типа <code>Result</code> фиксируется и определяется через <code>()</code> (произносится как “unit” или “пустой кортеж”). Тип <code>()</code> имеет ровно одно значение — <code>()</code>. (Да, это тип и значение этого типа, которые выглядят одинаково!)</p>
  <p>Тип <code>Result</code> — это способ выразить один из двух возможных исходов вычисления. По соглашению, один исход означает ожидаемый результат или “<code>Ok</code>”, в то время как другой исход означает исключительную ситуацию или “<code>Err</code>”.</p>
  <p>Подобно <code>Option</code>, тип <code>Result</code> имеет метод <code>unwrap</code>, <a href="http://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap">определенный в стандартной библиотеке</a>. Давайте объявим его самостоятельно:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">impl</span>&lt;T, E: ::std::fmt::Debug&gt; <span class="kw">Result</span>&lt;T, E&gt; {
      <span class="kw">fn</span> unwrap(<span class="kw">self</span>) -&gt; T {
          <span class="kw">match</span> <span class="kw">self</span> {
              <span class="kw">Result</span>::<span class="kw">Ok</span>(val) =&gt; val,
              <span class="kw">Result</span>::<span class="kw">Err</span>(err) =&gt;
                <span class="ot">panic!</span>(<span class="st">&quot;called `Result::unwrap()` on an `Err` value: {:?}&quot;</span>, err),
          }
      }
  }</code></pre>
  <p>Это фактически то же самое, что и <a href="#code-option-def-unwrap">определение <code>Option::unwrap</code></a>, за исключением того, что мы добавили значение ошибки в сообщение <code>panic!</code>. Это упрощает отладку, но это также вынуждает нас требовать от типа-параметра <code>E</code> (который представляет наш тип ошибки) реализации <a href="http://doc.rust-lang.org/std/fmt/trait.Debug.html"><code>Debug</code></a>. Поскольку подавляющее большинство типов должны реализовывать <code>Debug</code>, обычно на практике такое ограничение не мешает. (Реализация <code>Debug</code> для некоторого типа просто означает, что существует разумный способ печати удобочитаемого описания значения этого типа.)</p>
  <p>Окей, давайте перейдем к примеру.</p>
  <p><a name="parsing-integers"></a></p>
  <section id="преобразование-строки-в-число" class="level5">
  <h5>Преобразование строки в число</h5>
  <p>Стандартная библиотека Rust позволяет элементарно преобразовывать строки в целые числа. На самом деле это настолько просто, что возникает соблазн написать что-то вроде:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> double_number(number_str: &amp;<span class="kw">str</span>) -&gt; <span class="kw">i32</span> {
      <span class="dv">2</span> * number_str.parse::&lt;<span class="kw">i32</span>&gt;().unwrap()
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> n: <span class="kw">i32</span> = double_number(<span class="st">&quot;10&quot;</span>);
      <span class="ot">assert_eq!</span>(n, <span class="dv">20</span>);
  }</code></pre>
  <p>Здесь вы должны быть скептически настроены по-поводу вызова <code>unwrap</code>. Если строку нельзя преобразовать в число, вы получите панику:</p>
  <pre class="text"><code>thread '&lt;main&gt;' panicked at 'called `Result::unwrap()` on an `Err` value: ParseIntErro
  ↳ r { kind: InvalidDigit }', /home/rustbuild/src/rust-buildbot/slave/beta-dist-rustc-l
  ↳ inux/build/src/libcore/result.rs:729</code></pre>
  <p>Это довольно неприятно, и если бы подобное произошло в используемой вами библиотеке, вы могли бы небезосновательно разгневаться. Так что нам стоит попытаться обработать ошибку в нашей функции, и пусть вызывающий сам решит что с этим делать. Это означает необходимость изменения типа, который возвращается <code>double_number</code>. Но на какой? Чтобы понять это, необходимо посмотреть на сигнатуру <a href="http://doc.rust-lang.org/std/primitive.str.html#method.parse"><code>метода parse</code></a> из стандартной библиотеки:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">impl</span> <span class="kw">str</span> {
      <span class="kw">fn</span> parse&lt;F: FromStr&gt;(&amp;<span class="kw">self</span>) -&gt; <span class="kw">Result</span>&lt;F, F::<span class="kw">Err</span>&gt;;
  }</code></pre>
  <p>Хмм. По крайней мере мы знаем, что должны использовать <code>Result</code>. Вполне возможно, что метод мог возвращать <code>Option</code>. В конце концов, строка либо парсится как число, либо нет, не так ли? Это, конечно, разумный путь, но внутренняя реализация знает <em>почему</em> строка не может быть преобразована в целое число. (Это может быть пустая строка, или неправильные цифры, слишком большая или слишком маленькая длина и т.д.) Таким образом, использование <code>Result</code> имеет смысл, ведь мы хотим предоставить больше информации, чем просто “отсутствие”. Мы хотим сказать, <em>почему</em> преобразование не удалось. Вам стоит рассуждать похожим образом, когда вы сталкиваетесь с выбором между <code>Option</code> и <code>Result</code>. Если вы можете предоставить подробную информацию об ошибке, то вам, вероятно, следует это сделать. (Позже мы поговорим об этом подробнее.)</p>
  <p>Хорошо, но как мы запишем наш тип возвращаемого значения? Метод <code>parse</code> является обобщенным (generic) для всех различных типов чисел из стандартной библиотеки. Мы могли бы (и, вероятно, должны) также сделать нашу функцию обобщенной, но давайте пока остановимся на конкретной реализации. Нас интересует только тип <code>i32</code>, так что нам стоит <a href="http://doc.rust-lang.org/std/primitive.i32.html">найти его реализацию <code>FromStr</code></a> (выполните поиск в вашем браузере по строке “FromStr”) и посмотреть на его <a href="#sec--associated-types">ассоциированный тип</a> <code>Err</code>. Мы делаем это, чтобы определить конкретный тип ошибки. В данном случае, это <a href="http://doc.rust-lang.org/std/num/struct.ParseIntError.html"><code>std::num::ParseIntError</code></a>. Наконец, мы можем переписать нашу функцию:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::num::ParseIntError;
  
  <span class="kw">fn</span> double_number(number_str: &amp;<span class="kw">str</span>) -&gt; <span class="kw">Result</span>&lt;<span class="kw">i32</span>, ParseIntError&gt; {
      <span class="kw">match</span> number_str.parse::&lt;<span class="kw">i32</span>&gt;() {
          <span class="kw">Ok</span>(n) =&gt; <span class="kw">Ok</span>(<span class="dv">2</span> * n),
          <span class="kw">Err</span>(err) =&gt; <span class="kw">Err</span>(err),
      }
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">match</span> double_number(<span class="st">&quot;10&quot;</span>) {
          <span class="kw">Ok</span>(n) =&gt; <span class="ot">assert_eq!</span>(n, <span class="dv">20</span>),
          <span class="kw">Err</span>(err) =&gt; <span class="ot">println!</span>(<span class="st">&quot;Error: {:?}&quot;</span>, err),
      }
  }</code></pre>
  <p>Неплохо, но нам пришлось написать гораздо больше кода! И нас опять раздражает вариативный анализ.</p>
  <p>Комбинаторы спешат на помощь! Подобно <code>Option</code>, <code>Result</code> имеет много комбинаторов, определенных в качестве методов. Существует большой список комбинаторов, общих между <code>Result</code> и <code>Option</code>. И <code>map</code> входит в этот список:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::num::ParseIntError;
  
  <span class="kw">fn</span> double_number(number_str: &amp;<span class="kw">str</span>) -&gt; <span class="kw">Result</span>&lt;<span class="kw">i32</span>, ParseIntError&gt; {
      number_str.parse::&lt;<span class="kw">i32</span>&gt;().map(|n| <span class="dv">2</span> * n)
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">match</span> double_number(<span class="st">&quot;10&quot;</span>) {
          <span class="kw">Ok</span>(n) =&gt; <span class="ot">assert_eq!</span>(n, <span class="dv">20</span>),
          <span class="kw">Err</span>(err) =&gt; <span class="ot">println!</span>(<span class="st">&quot;Error: {:?}&quot;</span>, err),
      }
  }</code></pre>
  <p>Все ожидаемые методы реализованы для <code>Result</code>, включая <a href="http://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap_or"><code>unwrap_or</code></a> и <a href="http://doc.rust-lang.org/std/result/enum.Result.html#method.and_then"><code>and_then</code></a>. Кроме того, поскольку <code>Result</code> имеет второй параметр типа, существуют комбинаторы, которые влияют только на значение ошибки, такие как <a href="http://doc.rust-lang.org/std/result/enum.Result.html#method.map_err"><code>map_err</code></a> (аналог <code>map</code>) и <a href="http://doc.rust-lang.org/std/result/enum.Result.html#method.or_else"><code>or_else</code></a> (аналог <code>and_then</code>).</p>
  <p><a name="the-result-type-alias-idiom"></a></p>
  </section>
  <section id="создание-псевдонима-типа-result" class="level5">
  <h5>Создание псевдонима типа <code>Result</code></h5>
  <p>В стандартной библиотеке можно часто увидеть типы вроде <code>Result&lt;i32&gt;</code>. Но постойте, ведь <a href="#code-result-def">мы определили <code>Result</code></a> с двумя параметрами типа. Как мы можем обойти это, указывая только один из них? Ответ заключается в определении псевдонима типа <code>Result</code>, который <em>фиксирует</em> один из параметров конкретным типом. Обычно фиксируется тип ошибки. Например, наш предыдущий пример с преобразованием строк в числа можно переписать так:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::num::ParseIntError;
  <span class="kw">use</span> std::result;
  
  <span class="kw">type</span> Result&lt;T&gt; = result::<span class="kw">Result</span>&lt;T, ParseIntError&gt;;
  
  <span class="kw">fn</span> double_number(number_str: &amp;<span class="kw">str</span>) -&gt; <span class="kw">Result</span>&lt;<span class="kw">i32</span>&gt; {
      <span class="ot">unimplemented!</span>();
  }</code></pre>
  <p>Зачем мы это делаем? Что ж, если у нас есть много функций, которые могут вернуть <code>ParseIntError</code>, то гораздо удобнее определить псевдоним, который всегда использует <code>ParseIntError</code>, так что мы не будем повторяться все время.</p>
  <p>Самый заметный случай использования такого подхода в стандартной библиотеке — псевдоним <a href="http://doc.rust-lang.org/std/io/type.Result.html"><code>io::Result</code></a>. Как правило, достаточно писать <code>io::Result&lt;T&gt;</code>, чтобы было понятно, что вы используете псевдоним типа из модуля <code>io</code>, а не обычное определение из <code>std::result</code>. (Этот подход также используется для <a href="http://doc.rust-lang.org/std/fmt/type.Result.html"><code>fmt::Result</code></a>)</p>
  <p><a name="a-brief-interlude-unwrapping-isnt-evil"></a></p>
  </section>
  </section>
  <section id="короткое-отступление-unwrap-не-обязательно-зло" class="level4">
  <h4>Короткое отступление: <code>unwrap</code> — не обязательно зло</h4>
  <p>Если вы были внимательны, то возможно заметили, что я занял довольно жесткую позицию по отношению к методам вроде <code>unwrap</code>, которые могут вызвать <code>panic</code> и прервать исполнение вашей программы. <em>В основном</em>, это хороший совет.</p>
  <p>Тем не менее, <code>unwrap</code> все-таки можно использовать разумно. Факторы, которые оправдывают использование <code>unwrap</code>, являются несколько туманными, и разумные люди могут со мной не согласиться. Я кратко изложу свое <em>мнение</em> по этому вопросу:</p>
  <ul>
  <li><strong>Примеры и “грязный” код.</strong> Когда вы пишете просто пример или быстрый скрипт, обработка ошибок просто не требуется. Для подобных случаев трудно найти что-либо удобнее чем <code>unwrap</code>, так что здесь его использование очень привлекательно.</li>
  <li><strong>Паника указывает на ошибку в программе.</strong> Если логика вашего кода должна предотвращать определенное поведение (скажем, получение элемента из пустого стека), то использование <code>panic</code> также допустимо. Дело в том, что в этом случае паника будет сообщать о баге в вашей программе. Это может происходить явно, например от неудачного вызова <code>assert!</code>, или происходить потому, что индекс по массиву находится за пределами выделенной памяти.</li>
  </ul>
  <p>Вероятно, это не исчерпывающий список. Кроме того, при использовании <code>Option</code> зачастую лучше использовать метод <a href="http://doc.rust-lang.org/std/option/enum.Option.html#method.expect"><code>expect</code></a>. Этот метод делает ровно то же, что и <code>unwrap</code>, за исключением того, что в случае паники напечатает ваше сообщение. Это позволит лучше понять причину ошибки, ведь будет показано конкретное сообщение, а не просто “called unwrap on a <code>None</code> value”.</p>
  <p>Мой совет сводится к следующему: используйте здравый смысл. Есть причины, по которым слова вроде “никогда не делать X” или “Y считается вредным” не появятся в этой статье. У любых решений существуют компромиссы, и это ваша задача, как разработчика, определить, что именно является приемлемым для вашего случая. Моя цель состоит только в том, чтобы помочь вам оценить компромиссы как можно точнее.</p>
  <p>Теперь, когда мы рассмотрели основы обработки ошибок в Rust и разобрались с <code>unwrap</code>, давайте подробнее изучим стандартную библиотеку.</p>
  <p><a name="working-with-multiple-error-types"></a></p>
  </section>
  </section>
  <section id="работа-с-несколькими-типами-ошибок" class="level3">
  <h3>Работа с несколькими типами ошибок</h3>
  <p>До этого момента мы расматривали обработку ошибок только для случаев, когда все сводилось либо только к <code>Option&lt;T&gt;</code>, либо только к <code>Result&lt;T, SomeError&gt;</code>. Но что делать, когда у вас есть и <code>Option</code>, и <code>Result</code>? Или если у вас есть <code>Result&lt;T, Error1&gt;</code> и <code>Result&lt;T, Error2&gt;</code>? Наша следующуя задача — обработка <em>композиции различных типов ошибок</em>, и это будет главной темой на протяжении всей этой главы.</p>
  <p><a name="composing-option-and-result"></a></p>
  <section id="совмещение-option-и-result" class="level4">
  <h4>Совмещение <code>Option</code> и <code>Result</code></h4>
  <p>Пока что мы говорили о комбинаторах, определенных для <code>Option</code>, и комбинаторах, определенных для <code>Result</code>. Эти комбинаторы можно использовать для того, чтобы сочетать результаты различных вычислений, не делая подробного вариативного анализа.</p>
  <p>Конечно, в реальном коде все происходит не так гладко. Иногда у вас есть сочетания типов <code>Option</code> и <code>Result</code>. Должны ли мы прибегать к явному вариативному анализу, или можно продолжить использовать комбинаторы?</p>
  <p>Давайте на время вернемся к одному из первых примеров в этой главе:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::env;
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> <span class="kw">mut</span> argv = env::args();
      <span class="kw">let</span> arg: String = argv.nth(<span class="dv">1</span>).unwrap(); <span class="co">// ошибка 1</span>
      <span class="kw">let</span> n: <span class="kw">i32</span> = arg.parse().unwrap(); <span class="co">// ошибка 2</span>
      <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, <span class="dv">2</span> * n);
  }</code></pre>
  <p>Учитывая наши знания о типах <code>Option</code> и <code>Result</code>, а также их различных комбинаторах, мы можем попытаться переписать этот код так, чтобы ошибки обрабатывались должным образом, и программа не паниковала в случае ошибки.</p>
  <p>Ньюанс заключается в том, что <code>argv.nth(1)</code> возвращает <code>Option</code>, в то время как <code>arg.parse()</code> возвращает <code>Result</code>. Они не могут быть скомпонованы непосредственно. Когда вы сталкиваетесь одновременно с <code>Option</code> и<code>Result</code>, <em>обычно</em> наилучшее решение — преобразовать <code>Option</code> в <code>Result</code>. В нашем случае, отсутствие параметра командной строки (из <code>env::args()</code>) означает, что пользователь не правильно вызвал программу. Мы могли бы просто использовать <code>String</code> для описания ошибки. Давайте попробуем:</p>
  <p><a name="code-error-double-string"></a></p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::env;
  
  <span class="kw">fn</span> double_arg(<span class="kw">mut</span> argv: env::Args) -&gt; <span class="kw">Result</span>&lt;<span class="kw">i32</span>, String&gt; {
      argv.nth(<span class="dv">1</span>)
          .ok_or(<span class="st">&quot;Please give at least one argument&quot;</span>.to_owned())
          .and_then(|arg| arg.parse::&lt;<span class="kw">i32</span>&gt;().map_err(|err| err.to_string()))
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">match</span> double_arg(env::args()) {
          <span class="kw">Ok</span>(n) =&gt; <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, n),
          <span class="kw">Err</span>(err) =&gt; <span class="ot">println!</span>(<span class="st">&quot;Error: {}&quot;</span>, err),
      }
  }</code></pre>
  <p>Раcсмотрим пару новых моментов на этом примере. Во-первых, использование комбинатора <a href="http://doc.rust-lang.org/std/option/enum.Option.html#method.ok_or"><code>Option::ok_or</code></a>. Это один из способов преобразования <code>Option</code> в <code>Result</code>. Такое преобразование требует явного определения ошибки, которую необходимо вернуть в случае, когда значение <code>Option</code> равно <code>None</code>. Как и для всех комбинаторов, которые мы рассматривали, его объявление очень простое:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> ok_or&lt;T, E&gt;(option: <span class="kw">Option</span>&lt;T&gt;, err: E) -&gt; <span class="kw">Result</span>&lt;T, E&gt; {
      <span class="kw">match</span> option {
          <span class="kw">Some</span>(val) =&gt; <span class="kw">Ok</span>(val),
          <span class="kw">None</span> =&gt; <span class="kw">Err</span>(err),
      }
  }</code></pre>
  <p>Второй новый комбинатор, который мы использовали — <a href="http://doc.rust-lang.org/std/result/enum.Result.html#method.map_err"><code>Result::map_err</code></a>. Это то же самое, что и <code>Result::map</code>, за исключением того, функция применяется к <em>ошибке</em> внутри <code>Result</code>. Если значение <code>Result</code> равно <code>Оk(...)</code>, то оно возвращается без изменений.</p>
  <p>Мы используем <code>map_err</code>, потому что нам необходимо привести все ошибки к одинаковому типу (из-за нашего использования <code>and_then</code>). Поскольку мы решили преобразовывать <code>Option&lt;String&gt;</code> (из <code>argv.nth(1)</code>) в <code>Result&lt;String, String&gt;</code>, мы также обязаны преобразовывать <code>ParseIntError</code> из <code>arg.parse()</code> в <code>String</code>.</p>
  <p><a name="the-limits-of-combinators"></a></p>
  </section>
  <section id="ограничения-комбинаторов" class="level4">
  <h4>Ограничения комбинаторов</h4>
  <p>Работа с IO и анализ входных данных — очень типичные задачи, и это то, чем лично я много занимаюсь с Rust. Так что мы будем использовать IO и различные процедуры анализа как примеры обработки ошибок.</p>
  <p>Давайте начнем с простого. Поставим задачу открыть файл, прочесть все его содержимое и преобразовать это содержимое в число. После этого нужно будет умножить значение на <code>2</code> и распечатать результат.</p>
  <p>Хоть я и пытался убедить вас не использовать <code>unwrap</code>, иногда бывает полезным для начала написать код с <code>unwrap</code>. Это позволяет сосредоточиться на проблеме, а не на обработке ошибок, и это выявляет места, где надлежащая обработка ошибок необходима. Давайте начнем с того, что напишем просто работающий код, а затем отрефакторим его для лучшей обработки ошибок.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::fs::File;
  <span class="kw">use</span> std::io::Read;
  <span class="kw">use</span> std::path::Path;
  
  <span class="kw">fn</span> file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; <span class="kw">i32</span> {
      <span class="kw">let</span> <span class="kw">mut</span> file = File::open(file_path).unwrap(); <span class="co">// ошибка 1</span>
      <span class="kw">let</span> <span class="kw">mut</span> contents = String::new();
      file.read_to_string(&amp;<span class="kw">mut</span> contents).unwrap();   <span class="co">// ошибка 2</span>
      <span class="kw">let</span> n: <span class="kw">i32</span> = contents.trim().parse().unwrap(); <span class="co">// ошибка 3</span>
      <span class="dv">2</span> * n
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> doubled = file_double(<span class="st">&quot;foobar&quot;</span>);
      <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, doubled);
  }</code></pre>
  <p>(Замечание: Мы используем <code>AsRef</code> по <a href="http://doc.rust-lang.org/std/fs/struct.File.html#method.open">тем же причинам, почему он используется в <code>std::fs::File::open</code></a>. Это позволяет удобно использовать любой тип строки в качестве пути к файлу.)</p>
  <p>У нас есть три потенциальные ошибки, которые могут возникнуть:</p>
  <ol type="1">
  <li>Проблема при открытии файла.</li>
  <li>Проблема при чтении данных из файла.</li>
  <li>Проблема при преобразовании данных в число.</li>
  </ol>
  <p>Первые две проблемы определяются типом <a href="http://doc.rust-lang.org/std/io/struct.Error.html"><code>std::io::Error</code></a>. Мы знаем это из типа возвращаемого значения методов <a href="http://doc.rust-lang.org/std/fs/struct.File.html#method.open"><code>std::fs::File::open</code></a> и <a href="http://doc.rust-lang.org/std/io/trait.Read.html#method.read_to_string"><code>std::io::Read::read_to_string</code></a>. (Обратите внимание, что они оба используют <a href="#the-result-type-alias-idiom">концепцию с псевдонимом типа <code>Result</code></a>, описанную ранее. Если вы кликните на тип <code>Result</code>, вы <a href="http://doc.rust-lang.org/std/io/type.Result.html">увидите псевдоним типа</a>, и следовательно, лежащий в основе тип <code>io::Error</code>.) Третья проблема определяется типом <a href="http://doc.rust-lang.org/std/num/struct.ParseIntError.html"><code>std::num::ParseIntError</code></a>. Кстати, тип <code>io::Error</code> <em>часто</em> используется по всей стандартной библиотеке. Вы будете видеть его снова и снова.</p>
  <p>Давайте начнем рефакторинг функции <code>file_double</code>. Для того, чтобы эту функцию можно было сочетать с остальным кодом, она <em>не должна</em> паниковать, если какие-либо из перечисленных выше ошибок действительно произойдут. Фактически, это означает, что функция должна <em>возвращать ошибку</em>, если любая из возможных операций завершилась неудачей. Проблема состоит в том, что тип возвращаемого значения сейчас <code>i32</code>, который не дает нам никакого разумного способа сообщить об ошибке. Таким образом, мы должны начать с изменения типа возвращаемого значения с <code>i32</code> на что-то другое.</p>
  <p>Первое, что мы должны решить: какой из типов использовать: <code>Option</code> или <code>Result</code>? Мы, конечно, могли бы с легкостью использовать <code>Option</code>. Если какая-либо из трех ошибок происходит, мы могли бы просто вернуть <code>None</code>. Это будет работать, и <em>это лучше, чем просто паниковать</em>, но мы можем сделать гораздо лучше. Вместо этого, мы будем сообщать некоторые детали о возникшей проблеме. Поскольку мы хотим выразить <em>возможность ошибки</em>, мы должны использовать <code>Result&lt;i32, E&gt;</code>. Но каким должен быть тип <code>E</code>? Поскольку может возникнуть два <em>разных</em> типа ошибок, мы должны преобразовать их к общему типу. Одним из таких типов является <code>String</code>. Давайте посмотрим, как это отразится на нашем коде:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::fs::File;
  <span class="kw">use</span> std::io::Read;
  <span class="kw">use</span> std::path::Path;
  
  <span class="kw">fn</span> file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; <span class="kw">Result</span>&lt;<span class="kw">i32</span>, String&gt; {
      File::open(file_path)
           .map_err(|err| err.to_string())
           .and_then(|<span class="kw">mut</span> file| {
                <span class="kw">let</span> <span class="kw">mut</span> contents = String::new();
                file.read_to_string(&amp;<span class="kw">mut</span> contents)
                    .map_err(|err| err.to_string())
                    .map(|_| contents)
           })
           .and_then(|contents| {
                contents.trim().parse::&lt;<span class="kw">i32</span>&gt;()
                        .map_err(|err| err.to_string())
           })
           .map(|n| <span class="dv">2</span> * n)
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">match</span> file_double(<span class="st">&quot;foobar&quot;</span>) {
          <span class="kw">Ok</span>(n) =&gt; <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, n),
          <span class="kw">Err</span>(err) =&gt; <span class="ot">println!</span>(<span class="st">&quot;Ошибка: {}&quot;</span>, err),
      }
  }</code></pre>
  <p>Выглядит немного запутанно. Может потребоваться довольно много практики, прежде вы сможете писать такое. Написание кода в таком стиле называется <em>следованием за типом</em>. Когда мы изменили тип возвращаемого значения <code>file_double</code> на <code>Result&lt;i32, String&gt;</code>, нам пришлось начать подбирать правильные комбинатороы. В данном случае мы использовали только три различных комбинатора: <code>and_then</code>, <code>map</code> и <code>map_err</code>.</p>
  <p>Комбинатор <code>and_then</code> используется для объединения по цепочке нескольких вычислений, где каждое вычисление может вернуть ошибку. После открытия файла есть еще два вычисления, которые могут завершиться неудачей: чтение из файла и преобразование содержимого в число. Соответственно, имеем два вызова <code>and_then</code>.</p>
  <p>Комбинатор <code>map</code> используется, чтобы применить функцию к значению <code>Ok(...)</code> типа <code>Result</code>. Например, в самом последнем вызове, <code>map</code> умножает значение <code>Ok(...)</code> (типа <code>i32</code>) на <code>2</code>. Если ошибка произошла до этого момента, эта операция была бы пропущена. Это следует из определения <code>map</code>.</p>
  <p>Комбинатор <code>map_err</code> — это уловка, которая позволяют всему этому заработать. Этот комбинатор, такой же, как и <code>map</code>, за исключением того, что применяет функцию к <code>Err(...)</code> значению <code>Result</code>. В данном случае мы хотим привести все наши ошибки к одному типу — <code>String</code>. Поскольку как <code>io::Error</code>, так и <code>num::ParseIntError</code> реализуют <code>ToString</code>, мы можем вызвать метод <code>to_string</code>, чтобы выполнить преобразование.</p>
  <p>Не смотря на все сказанное, код по-прежнему выглядит запутанным. Мастерство использования комбинаторов является важным, но у них есть свои недостатки. Давайте попробуем другой подход: преждевременный возврат.</p>
  <p><a name="early-returns"></a></p>
  </section>
  <section id="преждевременный-return" class="level4">
  <h4>Преждевременный <code>return</code></h4>
  <p>Давайте возьмем код из предыдущего раздела и перепишем его с применением <em>раннего возврата</em>. Ранний <code>return</code> позволяет выйти из функции досрочно. Мы не можем выполнить <code>return</code> для <code>file_double</code> внутри замыкания, поэтому нам необходимо вернуться к явному вариативному анализу.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::fs::File;
  <span class="kw">use</span> std::io::Read;
  <span class="kw">use</span> std::path::Path;
  
  <span class="kw">fn</span> file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; <span class="kw">Result</span>&lt;<span class="kw">i32</span>, String&gt; {
      <span class="kw">let</span> <span class="kw">mut</span> file = <span class="kw">match</span> File::open(file_path) {
          <span class="kw">Ok</span>(file) =&gt; file,
          <span class="kw">Err</span>(err) =&gt; <span class="kw">return</span> <span class="kw">Err</span>(err.to_string()),
      };
      <span class="kw">let</span> <span class="kw">mut</span> contents = String::new();
      <span class="kw">if</span> <span class="kw">let</span> <span class="kw">Err</span>(err) = file.read_to_string(&amp;<span class="kw">mut</span> contents) {
          <span class="kw">return</span> <span class="kw">Err</span>(err.to_string());
      }
      <span class="kw">let</span> n: <span class="kw">i32</span> = <span class="kw">match</span> contents.trim().parse() {
          <span class="kw">Ok</span>(n) =&gt; n,
          <span class="kw">Err</span>(err) =&gt; <span class="kw">return</span> <span class="kw">Err</span>(err.to_string()),
      };
      <span class="kw">Ok</span>(<span class="dv">2</span> * n)
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">match</span> file_double(<span class="st">&quot;foobar&quot;</span>) {
          <span class="kw">Ok</span>(n) =&gt; <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, n),
          <span class="kw">Err</span>(err) =&gt; <span class="ot">println!</span>(<span class="st">&quot;Ошибка: {}&quot;</span>, err),
      }
  }</code></pre>
  <p>Кто-то может обосновано не согласиться с тем, что этот код лучше, чем тот, который использует комбинаторы, но если вы не знакомы с комбинаторами, на мой взгляд, этот код будет выглядеть проще. Он выполняет явный вариативный анализ с помощью <code>match</code> и <code>if let</code>. Если происходит ошибка, мы просто прекращаем выполнение функции и возвращаем ошибку (после преобразования в строку).</p>
  <p>Разве это не шаг назад? Ранее мы говорили, что ключ к удобной обработке ошибок — сокращение явного вариативного анализа, но здесь мы вернулись к тому, с чего начинали. Оказывается, существует <em>несколько</em> способов его уменьшения. И комбинаторы — не единственный путь.</p>
  <p><a name="the-try-macro"></a></p>
  </section>
  <section id="макрос-try" class="level4">
  <h4>Макрос <code>try!</code></h4>
  <p>Краеугольный камень обработки ошибок в Rust — это макрос <code>try!</code>. Этот макрос абстрагирует анализ вариантов так же, как и комбинаторы, но в отличие от них, он также абстрагирует <em>поток выполнения</em>. А именно, он умеет абстрагировать идею <em>досрочного возврата</em>, которую мы только что реализовали.</p>
  <p>Вот упрощенное определение макроса `try!:</p>
  <p><a name="code-try-def-simple"></a></p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="ot">macro_rules!</span> try {
      ($e:expr) =&gt; (<span class="kw">match</span> $e {
          <span class="kw">Ok</span>(val) =&gt; val,
          <span class="kw">Err</span>(err) =&gt; <span class="kw">return</span> <span class="kw">Err</span>(err),
      });
  }</code></pre>
  <p>(<a href="http://doc.rust-lang.org/std/macro.try!.html">Реальное определение</a> выглядит немного сложнее. Мы обсудим это далее).</p>
  <p>Использование макроса <code>try!</code> может очень легко упростить наш последний пример. Поскольку он выполняет анализ вариантов и досрочной возврат из функции, мы получаем более плотный код, который легче читать:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::fs::File;
  <span class="kw">use</span> std::io::Read;
  <span class="kw">use</span> std::path::Path;
  
  <span class="kw">fn</span> file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; <span class="kw">Result</span>&lt;<span class="kw">i32</span>, String&gt; {
      <span class="kw">let</span> <span class="kw">mut</span> file = <span class="ot">try!</span>(File::open(file_path).map_err(|e| e.to_string()));
      <span class="kw">let</span> <span class="kw">mut</span> contents = String::new();
      <span class="ot">try!</span>(file.read_to_string(&amp;<span class="kw">mut</span> contents).map_err(|e| e.to_string()));
      <span class="kw">let</span> n = <span class="ot">try!</span>(contents.trim().parse::&lt;<span class="kw">i32</span>&gt;().map_err(|e| e.to_string()));
      <span class="kw">Ok</span>(<span class="dv">2</span> * n)
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">match</span> file_double(<span class="st">&quot;foobar&quot;</span>) {
          <span class="kw">Ok</span>(n) =&gt; <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, n),
          <span class="kw">Err</span>(err) =&gt; <span class="ot">println!</span>(<span class="st">&quot;Ошибка: {}&quot;</span>, err),
      }
  }</code></pre>
  <p>Вызов <code>map_err</code> по-прежнему необходим, учитывая <a href="#code-try-def-simple">наше определение <code>try!</code></a>, поскольку ошибки все еще должны быть преобразованы в <code>String</code>. Хорошей новостью является то, что в ближайшее время мы узнаем, как убрать все эти вызовы <code>map_err</code>! Плохая новость состоит в том, что для этого нам придется кое-что узнать о паре важных типажей из стандартной библиотеки.</p>
  <p><a name="defining-your-own-error-type"></a></p>
  </section>
  <section id="объявление-собственного-типа-ошибки" class="level4">
  <h4>Объявление собственного типа ошибки</h4>
  <p>Прежде чем мы погрузимся в аспекты некоторых типажей из стандартной библиотеки, связанных с ошибками, я бы хотел завершить этот раздел отказом от использования <code>String</code> как типа ошибки в наших примерах.</p>
  <p>Использование <code>String</code> в том стиле, в котором мы использовали его в предыдущих примерах удобно потому, что достаточно легко конвертировать любые ошибки в строки, или даже создавать свои собственные ошибки на ходу. Тем не менее, использование типа <code>String</code> для ошибок имеет некоторые недостатки.</p>
  <p>Первый недостаток в том, что сообщения об ошибках, как правило, загромождают код. Можно определять сообщения об ошибках в другом месте, но это поможет только если вы необыкновенно дисциплинированны, поскольку очень заманчиво вставлять сообщения об ошибках прямо в код. На самом деле, мы именно этим и занимались в <a href="#code-error-double-string">предыдущем примере</a>.</p>
  <p>Второй и более важный недостаток заключается в том, что использование <code>String</code> чревато <em>потерей информации</em>. Другими словами, если все ошибки будут преобразованы в строки, то когда мы будем возвращать их вызывающей стороне, они не будут иметь никакого смысла. Единственное разумное, что вызывающая сторона может сделать с ошибкой типа <code>String</code> — это показать ее пользователю. Безусловно, можно проверить строку по значению, чтобы определить тип ошибки, но такой подход не может похвастаться надежностью. (Правда, в гораздо большей степени это недостаток для библиотек, чем для конечных приложений).</p>
  <p>Например, тип <code>io::Error</code> включает в себя тип <a href="http://doc.rust-lang.org/std/io/enum.ErrorKind.html"><code>io::ErrorKind</code></a>, который является <em>структурированными данными</em>, представляющими то, что пошло не так во время выполнения операции ввода-вывода. Это важно, поскольку может возникнуть необходимость по-разному реагировать на различные причины ошибки. (Например, ошибка <code>BrokenPipe</code> может изящно завершать программу, в то время как ошибка <code>NotFound</code> будет завершать программу с кодом ошибки и показывать соответствующее сообщение пользователю.) Благодаря <code>io::ErrorKind</code>, вызывающая сторона может исследовать тип ошибки с помощью вариативного анализа, и это значительно лучше попытки вычленить детали об ошибке из <code>String</code>.</p>
  <p>Вместо того, чтобы использовать <code>String</code> как тип ошибки в нашем предыдущем примере про чтение числа из файла, мы можем определить свой собственный тип, который представляет ошибку в виде <em>структурированных данных</em>. Мы постараемся не потерять никакую информацию от изначальных ошибок на тот случай, если вызывающая сторона захочет исследовать детали.</p>
  <p>Идеальным способом представления <em>одного варианта из многих</em> является определение нашего собственного типа-суммы с помощью <code>enum</code>. В нашем случае, ошибка представляет собой либо <code>io::Error</code>, либо <code>num::ParseIntError</code>, из чего естественным образом вытекает определение:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::io;
  <span class="kw">use</span> std::num;
  
  <span class="co">// Мы реализуем `Debug` поскольку, по всей видимости, все типы должны реализовывать `D</span>
  ↳ ebug`.
  <span class="co">// Это дает нам возможность получить адекватное и читаемое описание значения CliError</span>
  <span class="ot">#[</span>derive<span class="ot">(</span>Debug<span class="ot">)]</span>
  <span class="kw">enum</span> CliError {
      Io(io::Error),
      Parse(num::ParseIntError),
  }</code></pre>
  <p>Осталось только немного подогнать наш код из примера. Вместо преобразования ошибок в строки, мы будем просто конвертировать их в наш тип <code>CliError</code>, используя соответствующий конструктор значения:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::fs::File;
  <span class="kw">use</span> std::io::Read;
  <span class="kw">use</span> std::path::Path;
  
  <span class="kw">fn</span> file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; <span class="kw">Result</span>&lt;<span class="kw">i32</span>, CliError&gt; {
      <span class="kw">let</span> <span class="kw">mut</span> file = <span class="ot">try!</span>(File::open(file_path).map_err(CliError::Io));
      <span class="kw">let</span> <span class="kw">mut</span> contents = String::new();
      <span class="ot">try!</span>(file.read_to_string(&amp;<span class="kw">mut</span> contents).map_err(CliError::Io));
      <span class="kw">let</span> n: <span class="kw">i32</span> = <span class="ot">try!</span>(contents.trim().parse().map_err(CliError::Parse));
      <span class="kw">Ok</span>(<span class="dv">2</span> * n)
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">match</span> file_double(<span class="st">&quot;foobar&quot;</span>) {
          <span class="kw">Ok</span>(n) =&gt; <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, n),
          <span class="kw">Err</span>(err) =&gt; <span class="ot">println!</span>(<span class="st">&quot;Ошибка: {:?}&quot;</span>, err),
      }
  }</code></pre>
  <p>Единственное изменение здесь — замена вызова <code>map_err(|e| e.to_string())</code> (который преобразовывал ошибки в строки) на <code>map_err(CliError::Io)</code> или <code>map_err(CliError::Parse)</code>. Теперь <em>вызывающая сторона</em> определяет уровень детализации сообщения об ошибке для конечного пользователя. В действительности, использование <code>String</code> как типа ошибки лишает вызывающего возможности выбора, в то время использование собственного типа <code>enum</code>, на подобие <code>CliError</code>, дает вызывающему тот же уровень удобства, который был ранее, и кроме этого <em>структурированные данные</em>, описывающие ошибку.</p>
  <p>Практическое правило заключается в том, что необходимо определять свой собственный тип ошибки, а тип <code>String</code> для ошибок использовать в крайнем случае, в основном когда вы пишете конечное приложение. Если вы пишете библиотеку, определение своего собственного типа ошибки наиболее предпочтительно. Таким образом, вы не лишите пользователя вашей библиотеки возможности выбирать наиболее предпочтительное для его конкретного случая поведение.</p>
  <p><a name="standard-library-traits-used-for-error-handling"></a></p>
  </section>
  </section>
  <section id="типажи-из-стандартной-библиотеки-используемые-для-обработки-ошибок" class="level3">
  <h3>Типажи из стандартной библиотеки, используемые для обработки ошибок</h3>
  <p>Стандартная библиотека определяет два встроенных типажа, полезных для обработки ошибок <a href="http://doc.rust-lang.org/std/error/trait.Error.html"><code>std::error::Error</code></a> и <a href="http://doc.rust-lang.org/std/convert/trait.From.html"><code>std::convert::From</code></a>. И если <code>Error</code> разработан специально для создания общего описания ошибки, то типаж <code>From</code> играет широкую роль в преобразовании значений между различными типами.</p>
  <p><a name="the-error-trait"></a></p>
  <section id="типаж-error" class="level4">
  <h4>Типаж <code>Error</code></h4>
  <p>Типаж <code>Error</code> <a href="http://doc.rust-lang.org/std/error/trait.Error.html">объявлен в стандартной библиотеке</a>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::fmt::{Debug, Display};
  
  <span class="kw">trait</span> Error: Debug + Display {
    <span class="co">/// A short description of the error.</span>
    <span class="kw">fn</span> description(&amp;<span class="kw">self</span>) -&gt; &amp;<span class="kw">str</span>;
  
    <span class="co">/// The lower level cause of this error, if any.</span>
    <span class="kw">fn</span> cause(&amp;<span class="kw">self</span>) -&gt; <span class="kw">Option</span>&lt;&amp;Error&gt; { <span class="kw">None</span> }
  }</code></pre>
  <p>Этот типаж очень обобщенный, поскольку предполагается, что он должен быть реализован для <em>всех</em> типов, которые представляют собой ошибки. Как мы увидим дальше, он нам очень пригодится для написания сочетаемого кода. Этот типаж, как минимум, позволяет выполнять следующие вещи:</p>
  <ul>
  <li>Получать строковое представление ошибки для разработчика (<code>Debug</code>).</li>
  <li>Получать понятное для пользователя представление ошибки (<code>Display</code>).</li>
  <li>Получать краткое описание ошибки (метод <code>description</code>).</li>
  <li>Изучать по цепочке первопричину ошибки, если она существует (метод <code>cause</code>).</li>
  </ul>
  <p>Первые две возможности возникают в результате того, что типаж <code>Error</code> требует в свою очередь реализации типажей <code>Debug</code> и <code>Display</code>. Последние два факта исходят из двух методов, определенных в самом <code>Error</code>. Мощь <code>Еrror</code> заключается в том, что все существующие типы ошибок его реализуют, что в свою очередь означает что любые ошибки могут быть сохранены как <a href="#sec--trait-objects">типажи-объекты</a> (trait object). Обычно это выглядит как <code>Box&lt;Error&gt;</code>, либо <code>&amp;Error</code>. Например, метод <code>cause</code> возвращает <code>&amp;Error</code>, который как раз является типажом-объектом. Позже мы вернемся к применению <code>Error</code> как типажа-объекта.</p>
  <p>В настоящее время достаточно показать пример, реализующий типаж <code>Error</code>. Давайте воспользуемся для этого типом ошибки, который мы определили в <a href="#defining-your-own-error-type">предыдущем разделе</a>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::io;
  <span class="kw">use</span> std::num;
  
  <span class="co">// Мы реализуем `Debug` поскольку, по всей видимости, все типы должны реализовывать `D</span>
  ↳ ebug`.
  <span class="co">// Это дает нам возможность получить адекватное и читаемое описание значения CliError</span>
  <span class="ot">#[</span>derive<span class="ot">(</span>Debug<span class="ot">)]</span>
  <span class="kw">enum</span> CliError {
      Io(io::Error),
      Parse(num::ParseIntError),
  }</code></pre>
  <p>Данный тип ошибки отражает возможность возникновения двух других типов ошибок: ошибка работы с IО или ошибка преобразования строки в число. Определение ошибки может отражать столько других видов ошибок, сколько необходимо, за счет добавления новых вариантов в объявлении <code>enum</code>.</p>
  <p>Реализация <code>Error</code> довольно прямолинейна и главным образом состоит из явного анализа вариантов:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::error;
  <span class="kw">use</span> std::fmt;
  
  <span class="kw">impl</span> fmt::Display <span class="kw">for</span> CliError {
      <span class="kw">fn</span> fmt(&amp;<span class="kw">self</span>, f: &amp;<span class="kw">mut</span> fmt::Formatter) -&gt; fmt::<span class="kw">Result</span> {
          <span class="kw">match</span> *<span class="kw">self</span> {
              <span class="co">// Оба изначальных типа ошибок уже реализуют `Display`,</span>
              <span class="co">// так что мы можем использовать их реализации</span>
              CliError::Io(<span class="kw">ref</span> err) =&gt; <span class="ot">write!</span>(f, <span class="st">&quot;IO error: {}&quot;</span>, err),
              CliError::Parse(<span class="kw">ref</span> err) =&gt; <span class="ot">write!</span>(f, <span class="st">&quot;Parse error: {}&quot;</span>, err),
          }
      }
  }
  
  <span class="kw">impl</span> error::Error <span class="kw">for</span> CliError {
      <span class="kw">fn</span> description(&amp;<span class="kw">self</span>) -&gt; &amp;<span class="kw">str</span> {
          <span class="co">// Оба изначальных типа ошибок уже реализуют `Error`,</span>
          <span class="co">// так что мы можем использовать их реализацией</span>
          <span class="kw">match</span> *<span class="kw">self</span> {
              CliError::Io(<span class="kw">ref</span> err) =&gt; err.description(),
              CliError::Parse(<span class="kw">ref</span> err) =&gt; err.description(),
          }
      }
  
      <span class="kw">fn</span> cause(&amp;<span class="kw">self</span>) -&gt; <span class="kw">Option</span>&lt;&amp;error::Error&gt; {
          <span class="kw">match</span> *<span class="kw">self</span> {
              <span class="co">// В обоих случаях просходит неявное преобразование значения `err`</span>
              <span class="co">// из конкретного типа (`&amp;io::Error` или `&amp;num::ParseIntError`)</span>
              <span class="co">// в типаж-обьект `&amp;Error`. Это работает потому что оба типа реализуют `Er</span>
  ↳ ror`.
              CliError::Io(<span class="kw">ref</span> err) =&gt; <span class="kw">Some</span>(err),
              CliError::Parse(<span class="kw">ref</span> err) =&gt; <span class="kw">Some</span>(err),
          }
      }
  }</code></pre>
  <p>Хочется отметить, что это очень типичная реализация <code>Error</code>: реализация методов <code>description</code> и <code>cause</code> в соответствии с каждым возможным видом ошибки.</p>
  <p><a name="the-from-trait"></a></p>
  </section>
  <section id="типаж-from" class="level4">
  <h4>Типаж <code>From</code></h4>
  <p>Типаж <code>std::convert::From</code> объявлен в <a href="http://doc.rust-lang.org/std/convert/trait.From.html">стандартной библиотеке</a>:</p>
  <p><a name="code-from-def"></a></p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">trait</span> From&lt;T&gt; {
      <span class="kw">fn</span> from(T) -&gt; <span class="kw">Self</span>;
  }</code></pre>
  <p>Очень просто, не правда ли? Типаж <code>From</code> чрезвычайно полезен, поскольку создает общий подход для преобразования <em>из</em> определенного типа <code>Т</code> в какой-то другой тип (в данном случае, “другим типом” является тип, реализующий данный типаж, или <code>Self</code>). Самое важное в типаже <code>From</code> — <a href="http://doc.rust-lang.org/std/convert/trait.From.html">множество его реализаций, предоставляемых стандартной библиотекой</a>.</p>
  <p>Вот несколько простых примеров, демонстрирующих работу <code>From</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> string: String = From::from(<span class="st">&quot;foo&quot;</span>);
  <span class="kw">let</span> bytes: Vec&lt;<span class="kw">u8</span>&gt; = From::from(<span class="st">&quot;foo&quot;</span>);
  <span class="kw">let</span> cow: ::std::borrow::Cow&lt;<span class="kw">str</span>&gt; = From::from(<span class="st">&quot;foo&quot;</span>);</code></pre>
  <p>Итак, <code>From</code> полезен для выполнения преобразований между строками. Но как насчет ошибок? Оказывается, существует одна важная реализация:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">impl</span>&lt;<span class="ot">'a</span>, E: Error + <span class="ot">'a</span>&gt; From&lt;E&gt; <span class="kw">for</span> Box&lt;Error + <span class="ot">'a</span>&gt;</code></pre>
  <p>Эта реализация говорит, что <em>любой</em> тип, который реализует <code>Error</code>, можно конвертировать в типаж-объект <code>Box&lt;Error&gt;</code>. Выглядит не слишком впечатляюще, но это очень полезно в общем контексте.</p>
  <p>Помните те две ошибки, с которыми мы имели дело ранее, а именно, <code>io::Error</code> and <code>num::ParseIntError</code>? Поскольку обе они реализуют <code>Error</code>, они также работают с <code>From</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::error::Error;
  <span class="kw">use</span> std::fs;
  <span class="kw">use</span> std::io;
  <span class="kw">use</span> std::num;
  
  <span class="co">// Получаем значения ошибок</span>
  <span class="kw">let</span> io_err: io::Error = io::Error::last_os_error();
  <span class="kw">let</span> parse_err: num::ParseIntError = <span class="st">&quot;not a number&quot;</span>.parse::&lt;<span class="kw">i32</span>&gt;().unwrap_err();
  
  <span class="co">// Собственно, конвертация</span>
  <span class="kw">let</span> err1: Box&lt;Error&gt; = From::from(io_err);
  <span class="kw">let</span> err2: Box&lt;Error&gt; = From::from(parse_err);</code></pre>
  <p>Здесь нужно разобрать очень важный паттерн. Переменные <code>err1</code> и <code>err2</code> имеют <em>одинаковый тип</em> — типаж-объект. Это означает, что их реальные типы скрыты от компилятора, так что по факту он рассматривает <code>err1</code> и <code>err2</code> как одинаковые сущности. Кроме того, мы создали <code>err1</code> и <code>err2</code>, используя один и тот же вызов функции — <code>From::from</code>. Мы можем так делать, поскольку функция <code>From::from</code> перегружена по ее аргументу и возвращаемому типу.</p>
  <p>Эта возможность очень важна для нас, поскольку она решает нашу предыдущую проблему, позволяя эффективно конвертировать разные ошибки в один и тот же тип, пользуясь только одной функцией.</p>
  <p>Настало время вернуться к нашему старому другу — макросу <code>try!</code>.</p>
  <p><a name="the-real-try-macro"></a></p>
  </section>
  <section id="настоящий-макрос-try" class="level4">
  <h4>Настоящий макрос <code>try!</code></h4>
  <p>До этого мы привели такое определение <code>try!</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="ot">macro_rules!</span> try {
      ($e:expr) =&gt; (<span class="kw">match</span> $e {
          <span class="kw">Ok</span>(val) =&gt; val,
          <span class="kw">Err</span>(err) =&gt; <span class="kw">return</span> <span class="kw">Err</span>(err),
      });
  }</code></pre>
  <p>Но это не настоящее определение. Реальное определение можно найти в <a href="http://doc.rust-lang.org/std/macro.try!.html">стандартной библиотеке</a>:</p>
  <p><a name="code-try-def"></a></p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="ot">macro_rules!</span> try {
      ($e:expr) =&gt; (<span class="kw">match</span> $e {
          <span class="kw">Ok</span>(val) =&gt; val,
          <span class="kw">Err</span>(err) =&gt; <span class="kw">return</span> <span class="kw">Err</span>(::std::convert::From::from(err)),
      });
  }</code></pre>
  <p>Здесь есть одно маленькое, но очень важное изменение: значение ошибки пропускается через вызов <code>From::from</code>. Это делает макрос <code>try!</code> очень мощным инструментом, поскольку он дает нам возможность бесплатно выполнять автоматическое преобразование типов.</p>
  <p>Вооружившись более мощным макросом <code>try!</code>, давайте взглянем на код, написанный нами ранее, который читает файл и конвертирует его содержимое в число:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::fs::File;
  <span class="kw">use</span> std::io::Read;
  <span class="kw">use</span> std::path::Path;
  
  <span class="kw">fn</span> file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; <span class="kw">Result</span>&lt;<span class="kw">i32</span>, String&gt; {
      <span class="kw">let</span> <span class="kw">mut</span> file = <span class="ot">try!</span>(File::open(file_path).map_err(|e| e.to_string()));
      <span class="kw">let</span> <span class="kw">mut</span> contents = String::new();
      <span class="ot">try!</span>(file.read_to_string(&amp;<span class="kw">mut</span> contents).map_err(|e| e.to_string()));
      <span class="kw">let</span> n = <span class="ot">try!</span>(contents.trim().parse::&lt;<span class="kw">i32</span>&gt;().map_err(|e| e.to_string()));
      <span class="kw">Ok</span>(<span class="dv">2</span> * n)
  }</code></pre>
  <p>Ранее мы говорили, что мы можем избавиться от вызовов <code>map_err</code>. На самом деле, все что мы должны для этого сделать — это найти тип, который работает с <code>From</code>. Как мы увидели в предыдущем разделе, <code>From</code> имеет реализацию, которая позволяет преобразовать любой тип ошибки в <code>Box&lt;Error&gt;</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::error::Error;
  <span class="kw">use</span> std::fs::File;
  <span class="kw">use</span> std::io::Read;
  <span class="kw">use</span> std::path::Path;
  
  <span class="kw">fn</span> file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; <span class="kw">Result</span>&lt;<span class="kw">i32</span>, Box&lt;Error&gt;&gt; {
      <span class="kw">let</span> <span class="kw">mut</span> file = <span class="ot">try!</span>(File::open(file_path));
      <span class="kw">let</span> <span class="kw">mut</span> contents = String::new();
      <span class="ot">try!</span>(file.read_to_string(&amp;<span class="kw">mut</span> contents));
      <span class="kw">let</span> n = <span class="ot">try!</span>(contents.trim().parse::&lt;<span class="kw">i32</span>&gt;());
      <span class="kw">Ok</span>(<span class="dv">2</span> * n)
  }</code></pre>
  <p>Мы уже очень близки к идеальной обработке ошибок. Наш код имеет очень мало накладных расходов из-за обработки ошибок, ведь макрос <code>try!</code> инкапсулирует сразу три вещи:</p>
  <ol type="1">
  <li>Вариативный анализ.</li>
  <li>Поток выполнения.</li>
  <li>Преобразование типов ошибок.</li>
  </ol>
  <p>Когда все эти три вещи объединены вместе, мы получаем код, который не обременен комбинаторами, вызовами <code>unwrap</code> или постоянным анализом вариантов.</p>
  <p>Но осталась одна маленькая деталь: тип <code>Box&lt;Error&gt;</code> <em>не несет никакой информации</em>. Если мы возвращаем <code>Box&lt;Error&gt;</code> вызывающей стороне, нет никакой возможности (легко) узнать базовый тип ошибки. Ситуация, конечно, лучше, чем со <code>String</code>, посольку появилась возможность вызывать методы, вроде <a href="http://doc.rust-lang.org/std/error/trait.Error.html#tymethod.description"><code>description</code></a> или <a href="http://doc.rust-lang.org/std/error/trait.Error.html#method.cause"><code>cause</code></a>, но ограничение остается: <code>Box&lt;Error&gt;</code> не предоставляет никакой информации о сути ошибки. (Замечание: Это не совсем верно, поскольку в Rust есть инструменты рефлексии во время выполнения, которые полезны при некоторых сценариях, но их рассмотрение <a href="https://crates.io/crates/error">выходит за рамки этой главы</a>).</p>
  <p>Настало время вернуться к нашему собственному типу <code>CliError</code> и связать все в одно целое.</p>
  <p><a name="composing-custom-error-types"></a></p>
  </section>
  <section id="совмещение-собственных-типов-ошибок" class="level4">
  <h4>Совмещение собственных типов ошибок</h4>
  <p>В последнем разделе мы рассмотрели реальный макрос <code>try!</code> и то, как он выполняет автоматическое преобразование значений ошибок с помощью вызова <code>From::from</code>. В нашем случае мы конвертировали ошибки в <code>Box&lt;Error&gt;</code>, который работает, но его значение скрыто для вызывающей стороны.</p>
  <p>Чтобы исправить это, мы используем средство, с которым мы уже знакомы: создание собственного типа ошибки. Давайте вспомним код, который считывает содержимое файла и преобразует его в целое число:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::fs::File;
  <span class="kw">use</span> std::io::{<span class="kw">self</span>, Read};
  <span class="kw">use</span> std::num;
  <span class="kw">use</span> std::path::Path;
  
  <span class="co">// Мы реализуем `Debug` поскольку, по всей видимости, все типы должны реализовывать `D</span>
  ↳ ebug`.
  <span class="co">// Это дает нам возможность получить адекватное и читаемое описание значения CliError</span>
  <span class="ot">#[</span>derive<span class="ot">(</span>Debug<span class="ot">)]</span>
  <span class="kw">enum</span> CliError {
      Io(io::Error),
      Parse(num::ParseIntError),
  }
  
  <span class="kw">fn</span> file_double_verbose&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; <span class="kw">Result</span>&lt;<span class="kw">i32</span>, CliError&gt; {
      <span class="kw">let</span> <span class="kw">mut</span> file = <span class="ot">try!</span>(File::open(file_path).map_err(CliError::Io));
      <span class="kw">let</span> <span class="kw">mut</span> contents = String::new();
      <span class="ot">try!</span>(file.read_to_string(&amp;<span class="kw">mut</span> contents).map_err(CliError::Io));
      <span class="kw">let</span> n: <span class="kw">i32</span> = <span class="ot">try!</span>(contents.trim().parse().map_err(CliError::Parse));
      <span class="kw">Ok</span>(<span class="dv">2</span> * n)
  }</code></pre>
  <p>Обратите внимание, что здесь у нас еще остались вызовы <code>map_err</code>. Почему? Вспомните определения <a href="#code-try-def"><code>try!</code></a> и <a href="#code-from-def"><code>From</code></a>. Проблема в том, что не существует такой реализации <code>From</code>, которая позволяет конвертировать типы ошибок <code>io::Error</code> и <code>num::ParseIntError</code> в наш собственный тип <code>CliError</code>. Но мы можем легко это исправить! Поскольку мы определили тип <code>CliError</code>, мы можем также реализовать для него типаж <code>From</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::io;
  <span class="kw">use</span> std::num;
  
  <span class="kw">impl</span> From&lt;io::Error&gt; <span class="kw">for</span> CliError {
      <span class="kw">fn</span> from(err: io::Error) -&gt; CliError {
          CliError::Io(err)
      }
  }
  
  <span class="kw">impl</span> From&lt;num::ParseIntError&gt; <span class="kw">for</span> CliError {
      <span class="kw">fn</span> from(err: num::ParseIntError) -&gt; CliError {
          CliError::Parse(err)
      }
  }</code></pre>
  <p>Все эти реализации позволяют <code>From</code> создавать значения <code>CliError</code> из других типов ошибок. В нашем случае такое создание состоит из простого вызова конструктора значения. <em>Как правило</em>, это все что нужно.</p>
  <p>Наконец, мы можем переписать <code>file_double</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">
  <span class="kw">use</span> std::fs::File;
  <span class="kw">use</span> std::io::Read;
  <span class="kw">use</span> std::path::Path;
  
  <span class="kw">fn</span> file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; <span class="kw">Result</span>&lt;<span class="kw">i32</span>, CliError&gt; {
      <span class="kw">let</span> <span class="kw">mut</span> file = <span class="ot">try!</span>(File::open(file_path));
      <span class="kw">let</span> <span class="kw">mut</span> contents = String::new();
      <span class="ot">try!</span>(file.read_to_string(&amp;<span class="kw">mut</span> contents));
      <span class="kw">let</span> n: <span class="kw">i32</span> = <span class="ot">try!</span>(contents.trim().parse());
      <span class="kw">Ok</span>(<span class="dv">2</span> * n)
  }</code></pre>
  <p>Единственное, что мы сделали — это удалили вызовы <code>map_err</code>. Они нам больше не нужны, поскольку макрос <code>try!</code> выполняет <code>From::from</code> над значениями ошибок. И это работает, поскольку мы предоставили реализации <code>From</code> для всех типов ошибок, которые могут возникнуть.</p>
  <p>Если бы мы изменили нашу функцию <code>file_double</code> таким образом, чтобы она начала выполнять какие-то другие операции, например, преобразовать строку в число с плавающей точкой, то мы должны были бы добавить новый вариант к нашему типу ошибок:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::io;
  <span class="kw">use</span> std::num;
  
  <span class="kw">enum</span> CliError {
      Io(io::Error),
      ParseInt(num::ParseIntError),
      ParseFloat(num::ParseFloatError),
  }</code></pre>
  <p>И добавить новую реализацию для <code>From</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">
  <span class="kw">use</span> std::num;
  
  <span class="kw">impl</span> From&lt;num::ParseFloatError&gt; <span class="kw">for</span> CliError {
      <span class="kw">fn</span> from(err: num::ParseFloatError) -&gt; CliError {
          CliError::ParseFloat(err)
      }
  }</code></pre>
  <p>Вот и все!</p>
  <p><a name="advice-for-library-writers"></a></p>
  </section>
  <section id="рекомендации-для-авторов-библиотек" class="level4">
  <h4>Рекомендации для авторов библиотек</h4>
  <p>Если в вашей библиотеке могут возникать специфические ошибки, то вы наверняка должны определить для них свой собственный тип. На ваше усмотрение вы можете сделать его внутреннее представление публичным (как <a href="http://doc.rust-lang.org/std/io/enum.ErrorKind.html"><code>ErrorKind</code></a>), или оставить его скрытым (подобно <a href="http://doc.rust-lang.org/std/num/struct.ParseIntError.html"><code>ParseIntError</code></a>). Независимо от того, что вы предпримете, считается хорошим тоном обеспечить по крайней мере некоторую информацию об ошибке помимо ее строкового представления. Но, конечно, все зависит от конкретных случаев использования.</p>
  <p>Как минимум, вы скорее всего должны реализовать типаж <a href="http://doc.rust-lang.org/std/error/trait.Error.html"><code>Error</code></a>. Это даст пользователям вашей библиотеки некоторую минимальную гибкость при <a href="#the-real-try-macro">совмещении ошибок</a>. Реализация типажа <code>Error</code> также означает, что пользователям гарантируется возможность получения строкового представления ошибки (это следует из необходимости реализации <code>fmt::Debug</code> и <code>fmt::Display</code>).</p>
  <p>Кроме того, может быть полезным реализовать <code>From</code> для ваших типов ошибок. Это позволит вам (как автору библиотеки) и вашим пользователям <a href="#composing-custom-error-types">совмещать более детальные ошибки</a>. Например, <a href="http://burntsushi.net/rustdoc/csv/enum.Error.html"><code>csv::Error</code></a> реализует <code>From</code> для <code>io::Error</code> и <code>byteorder::Error</code>.</p>
  <p>Наконец, на свое усмотрение, вы также можете определить <a href="#the-result-type-alias-idiom">псевдоним типа <code>Result</code></a>, особенно, если в вашей библиотеке определен только один тип ошибки. Такой подход используется в стандартной библиотеке для <a href="http://doc.rust-lang.org/std/io/type.Result.html"><code>io::Result</code></a> и <a href="http://doc.rust-lang.org/std/fmt/type.Result.html"><code>fmt::Result</code></a>.</p>
  <p><a name="the-short-story"></a></p>
  </section>
  </section>
  <section id="заключение-2" class="level3">
  <h3>Заключение</h3>
  <p>Поскольку это довольно длинная глава, не будет лишним составить короткий конспект по обработке ошибок в Rust. Ниже будут приведены некоторые практические рекомендации. Это совсем <em>не</em> заповеди. Наверняка существуют веские причины для того, чтобы нарушить любое из этих правил.</p>
  <ul>
  <li>Если вы пишете короткий пример кода, который может быть перегружен обработкой ошибок, это, вероятно, отличная возможность использовать <code>unwrap</code> (будь-то <a href="http://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap"><code>Result::unwrap</code></a>, <a href="http://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap"><code>Option::unwrap</code></a> или <a href="http://doc.rust-lang.org/std/option/enum.Option.html#method.expect"><code>Option::expect</code></a>). Те, для кого предназначен пример, должны осознавать, что необходимо реализовать надлежащую обработку ошибок. (Если нет, отправляйте их сюда!)</li>
  <li>Если вы пишете одноразовую программу, также не зазорно использовать <code>unwrap</code>. Но будьте внимательны: если ваш код попадет в чужие руки, не удивляйтесь, если кто-то будет расстроен из-за скудных сообщений об ошибках!</li>
  <li>Если вы пишете одноразовый код, но вам все-равно стыдно из-за использования <code>unwrap</code>, воспользуйтесь либо <code>String</code> в качестве типа ошибки, либо <code>Box&lt;Error + Send + Sync&gt;</code> (из-за <a href="http://doc.rust-lang.org/std/convert/trait.From.html">доступных реализаций <code>From</code></a>.)</li>
  <li>В остальных случаях, определяйте свои собственные типы ошибок с соответствующими реализациями <a href="http://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> и <a href="http://doc.rust-lang.org/std/error/trait.Error.html"><code>Error</code></a>, делая использование <a href="http://doc.rust-lang.org/std/macro.try!.html"><code>try!</code></a> более удобным.</li>
  <li>Если вы пишете библиотеку и ваш код может выдавать ошибки, определите ваш собственный тип ошибки и реализуйте типаж <a href="http://doc.rust-lang.org/std/error/trait.Error.html"><code>std::error::Error</code></a>. Там, где это уместно, реализуйте <a href="http://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a>, чтобы вам и вашим пользователям было легче с ними работать. (Из-за правил когерентности в Rust, пользователи вашей библиотеки не смогут реализовать <code>From</code> для ваших ошибок, поэтому это должна сделать ваша библиотека.)</li>
  <li>Изучите комбинаторы, определенные для <a href="http://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a> и <a href="http://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a>. Писать код, пользуясь только ними может быть немного утомительно, но я лично нашел для себя хороший баланс между использованием <code>try!</code> и комбинаторами (<code>and_then</code>, <code>map</code> и <code>unwrap_or</code> — мои любимые).</li>
  </ul>
  </section>
  </section>
  <section id="sec--choosing-your-guarantees" class="level2">
  <h2>Выбор гарантий</h2>
  <p>Одна из важных черт языка Rust — это то, что он позволяет нам управлять накладными расходами и гарантиями программы.</p>
  <p>В стандартной библиотеке Rust есть различные «обёрточные типы», которые реализуют множество компромиссов между накладными расходами, эргономикой, и гарантиями. Многие позволяют выбирать между проверками во время компиляции и проверками во время исполнения. Эта глава подробно объяснит несколько избранных абстракций.</p>
  <p>Перед тем, как продолжить, крайне рекомендуем познакомиться с <a href="#sec--ownership">владением</a> и <a href="#sec--references-and-borrowing">заимствованием</a> в Rust.</p>
  <section id="основные-типы-указателей" class="level3">
  <h3>Основные типы указателей</h3>
  <section id="boxt" class="level4">
  <h4><code>Box&lt;T&gt;</code></h4>
  <p><a href="https://doc.rust-lang.org/stable/std/boxed/struct.Box.html"><code>Box&lt;T&gt;</code></a> — «владеющий» указатель, или, по-другому, «упаковка». Хотя он и может выдавать ссылки на содержащиеся в нём данные, он — единственный владелец этих данных. В частности, когда происходит что-то вроде этого:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = Box::new(<span class="dv">1</span>);
  <span class="kw">let</span> y = x;
  <span class="co">// x больше не доступен</span></code></pre>
  <p>Здесь упаковка была <em>перемещена</em> в <code>y</code>. Поскольку <code>x</code> больше не владеет ею, с этого момента компилятор не позволит использовать <code>x</code>. Упаковка также может быть перемещена <em>из</em> функции — для этого функция возвращает её как свой результат.</p>
  <p>Когда упаковка, которая не была перемещена, выходит из области видимости, выполняются деструкторы. Эти деструкторы освобождают содержащиеся данные.</p>
  <p>Мы абстрагируемся от динамического выделения памяти, и это абстракция без накладных расходов. Это идеальный способ выделить память в куче и безопасно передавать указатель на эту память. Заметьте, что вы можете создавать ссылки на упаковку по обычным правилам заимствования, которые проверяются во время компиляции.</p>
  </section>
  <section id="t-и-mut-t" class="level4">
  <h4><code>&amp;T</code> и <code>&amp;mut T</code></h4>
  <p>Это неизменяемые и изменяемые ссылки, соответственно. Они реализуют шаблон «read-write lock», т.е. вы можете создать или одну изменяемую ссылку на данные, или любое число неизменяемых, но не оба вида ссылок одновременно. Эта гарантия проверяется во время компиляции, и ничего не стоит во время исполнения. В большинстве случаев эти два типа указателей покрывают все нужды по передаче дешёвых ссылок между частями кода.</p>
  <p>При копировании эти указатели сохраняют связанное с ними время жизни — они всё равно не могут прожить дольше, чем исходное значение, на которое они ссылаются.</p>
  </section>
  <section id="const-t-и-mut-t" class="level4">
  <h4><code>*const T</code> и <code>*mut T</code></h4>
  <p>Это сырые указатели в стиле C, не имеющие связанной информации о времени жизни и владельце. Они просто указывают на какое-то место в памяти, без дополнительных ограничений. Они гарантируют только то, что они могут быть разыменованы только в коде, помеченном как «небезопасный».</p>
  <p>Они полезны при создании безопасных низкоуровневых абстракций вроде <code>Vec&lt;T&gt;</code>, но их следует избегать в безопасном коде.</p>
  </section>
  <section id="rct" class="level4">
  <h4><code>Rc&lt;T&gt;</code></h4>
  <p>Это первая рассматриваемая обёртка, использование которой влечёт за собой накладные расходы во время исполнения.</p>
  <p><a href="https://doc.rust-lang.org/stable/std/rc/struct.Rc.html"><code>Rc&lt;T&gt;</code></a> — это указатель со счётчиком ссылок. Другими словами, он позволяет создавать несколько «владеющих» указателей на одни и те же данные, и эти данные будут уничтожены, когда все указатели выйдут из области видимости.</p>
  <p>Собственно, внутри у него счётчик ссылок (reference count, или сокращённо refcount), который увеличивается каждый раз, когда происходит клонирование <code>Rc</code>, и уменьшается когда <code>Rc</code> выходит из области видимости. Основная ответственность <code>Rc&lt;T&gt;</code> — удостовериться в том, что для разделяемых данных вызываются деструкторы.</p>
  <p>Хранимые данные при этом неизменяемы, и если создаётся цикл ссылок, данные утекут. Если нам нужно отсутствие утечек в присутствие циклов, нужно использовать сборщик мусора.</p>
  <section id="гарантии" class="level6">
  <h6>Гарантии</h6>
  <p>Здесь главная гарантия в том, что данные не будут уничтожены, пока все ссылки на них не исчезнут.</p>
  <p>Счётчик ссылок нужно использовать, когда мы хотим динамически выделить какие-то данные и предоставить ссылки на эти данные только для чтения, и при этом неясно, какая часть программы последней закончит использование ссылки. Это подходящая альтернатива <code>&amp;T</code>, когда невозможно статически доказать правильность <code>&amp;T</code>, или когда это создаёт слишком большие неудобства в написании кода, на который разработчик не хочет тратить своё время.</p>
  <p>Этот указатель <em>не</em> является потокобезопасным, и Rust не позволяет передавать его или делиться им с другими потоками. Это позволяет избежать накладных расходов от использования атомарных операций там, где они не нужны.</p>
  <p>Есть похожий умный указатель, <code>Weak&lt;T&gt;</code>. Это невладеющий, но и не заимствуемый, умный указатель. Он тоже похож на <code>&amp;T</code>, но не ограничен временем жизни — <code>Weak&lt;T&gt;</code> можно не отпускать. Однако, возможна ситуация, когда попытка доступа к хранимым в нём данным провалится и вернёт <code>None</code>, поскольку <code>Weak&lt;T&gt;</code> может пережить владеющие <code>Rc</code>. Его удобно использовать в случае циклических структур данных и некоторых других.</p>
  </section>
  <section id="накладные-расходы" class="level6">
  <h6>Накладные расходы</h6>
  <p>Что касается памяти, <code>Rc&lt;T&gt;</code> — это одно выделение, однако оно будет включать два лишних слова (т.е. два значения типа <code>usize</code>) по сравнению с обычным <code>Box&lt;T&gt;</code>. Это верно и для «сильных», и для «слабых» счётчиков ссылок.</p>
  <p>Расходы на <code>Rc&lt;T&gt;</code> заключаются в увеличении и уменьшении счётчика ссылок каждый раз, когда <code>Rc&lt;T&gt;</code> клонируется или выходит из области видимости, соответственно. Отметим, что клонирование не выполняет глубокое копирование, а просто увеличивает счётчик и возвращает копию <code>Rc&lt;T&gt;</code>.</p>
  </section>
  </section>
  </section>
  <section id="типы-ячейки-cell-types" class="level3">
  <h3>Типы-ячейки (cell types)</h3>
  <p>Типы <code>Cell</code> предоставляют «внутреннюю» изменяемость. Другими словами, они содержат данные, которые можно изменять даже если тип не может быть получен в изменяемом виде (например, когда он за указателем <code>&amp;</code> или за <code>Rc&lt;T&gt;</code>).</p>
  <p><a href="https://doc.rust-lang.org/stable/std/cell/">Документация модуля <code>cell</code> довольно хорошо объясняет эти вещи</a>.</p>
  <p>Эти типы <em>обычно</em> используют в полях структур, но они не ограничены таким использованием.</p>
  <section id="cellt" class="level4">
  <h4><code>Cell&lt;T&gt;</code></h4>
  <p><a href="https://doc.rust-lang.org/stable/std/cell/struct.Cell.html"><code>Cell&lt;T&gt;</code></a> — это тип, который обеспечивает внутреннюю изменяемость без накладных расходов, но только для типов, реализующих типаж <code>Copy</code>. Поскольку компилятор знает, что все данные, вложенные в <code>Cell&lt;T&gt;</code>, находятся на стеке, их можно просто заменять без страха утечки ресурсов.</p>
  <p>Нарушить инварианты с помощью этой обёртки всё равно можно, поэтому будьте осторожны при её использовании. Если поле обёрнуто в <code>Cell</code>, это индикатор того, что эти данные изменяемы и поле может не сохранить своё значение с момента чтения до момента его использования.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::cell::Cell;
  
  <span class="kw">let</span> x = Cell::new(<span class="dv">1</span>);
  <span class="kw">let</span> y = &amp;x;
  <span class="kw">let</span> z = &amp;x;
  x.set(<span class="dv">2</span>);
  y.set(<span class="dv">3</span>);
  z.set(<span class="dv">4</span>);
  <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, x.get());</code></pre>
  <p>Заметьте, что здесь мы смогли изменить значение через различные ссылки без права изменения.</p>
  <p>В плане затрат во время исполнения, такой код аналогичен нижеследующему:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> x = <span class="dv">1</span>;
  <span class="kw">let</span> y = &amp;<span class="kw">mut</span> x;
  <span class="kw">let</span> z = &amp;<span class="kw">mut</span> x;
  x = <span class="dv">2</span>;
  *y = <span class="dv">3</span>;
  *z = <span class="dv">4</span>;
  <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, x);</code></pre>
  <p>но имеет преимущество в том, что он действительно компилируется.</p>
  <section id="гарантии-1" class="level6">
  <h6>Гарантии</h6>
  <p>Этот тип ослабляет правило отсутствия совпадающих указателей с правом записи там, где оно не нужно. Однако, он также ослабляет гарантии, которые предоставляет такое ограничение; поэтому если ваши инварианты зависят от данных, хранимых в <code>Cell</code>, будьте осторожны.</p>
  <p>Это применяется при изменении примитивов и других типов, реализующих <code>Copy</code>, когда нет лёгкого способа сделать это в соответствии с статическими правилами <code>&amp;</code> и <code>&amp;mut</code>.</p>
  <p><code>Cell</code> не позволяет получать внутрение ссылки на данные, что позволяет безопасно менять его содержимое.</p>
  </section>
  <section id="накладные-расходы-1" class="level6">
  <h6>Накладные расходы</h6>
  <p>Накладные расходы при использовании <code>Cell&lt;T&gt;</code> отсутствуют, однако если вы оборачиваете в него большие структуры, есть смысл вместо этого обернуть отдельные поля, поскольку иначе каждая запись будет производить полное копирование структуры.</p>
  </section>
  </section>
  <section id="refcellt" class="level4">
  <h4><code>RefCell&lt;T&gt;</code></h4>
  <p><a href="https://doc.rust-lang.org/stable/std/cell/struct.RefCell.html"><code>RefCell&lt;T&gt;</code></a> также предоставляет внутреннюю изменяемость, но не ограничен только типами, реализующими <code>Copy</code>.</p>
  <p>Однако, у этого решения есть накладные расходы. <code>RefCell&lt;T&gt;</code> реализует шаблон «read-write lock» во время исполнения, а не во время компиляции, как <code>&amp;T</code>/ <code>&amp;mut T</code>. Он похож на однопоточный мьютекс. У него есть функции <code>borrow()</code> и <code>borrow_mut()</code>, которые изменяют внутрений счётчик ссылок и возвращают умный указатель, который может быть разыменован без права изменения или с ним, соответственно. Счётчик ссылок восстанавливается, когда умные указатели выходят из области видимости. С этой системой мы можем динамически гарантировать, что во время заимствования с правом изменения никаких других ссылок на значение больше нет. Если программист пытается позаимствовать значение в этот момент, поток запаникует.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::cell::RefCell;
  
  <span class="kw">let</span> x = RefCell::new(<span class="ot">vec!</span>[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]);
  {
      <span class="ot">println!</span>(<span class="st">&quot;{:?}&quot;</span>, *x.borrow())
  }
  
  {
      <span class="kw">let</span> <span class="kw">mut</span> my_ref = x.borrow_mut();
      my_ref.push(<span class="dv">1</span>);
  }</code></pre>
  <p>Как и <code>Cell</code>, это в основном применяется в ситуациях, когда сложно или невозможно удовлетворить статическую проверку заимствования. В целом мы знаем, что такие изменения не будут происходить вложенным образом, но это стоит дополнительно проверить.</p>
  <p>Для больших, сложных программ, есть смысл положить некоторые вещи в <code>RefCell</code>, чтобы упростить работу с ними. Например, многие словари в структуре <code>ctxt</code>[ctxt] в компиляторе Rust обёрнуты в этот тип. Они изменяются только однажды — во время создания, но не во время инициализации, или несколько раз в явно отдельных местах. Однако, поскольку эта структура повсеместно используется везде, жонглирование изменяемыми и неизменяемыми указателями было бы очень сложным (или невозможным), и наверняка создало бы мешанину указателей <code>&amp;</code>, которую сложно было бы расширять. С другой стороны, <code>RefCell</code> предоставляет дешёвый (но не бесплатный) способ обращаться к таким данным. В будущем, если кто-то добавит код, который пытается изменить ячейку, пока она заимствована, это вызывет панику, источник которой можно отследить. И такая паника обычно происходит детерминированно.</p>
  <p>Похожим образом, в DOM Servo много изменения данных, большая часть которого происходит внутри типа DOM, но часть выходит за его границы и изменяет произвольные вещи. Использование <code>RefCell</code> и <code>Cell</code> для ограждения этих изменений позволяет нам избежать необходимости беспокоиться об изменяемости везде, и одновременно обозначает места, где изменение <em>действительно</em> происходит.</p>
  <p>Заметьте, что стоит избегать использования <code>RefCell</code>, если возможно достаточно простое решение с помощью указателей <code>&amp;</code>.</p>
  <section id="гарантии-2" class="level6">
  <h6>Гарантии</h6>
  <p><code>RefCell</code> ослабляет <em>статические</em> ограничения, предотвращающие совпадение изменяемых указателей, и заменяет их на <em>динамические</em> ограничения. Сами гарантии при этом не изменяются.</p>
  </section>
  <section id="накладные-расходы-2" class="level6">
  <h6>Накладные расходы</h6>
  <p><code>RefCell</code> не выделяет память, но содержит дополнительный индикатор «состояния заимствования» (размером в одно слово) вместе с данными.</p>
  <p>Во время исполнения каждое заимствование вызывает изменение и проверку счётчика ссылок.</p>
  </section>
  </section>
  </section>
  <section id="синхронизированные-типы" class="level3">
  <h3>Синхронизированные типы</h3>
  <p>Многие из вышеперечисленных типов не могут быть использованы потокобезопасным образом. В частности, <code>Rc&lt;T&gt;</code> и <code>RefCell&lt;T&gt;</code>, оба из которых используют не-атомарные счётчики ссылок, не могут быть использованы так. (<em>Атомарные</em> счётчики ссылок — это такие, которые могут быть увеличены из нескольких потоков, не вызывая при этом гонку данных.) Благодаря этому они привносят меньше накладных расходов, но нам также потребуются и потокобезопасные варианты этих типов. Они существуют — это <code>Arc&lt;T&gt;</code> и <code>Mutex&lt;T&gt;</code>/<code>RWLock&lt;T&gt;</code>.</p>
  <p>Заметьте, что не-потокобезопасные типы <em>не могут</em> быть переданы между потоками, и это проверяется во время компиляции.</p>
  <p>В модуле <a href="https://doc.rust-lang.org/stable/std/sync/index.html">sync</a> много полезных обёрточных типов для многопоточного программирования, но мы затронем только главные из них.</p>
  <section id="arct" class="level4">
  <h4><code>Arc&lt;T&gt;</code></h4>
  <p><a href="https://doc.rust-lang.org/stable/std/sync/struct.Arc.html"><code>Arc&lt;T&gt;</code></a> — это вариант <code>Rc&lt;T&gt;</code>, который использует атомарный счётчик ссылок (поэтому «Arc»). Его можно свободно передавать между потоками.</p>
  <p><code>shared_ptr</code> из C++ похож на <code>Arc</code>, но в случае C++ вложенные данные всегда изменяемы. Чтобы получить семантику, похожую на семантику C++, нужно использовать <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>, <code>Arc&lt;RwLock&lt;T&gt;&gt;</code>, или <code>Arc&lt;UnsafeCell&lt;T&gt;&gt;</code><a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>. (<code>UnsafeCell&lt;T&gt;</code> — это тип-ячейка, который может содержать любые данные и не имеет накладных расходов, но доступ к его содержимому производится только внутри небезопасных блоков.) Последний стоит использовать только тогда, когда мы уверены в том, что наша работа не вызывет нарушения безопасности памяти. Учитывайте, что запись в структуру не атомарна, а многие функции вроде <code>vec.push()</code> могут выделять память заново в процессе работы, и тем самым вызывать небезопасное поведение.</p>
  <section id="гарантии-3" class="level6">
  <h6>Гарантии</h6>
  <p>Как и <code>Rc</code>, этот тип гарантирует, что деструктор хранимых в нём данных будет вызван, когда последний <code>Arc</code> выходит из области видимости (за исключением случаев с циклами). В отличие от <code>Rc</code>, <code>Arc</code> предоставляет эту гарантию и в многопоточном окружении.</p>
  </section>
  <section id="накладные-расходы-3" class="level6">
  <h6>Накладные расходы</h6>
  <p>Накладные расходы увеличиваются по сравнению с <code>Rc</code>, т.к. теперь для изменения счётчика ссылок используются атомарные операции (которые происходят каждый раз при клонировании или выходе из области видимости). Когда вы хотите поделиться данными в пределах одного потока, предпочтительнее использовать простые ссылки <code>&amp;</code>.</p>
  </section>
  </section>
  <section id="mutext-and-rwlockt" class="level4">
  <h4><code>Mutex&lt;T&gt;</code> and <code>RwLock&lt;T&gt;</code></h4>
  <p><a href="https://doc.rust-lang.org/stable/std/sync/struct.Mutex.html"><code>Mutex&lt;T&gt;</code></a> и <a href="https://doc.rust-lang.org/stable/std/sync/struct.RwLock.html"><code>RwLock&lt;T&gt;</code></a> предоставляют механизм взаимоисключения с помощью охранных значений RAII. Охранные значения — это объекты, имеющие некоторое состояние, как замок, пока не выполнится их деструктор. В обоих случаях, мьютекс непрозрачен, пока на нём не вызовут <code>lock()</code>, после чего поток остановится до момента, когда мьютекс может быть закрыт, после чего возвращается охранное значение. Оно может быть использовано для доступа к вложенным данным с правом изменения, а мьютекс будет снова открыт, когда охранное значение выйдет из области видимости.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">{
      <span class="kw">let</span> guard = mutex.lock();
      <span class="co">// охранное значение разыменовывается в изменяемое значение</span>
      <span class="co">// вложенного в мьютекс типа</span>
      *guard += <span class="dv">1</span>;
  } <span class="co">// мьютекс открывается когда выполняется деструктор</span></code></pre>
  <p><code>RwLock</code> имеет преимущество — он эффективно работает в случае множественных чтений. Ведь читать из общих данных всегда безопасно, пока в эти данные никто не хочет писать; и <code>RwLock</code> позволяет читающим получить «право чтения». Право чтения может быть получено многими потоками одновременно, и за читающими следит счётчик ссылок. Тот же, кто хочет записать данные, должен получить «право записи», а оно может быть получено только когда все читающие вышли из области видимости.</p>
  <section id="гарантии-4" class="level6">
  <h6>Гарантии</h6>
  <p>Оба этих типа предоставляют безопасное изменение данных из разных потоков, но не защищают от взаимной блокировки (deadlock). Некоторая дополнительная безопасность протокола работы с данными может быть получена с помощью системы типов.</p>
  </section>
  <section id="накладные-расходы-4" class="level6">
  <h6>Накладные расходы</h6>
  <p>Для поддержания состояния прав чтения и записи эти типы используют в своей реализации конструкции, похожие на атомарные типы, и они довольно дороги. Они могут блокировать все межпроцессорные чтения из памяти, пока не закончат работу. Ожидание возможности закрытия этих примитивов синхронизации тоже может быть медленным, когда производится много одновременных попыток доступа к данным.</p>
  </section>
  </section>
  </section>
  <section id="сочетание" class="level3">
  <h3>Сочетание</h3>
  <p>Распространённая жалоба на код на Rust — это сложность чтения типов вроде <code>Rc&lt;RefCell&lt;Vec&lt;T&gt;&gt;&gt;</code> (или ещё более сложных сочетаний похожих типов). Не всегда понятно, что делает такая комбинация, или почему автор решил использовать именно такой тип. Не ясно и то, в каких случаях сам программист должен использовать похожие сочетания типов.</p>
  <p>Обычно, вам понадобятся такие типы, когда вы хотите сочетать гарантии разных типов, но не хотите переплачивать за то, что вам не нужно.</p>
  <p>Например, одно из таких сочетаний — это <code>Rc&lt;RefCell&lt;T&gt;&gt;</code>. Сам по себе <code>Rc&lt;T&gt;</code> не может быть разыменован с правом изменения; поскольку <code>Rc&lt;T&gt;</code> позволяет делиться данными и одновременная попытка изменения данных может привести к небезопасному поведению, мы кладём внутрь <code>RefCell&lt;T&gt;</code>, чтобы получить динамическую проверку одновременных попыток изменения. Теперь у нас есть разделяемые изменяемые данные, но одновременный доступ к ним предоставляется только на чтение, а запись всегда исключительна.</p>
  <p>Далее мы можем развить эту мысль и получить <code>Rc&lt;RefCell&lt;Vec&lt;T&gt;&gt;&gt;</code> или <code>Rc&lt;Vec&lt;RefCell&lt;T&gt;&gt;&gt;</code>. Это — изменяемые, разделяемые между потоками вектора, но они не одинаковы.</p>
  <p>В первом типе <code>RefCell&lt;T&gt;</code> оборачивает <code>Vec&lt;T&gt;</code>, поэтому изменяем весь <code>Vec&lt;T&gt;</code> целиком. В то же время, это значит, что в каждый момент времени может быть только одна ссылка на <code>Vec&lt;T&gt;</code> с правом изменения. Поэтому код не может одновременно работать с разными элементами вектора, обращаясь к ним через разные <code>Rc</code>. Однако, мы сможем добавлять и удалять элементы вектора в произвольные моменты времени. Этот тип похож на <code>&amp;mut Vec&lt;T&gt;</code>, с тем различием, что проверка заимствования делается во время исполнения.</p>
  <p>Во втором типе заимствуются отдельные элементы, а вектор в целом неизменяем. Поэтому мы можем получить ссылки на отдельные элементы, но не можем добавлять или удалять элементы. Это похоже на <code>&amp;mut [T]</code><a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>, но, опять-таки, проверка заимствования производится во время исполнения.</p>
  <p>В многопоточных программах возникает похожая ситуация с <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>, который обеспечивает разделяемое владение и одновременное изменение.</p>
  <p>Когда вы читаете такой код, рассматривайте гарантии и накладные расходы каждого вложенного типа шаг за шагом.</p>
  <p>Когда вы выбираете сложный тип, поступайте наоборот: решите, какие гарантии вам нужны, и в каком «слое» сочетания они понадобятся. Например, если у вас стоит выбор между <code>Vec&lt;RefCell&lt;T&gt;&gt;</code> и <code>RefCell&lt;Vec&lt;T&gt;&gt;</code>, найдите компромисс путём рассуждений, как мы делали выше по тексту, и выберите нужный вам тип.</p>
  </section>
  </section>
  <section id="sec--ffi" class="level2">
  <h2>Интерфейс внешних функций (FFI)</h2>
  <section id="введение" class="level3">
  <h3>Введение</h3>
  <p>В данном руководстве в качестве примера мы будем использовать <a href="https://github.com/google/snappy">snappy</a>, библиотеку для сжатия/распаковки данных. Мы реализуем Rust-интерфейс к этой библиотеке через вызов внешних функций. Rust в настоящее время не в состоянии делать вызовы напрямую в библиотеки C++, но snappy включает в себя интерфейс C (документирован в <a href="https://github.com/google/snappy/blob/master/snappy-c.h"><code>snappy-c.h</code></a>).</p>
  <p>Ниже приведен минимальный пример вызова внешней функции, который будет скомпилирован при условии, что библиотека snappy установлена:</p>
  <pre class="no_run"><code># #![feature(libc)]
  extern crate libc;
  use libc::size_t;
  
  #[link(name = &quot;snappy&quot;)]
  extern {
      fn snappy_max_compressed_length(source_length: size_t) -&gt; size_t;
  }
  
  fn main() {
      let x = unsafe { snappy_max_compressed_length(100) };
      println!(&quot;максимальный размер сжатого буфера длиной 100 байт: {}&quot;, x);
  }</code></pre>
  <p>Блок <code>extern</code> содержит список сигнатур функций из внешней библиотеки, в данном случае для C ABI (application binary interface; двоичный интерфейс приложений) данной платформы. Чтобы указать, что программу нужно компоновать с библиотекой snappy, используется атрибут <code>#[link(...)]</code>. Благодаря этому, символы будут успешно разрешены.</p>
  <p>Предполагается, что внешние функции могут быть небезопасными, поэтому их вызовы должны быть обёрнуты в блок <code>unsafe {}</code> как обещание компилятору, что все внутри этого блока в действительности безопасно. Библиотеки C часто предоставляют интерфейсы, которые не являются потоко-безопасными. И почти любая функция, которая принимает в качестве аргумента указатель, не может принимать любое входное значений, поскольку указатель может быть висячим; сырые указатели выходят за пределы безопасной модели памяти в Rust.</p>
  <p>При объявлении типов аргументов для внешней функции, компилятор Rust не может проверить, является ли данное объявление корректным. Поэтому важно правильно указать тип привязываемой функции — иначе ошибка обнаружится только во время исполнения.</p>
  <p>Блок <code>extern</code> может быть распространён на весь API snappy:</p>
  <pre class="no_run"><code># #![feature(libc)]
  extern crate libc;
  use libc::{c_int, size_t};
  
  #[link(name = &quot;snappy&quot;)]
  extern {
      fn snappy_compress(input: *const u8,
                         input_length: size_t,
                         compressed: *mut u8,
                         compressed_length: *mut size_t) -&gt; c_int;
      fn snappy_uncompress(compressed: *const u8,
                           compressed_length: size_t,
                           uncompressed: *mut u8,
                           uncompressed_length: *mut size_t) -&gt; c_int;
      fn snappy_max_compressed_length(source_length: size_t) -&gt; size_t;
      fn snappy_uncompressed_length(compressed: *const u8,
                                    compressed_length: size_t,
                                    result: *mut size_t) -&gt; c_int;
      fn snappy_validate_compressed_buffer(compressed: *const u8,
                                           compressed_length: size_t) -&gt; c_int;
  }
  # fn main() {}</code></pre>
  </section>
  <section id="создание-безопасного-интерфейса" class="level3">
  <h3>Создание безопасного интерфейса</h3>
  <p>Сырой C API (application programming interface; интерфейс программирования приложений) необходимо обернуть, чтобы обеспечить безопасность памяти. Тогда мы сможем использовать концепции более высокого уровня, такие как векторы. Библиотека может выборочно открывать только безопасный, высокоуровневый интерфейс и скрывать небезопасные внутренние детали.</p>
  <p>Оборачивание функций, которые принимают в качестве входных параметров буферы, включает в себя использование модуля <code>slice::raw</code> для управления векторами Rust как указателями на память. Векторы Rust представляют собой гарантированно непрерывный блок памяти. Длина — это количество элементов, которое в настоящее время содержится в векторе, а ёмкость — общее количество выделенной памяти в элементах. Длина меньше или равна ёмкости.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">fn</span> validate_compressed_buffer(src: &amp;[<span class="kw">u8</span>]) -&gt; <span class="kw">bool</span> {
      <span class="kw">unsafe</span> {
          snappy_validate_compressed_buffer(src.as_ptr(), src.len() <span class="kw">as</span> size_t) == <span class="dv">0</span>
      }
  }</code></pre>
  <p>Обёртка <code>validate_compressed_buffer</code> использует блок <code>unsafe</code>, но это гарантирует, что её вызов будет безопасен для всех входных данных, поскольку модификатор <code>unsafe</code> отсутствует в сигнатуре функции. Т.е. небезопасность скрыта внутри функции и не видна вызывающему.</p>
  <p>Функции <code>snappy_compress</code> и <code>snappy_uncompress</code> являются более сложными, так как должен быть выделен буфер для хранения выходных данных.</p>
  <p>Функция <code>snappy_max_compressed_length</code> может быть использована для выделения вектора максимальной ёмкости, требуемой для хранения сжатых выходных данных. Затем этот вектор может быть передан в функцию <code>snappy_compress</code> в качестве выходного параметра. Ещё один параметр передается, чтобы получить настоящую длину после сжатия и установить соответствующую длину вектора.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">fn</span> compress(src: &amp;[<span class="kw">u8</span>]) -&gt; Vec&lt;<span class="kw">u8</span>&gt; {
      <span class="kw">unsafe</span> {
          <span class="kw">let</span> srclen = src.len() <span class="kw">as</span> size_t;
          <span class="kw">let</span> psrc = src.as_ptr();
  
          <span class="kw">let</span> <span class="kw">mut</span> dstlen = snappy_max_compressed_length(srclen);
          <span class="kw">let</span> <span class="kw">mut</span> dst = Vec::with_capacity(dstlen <span class="kw">as</span> usize);
          <span class="kw">let</span> pdst = dst.as_mut_ptr();
  
          snappy_compress(psrc, srclen, pdst, &amp;<span class="kw">mut</span> dstlen);
          dst.set_len(dstlen <span class="kw">as</span> usize);
          dst
      }
  }</code></pre>
  <p>Распаковка аналогична, потому что snappy хранит размер несжатых данных как часть формата сжатия, и <code>snappy_uncompressed_length</code> будет возвращать точный размер необходимого буфера.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">fn</span> uncompress(src: &amp;[<span class="kw">u8</span>]) -&gt; <span class="kw">Option</span>&lt;Vec&lt;<span class="kw">u8</span>&gt;&gt; {
      <span class="kw">unsafe</span> {
          <span class="kw">let</span> srclen = src.len() <span class="kw">as</span> size_t;
          <span class="kw">let</span> psrc = src.as_ptr();
  
          <span class="kw">let</span> <span class="kw">mut</span> dstlen: size_t = <span class="dv">0</span>;
          snappy_uncompressed_length(psrc, srclen, &amp;<span class="kw">mut</span> dstlen);
  
          <span class="kw">let</span> <span class="kw">mut</span> dst = Vec::with_capacity(dstlen <span class="kw">as</span> usize);
          <span class="kw">let</span> pdst = dst.as_mut_ptr();
  
          <span class="kw">if</span> snappy_uncompress(psrc, srclen, pdst, &amp;<span class="kw">mut</span> dstlen) == <span class="dv">0</span> {
              dst.set_len(dstlen <span class="kw">as</span> usize);
              <span class="kw">Some</span>(dst)
          } <span class="kw">else</span> {
              <span class="kw">None</span> <span class="co">// SNAPPY_INVALID_INPUT</span>
          }
      }
  }</code></pre>
  <p>Для справки, примеры, используемые здесь, также доступны в библиотеке на <a href="https://github.com/thestinger/rust-snappy">GitHub</a>.</p>
  </section>
  <section id="деструкторы" class="level3">
  <h3>Деструкторы</h3>
  <p>Внешние библиотеки часто передают владение ресурсами в вызывающий код. Когда это происходит, мы должны использовать деструкторы Rust, чтобы обеспечить безопасность и гарантировать освобождение этих ресурсов (особенно в случае паники).</p>
  <p>Чтобы получить более подробную информацию о деструкторах, смотрите <a href="http://doc.rust-lang.org/std/ops/trait.Drop.html">типаж Drop</a>.</p>
  </section>
  <section id="обратные-вызовы-функций-rust-кодом-на-c-callbacks-from-c-code-to-rust" class="level3">
  <h3>Обратные вызовы функций Rust кодом на C (Callbacks from C code to Rust</h3>
  </section>
  <section id="functions" class="level3">
  <h3>functions)</h3>
  <p>Некоторые внешние библиотеки требуют использование обратных вызовов для передачи вызывающей стороне отчета о своем текущем состоянии или промежуточных данных. Во внешнюю библиотеку можно передавать функции, которые были определены в Rust. При создании функции обратного вызова, которую можно вызывать из C кода, необходимо указать для нее спецификатор <code>extern</code>, за котороым следует подходящее соглашение о вызове.</p>
  <p>Затем функция обратного вызова может быть передана в библиотеку C через регистрационный вызов, и уже затем может быть вызвана оттуда.</p>
  <p>Простой пример:</p>
  <p>Код на Rust:</p>
  <pre class="no_run"><code>extern fn callback(a: i32) {
      println!(&quot;Меня вызывают из C со значением {0}&quot;, a);
  }
  
  #[link(name = &quot;extlib&quot;)]
  extern {
     fn register_callback(cb: extern fn(i32)) -&gt; i32;
     fn trigger_callback();
  }
  
  fn main() {
      unsafe {
          register_callback(callback);
          trigger_callback(); // Активация функции обратного вызова
      }
  }</code></pre>
  <p>Код на C:</p>
  <pre class="sourceCode c"><code class="sourceCode c"><span class="kw">typedef</span> <span class="dt">void</span> (*rust_callback)(<span class="dt">int32_t</span>);
  rust_callback cb;
  
  <span class="dt">int32_t</span> register_callback(rust_callback callback) {
      cb = callback;
      <span class="kw">return</span> <span class="dv">1</span>;
  }
  
  <span class="dt">void</span> trigger_callback() {
    cb(<span class="dv">7</span>); <span class="co">// Вызовет callback(7) в Rust</span>
  }</code></pre>
  <p>В этом примере функция <code>main()</code> в Rust вызовет функцию <code>trigger_callback()</code> в C, которая, в свою очередь, выполнит обратный вызов функции <code>callback()</code> в Rust.</p>
  <section id="обратные-вызовы-адресованные-объектам-rust-targeting-callbacks-to-rust" class="level4">
  <h4>Обратные вызовы, адресованные объектам Rust (Targeting callbacks to Rust</h4>
  </section>
  <section id="objects" class="level4">
  <h4>objects)</h4>
  <p>Предыдущий пример показал, как глобальная функция может быть вызвана из C кода. Однако зачастую желательно, чтобы обратный вызов был адресован конкретному объекту в Rust. Это может быть объект, который представляет собой обертку для соответствующего объекта C.</p>
  <p>Такое поведение может быть достигнуто путем передачи небезопасного указателя на объект в библиотеку C. После чего библиотека C сможет передавать указатель на объект Rust при обратном вызове. Это позволит получить небезопасный доступ к объекту Rust, на которой сослались в обратном вызове.</p>
  <p>Код на Rust:</p>
  <pre class="no_run"><code>#[repr(C)]
  struct RustObject {
      a: i32,
      // другие поля
  }
  
  extern &quot;C&quot; fn callback(target: *mut RustObject, a: i32) {
      println!(&quot;Меня вызывают из C со значением {0}&quot;, a);
      unsafe {
          // Меняем значение в RustObject на значение, полученное через функцию обратног
  ↳ о вызова
          (*target).a = a;
      }
  }
  
  #[link(name = &quot;extlib&quot;)]
  extern {
     fn register_callback(target: *mut RustObject,
                          cb: extern fn(*mut RustObject, i32)) -&gt; i32;
     fn trigger_callback();
  }
  
  fn main() {
      // Создаём объект, на который будем ссылаться в функции обратного вызова
      let mut rust_object = Box::new(RustObject { a: 5 });
  
      unsafe {
          register_callback(&amp;mut *rust_object, callback);
          trigger_callback();
      }
  }</code></pre>
  <p>Код на C:</p>
  <pre class="sourceCode c"><code class="sourceCode c"><span class="kw">typedef</span> <span class="dt">void</span> (*rust_callback)(<span class="dt">void</span>*, <span class="dt">int32_t</span>);
  <span class="dt">void</span>* cb_target;
  rust_callback cb;
  
  <span class="dt">int32_t</span> register_callback(<span class="dt">void</span>* callback_target, rust_callback callback) {
      cb_target = callback_target;
      cb = callback;
      <span class="kw">return</span> <span class="dv">1</span>;
  }
  
  <span class="dt">void</span> trigger_callback() {
    cb(cb_target, <span class="dv">7</span>); <span class="co">// Вызовет callback(&amp;rustObject, 7) в Rust</span>
  }</code></pre>
  </section>
  <section id="асинхронные-обратные-вызовы" class="level4">
  <h4>Асинхронные обратные вызовы</h4>
  <p>В приведённых примерах обратные вызовы выполняются как непосредственная реакция на вызов функции внешней библиотеки на C. Для выполнения обратного вызова поток исполнения переключался из Rust в C, а затем снова в Rust, но, в конце концов, обратный вызов выполнялся в том же потоке, из которого была вызвана функция, инициировавшая обратный вызов.</p>
  <p>Более сложная ситуация — это когда внешняя библиотека порождает свои собственные потоки и осуществляет обратные вызовы из них. В этих случаях доступ к структурам данных Rust из обратных вызовов особенно опасен, и поэтому нужно использовать соответствующие механизмы синхронизации. Помимо классических механизмов синхронизации, таких как мьютексы, в Rust есть еще одна возможность: использовать каналы (<code>std::sync::mpsc::channel</code>), чтобы направить данные из потока C, который выполнял обратный вызов, в поток Rust.</p>
  <p>Если асинхронный обратный вызов адресован конкретному объекту в адресном пространстве Rust, то необходимо, чтобы обратные вызовы не выполнялись библиотекой C после уничтожения этого объекта Rust. Для этого следует, во-первых, проектировать библиотеку таким образом, чтобы отмена регистрации обратного вызова гарантировала, что он больше не будет выполняться. Во-вторых, нужно отменить регистрацию обратного вызова в деструкторе объекта Rust, которому адресован обратный вызов.</p>
  </section>
  </section>
  <section id="компоновка" class="level3">
  <h3>Компоновка</h3>
  <p>Атрибут <code>link</code> для блоков <code>extern</code> предоставляет <code>rustc</code> основные инструкции относительно того, как он должен компоновать нативные библиотеки. На данный момент есть две общепринятых формы записи атрибута <code>link</code>:</p>
  <ul>
  <li><code>#[link(name = &quot;foo&quot;)]</code></li>
  <li><code>#[link(name = &quot;foo&quot;, kind = &quot;bar&quot;)]</code></li>
  </ul>
  <p>В обоих этих случаях <code>foo</code> — это имя нативной библиотеки, с которой мы компонуемся. Во втором случае <code>bar</code> — это тип нативной библиотеки, с которой происходит компоновка. В настоящее время <code>rustc</code> известны три типа нативных библиотек:</p>
  <ul>
  <li>Динамические — <code>#[link(name = &quot;readline&quot;)]</code></li>
  <li>Статические — <code>#[link(name = &quot;my_build_dependency&quot;, kind = &quot;static&quot;)]</code></li>
  <li>Фреймворки — <code>#[link(name = &quot;CoreFoundation&quot;, kind = &quot;framework&quot;)]</code></li>
  </ul>
  <p>Обратите внимание, что фреймворки доступны только для OSX.</p>
  <p>Различные значения <code>kind</code> нужны, чтобы определить, как компоновать нативную библиотеку. С точки зрения компоновки, компилятор Rust создает две разновидности артефактов: промежуточный (rlib/статическая библиотека) и конечный (динамическая библиотека/исполняемый файл). (Прим. переводчика: rlib — это формат статической библиотеки с метаданными в формате Rust) Зависимости от нативных динамических библиотек и фреймворков распространяются дальше, пока не дойдут до конечного артефакта, а от статических библиотек — нет.</p>
  <p>Вот несколько примеров того, как эта модель может быть использована:</p>
  <ul>
  <li>Нативная зависимость при сборке. Иногда написанный на Rust код необходимо состыковать с некоторым кодом на C/C++, но распространение C/C++ кода в формате библиотеки вызывает дополнительные трудности. В этом случае, код будут упакован в <code>libfoo.a</code>, а затем контейнер Rust должен будет объявить зависимость с помощью <code>#[link(name = &quot;foo&quot;, kind = &quot;static&quot;)]</code>.</li>
  </ul>
  <p>Независимо от типа результата (промежуточный или конечный) контейнера, нативная статическая библиотека будет включена в него на выходе, поэтому нет необходимости в распространении этой нативной статической библиотеки отдельно.</p>
  <ul>
  <li>Обычная динамическая зависимость. Общие системные библиотеки (такие, как <code>readline</code>) доступны на большом количестве систем, и статическую копию этих библиотек часто сложно найти. Когда такая зависимость включена в контейнер Rust, промежуточные артефакты (например, rlib’ы) не будут компоноваться с библиотекой, но когда rlib включается в состав конечного артефакта (например, исполняемый файл), нативная библиотека будет прикомпонована.</li>
  </ul>
  <p>На OSX, фреймворки ведут себя так же, как и динамические библиотеки.</p>
  </section>
  <section id="небезопасные-блоки" class="level3">
  <h3>Небезопасные блоки</h3>
  <p>Некоторые операции, такие как разыменование небезопасных указателей или вызов функций, которые были отмечены как небезопасные, разрешено использовать только внутри небезопасных блоков. Небезопасные блоки изолируют опасные ситуации и дают гарантии компилятору, что опасности не вытекут за пределы блока.</p>
  <p>Небезопасные функции же, наоборот, показывают свою опасность всем. Небезопасная функция записывается в виде:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">unsafe</span> <span class="kw">fn</span> kaboom(ptr: *const <span class="kw">i32</span>) -&gt; <span class="kw">i32</span> { *ptr }</code></pre>
  <p>Эта функция может быть вызвана только из блока <code>unsafe</code> или из другой <code>unsafe</code> функции.</p>
  </section>
  <section id="доступ-к-внешним-глобальным-переменным" class="level3">
  <h3>Доступ к внешним глобальным переменным</h3>
  <p>Внешние API довольно часто экспортируют глобальные переменные, которые могут быть использованы, например, для отслеживания глобального состояния. Для того, чтобы получить доступ к этим переменным, нужно объявить их в блоке <code>extern</code>, используя ключевое слово <code>static</code>:</p>
  <pre class="no_run"><code># #![feature(libc)]
  extern crate libc;
  
  #[link(name = &quot;readline&quot;)]
  extern {
      static rl_readline_version: libc::c_int;
  }
  
  fn main() {
      println!(&quot;You have readline version {} installed.&quot;,
               rl_readline_version as i32);
  }</code></pre>
  <p>Кроме того, возможно, вам потребуется изменить глобальное состояние, предоставленное внешним интерфейсом. Для этого при объявлении статических переменных может быть добавлен модификатор <code>mut</code>, чтобы была возможность изменять их.</p>
  <pre class="no_run"><code># #![feature(libc)]
  extern crate libc;
  
  use std::ffi::CString;
  use std::ptr;
  
  #[link(name = &quot;readline&quot;)]
  extern {
      static mut rl_prompt: *const libc::c_char;
  }
  
  fn main() {
      let prompt = CString::new(&quot;[my-awesome-shell] $&quot;).unwrap();
      unsafe {
          rl_prompt = prompt.as_ptr();
  
          println!(&quot;{:?}&quot;, rl_prompt);
  
          rl_prompt = ptr::null();
      }
  }</code></pre>
  <p>Обратите внимание, что любое взаимодействие с <code>static mut</code> небезопасно — как чтение, так и запись. Работа с изменяемым глобальным состоянием требует значительно большей осторожности.</p>
  <p><a name="foreign-calling-conventions"></a> ### Соглашение о вызове внешних функций</p>
  <p>Большинство внешнего кода предоставляет C ABI. И Rust при вызове внешних функций по умолчанию использует соглашение о вызове C для данной платформы. Но некоторые внешние функции, в первую очередь Windows API, используют другое соглашение о вызове. Rust обеспечивает способ указать компилятору, какое именно соглашение использовать:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> crate libc;
  
  <span class="ot">#[</span>cfg<span class="ot">(</span>all<span class="ot">(</span>target_os <span class="ot">=</span> <span class="st">&quot;win32&quot;</span><span class="ot">,</span> target_arch <span class="ot">=</span> <span class="st">&quot;x86&quot;</span><span class="ot">))]</span>
  <span class="ot">#[</span>link<span class="ot">(</span>name <span class="ot">=</span> <span class="st">&quot;kernel32&quot;</span><span class="ot">)]</span>
  <span class="ot">#[</span>allow<span class="ot">(</span>non_snake_case<span class="ot">)]</span>
  <span class="kw">extern</span> <span class="st">&quot;stdcall&quot;</span> {
      <span class="kw">fn</span> SetEnvironmentVariableA(n: *const <span class="kw">u8</span>, v: *const <span class="kw">u8</span>) -&gt; libc::c_int;
  }</code></pre>
  <p>Это указание относится ко всему блоку <code>extern</code>. Вот список поддерживаемых ограничений для ABI:</p>
  <ul>
  <li><code>stdcall</code></li>
  <li><code>aapcs</code></li>
  <li><code>cdecl</code></li>
  <li><code>fastcall</code></li>
  <li><code>Rust</code></li>
  <li><code>rust-intrinsic</code></li>
  <li><code>system</code></li>
  <li><code>C</code></li>
  <li><code>win64</code></li>
  </ul>
  <p>Большинство ABI в этом списке не требуют пояснений, но ABI <code>system</code> может показаться немного странным. Он выбирает такое ABI, которое подходит для взаимодействия с нативными библиотеками данной платформы. Например, на платформе win32 с архитектурой x86, это означает, что будет использован ABI <code>stdcall</code>. Однако, на windows x86_64 используется соглашение о вызове <code>C</code>, поэтому в этом случае будет использован <code>C</code> ABI. Это означает, что в нашем предыдущем примере мы могли бы использовать <code>extern &quot;system&quot; { ... }</code>, чтобы определить блок для всех windows систем, а не только для x86.</p>
  </section>
  <section id="взаимодействие-с-внешним-кодом" class="level3">
  <h3>Взаимодействие с внешним кодом</h3>
  <p>Rust гарантирует, что размещение полей <code>struct</code> совместимо с представлением в C только в том случае, если к ней применяется атрибут <code>#[repr(C)]</code>. Атрибут <code>#[repr(C, packed)]</code> может быть использован для размещения полей структуры без выравнивания. Атрибут <code>#[repr(C)]</code> также может быть применен и к перечислениям.</p>
  <p>Владеющие упаковки в Rust (<code>Box&lt;T&gt;</code>) используют указатели, не допускающие нулевое значение (non-nullable), как дескрипторы содержащихся в них объектов. Тем не менее, эти дескрипторы не должны создаваться вручную, так как они управляются внутренними средствами выделения памяти. Ссылки можно без риска считать ненулевыми указателями непосредствено на тип. Однако нарушение правил проверки заимствования или изменяемости может быть небезопасным. Но компилятор не может сделать так много предположений о сырых указателях. Например, он не полагается на настоящую неизменяемость данных под неизменяемым сырым указателем. Поэтому используйте сырые указатели (<code>*</code>), если вам необходимо намеренно нарушить правила (но так, что при этом всё работает). Это нужно, чтобы компилятор «случайно» не предположил относительно ссылок чего-то, что мы собираемся нарушать (возможно, нам нужны несколько указателей с правом изменения, что не допускается обычными ссылками).</p>
  <p>Векторы и строки совместно используют одну и ту же базовую cхему размещения памяти и утилиты, доступные в модулях <code>vec</code> и <code>str</code>, для работы с C API. Однако, строки не завершаются нулевым байтом, <code>\0</code>. Если вам нужна строка, завершающаяся нулевым байтом, для совместимости с C, вы должны использовать тип <code>CString</code> из модуля <code>std::ffi</code>.</p>
  <p>Стандартная библиотека включает в себя псевдонимы типов и определения функций для стандартной библиотеки C в модуле <code>libc</code>, и Rust компонует <code>libc</code> и <code>libm</code> по умолчанию.</p>
  </section>
  <section id="оптимизация-указателей-допускающих-нулевое-значение" class="level3">
  <h3>Оптимизация указателей, допускающих нулевое значение</h3>
  </section>
  <section id="the-nullable-pointer-optimization" class="level3">
  <h3>(The nullable pointer optimization)</h3>
  <p>Некоторые типы по определению не могут быть <code>null</code>. Это ссылки (<code>&amp;T</code>, <code>&amp;mut T</code>), упаковки (<code>Box&lt;T&gt;</code>), указатели на функции (<code>extern &quot;abi&quot; fn()</code>). При взаимодействии же с С часто используются указатели, которые могут быть <code>null</code>. Как особый случай — обобщенный <code>enum</code>, который содержит ровно два варианта, один из которых не содержит данных, а другой содержит одно поле. Такое использование перечисления имеет право на «оптимизацию указателя, допускающего нулевое значение». Когда создан экземпляр такого перечисления с одним из не-обнуляемых типов, то он представляет собой ненулевой указатель для варианта, содержащего данные, и нулевой — для варианта без данных. Таким образом, <code>Option&lt;extern &quot;C&quot; fn(c_int) -&gt; c_int&gt;</code> — это представление указателя на функцию, допускающего нулевое значение, и совместимого с C ABI.</p>
  </section>
  <section id="вызов-кода-на-rust-из-кода-на-c" class="level3">
  <h3>Вызов кода на Rust из кода на C</h3>
  <p>Вы можете скомпилировать код на Rust таким образом, чтобы он мог быть вызван из кода на C. Это довольно легко, но требует нескольких вещей:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="ot">#[</span>no_mangle<span class="ot">]</span>
  <span class="kw">pub</span> <span class="kw">extern</span> <span class="kw">fn</span> hello_rust() -&gt; *const <span class="kw">u8</span> {
      <span class="st">&quot;Hello, world!</span><span class="ch">\</span><span class="er">0</span><span class="st">&quot;</span>.as_ptr()
  }</code></pre>
  <p><code>extern</code> указывает, что эта функцию придерживается соглашения о вызове C, как описано выше в разделе «<a href="#foreign-calling-conventions">Соглашение о вызове внешних функций</a>». Атрибут <code>no_mangle</code> выключает изменение имён, применяемое в Rust, чтобы было легче компоноваться с этим кодом.</p>
  </section>
  </section>
  <section id="sec--borrow-and-asref" class="level2">
  <h2>Типажи <code>Borrow</code> и <code>AsRef</code></h2>
  <p>Типажи <a href="http://doc.rust-lang.org/std/borrow/trait.Borrow.html"><code>Borrow</code></a> и <a href="http://doc.rust-lang.org/std/convert/trait.AsRef.html"><code>AsRef</code></a> очень похожи, но в то же время отличаются. Ниже приводится небольшая памятка об этих двух типажах.</p>
  <section id="типаж-borrow" class="level3">
  <h3>Типаж Borrow</h3>
  <p>Типаж <code>Borrow</code> используется, когда вы пишете структуру данных и хотите использовать владение и заимствование типа как синонимы.</p>
  <p>Например, <a href="http://doc.rust-lang.org/std/collections/struct.HashMap.html"><code>HashMap</code></a> имеет метод <a href="http://doc.rust-lang.org/std/collections/struct.HashMap.html#method.get"><code>get</code></a>, который использует <code>Borrow</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> get&lt;Q: ?<span class="kw">Sized</span>&gt;(&amp;<span class="kw">self</span>, k: &amp;Q) -&gt; <span class="kw">Option</span>&lt;&amp;V&gt;
      where K: Borrow&lt;Q&gt;,
            Q: Hash + <span class="kw">Eq</span></code></pre>
  <p>Эта сигнатура является довольно сложной. Параметр <code>K</code> — это то, что нас здесь интересует. Он ссылается на параметр самого <code>HashMap</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> HashMap&lt;K, V, S = RandomState&gt; {</code></pre>
  <p>Параметр <code>K</code> представляет собой тип <em>ключа</em>, который использует <code>HashMap</code>. Взглянем на сигнатуру <code>get()</code> еще раз. Использовать <code>get()</code> возможно, когда ключ реализует <code>Borrow&lt;Q&gt;</code>. Таким образом, мы можем сделать <code>HashMap</code>, который использует ключи <code>String</code>, но использовать <code>&amp;str</code>, когда мы выполняем поиск:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::collections::HashMap;
  
  <span class="kw">let</span> <span class="kw">mut</span> map = HashMap::new();
  map.insert(<span class="st">&quot;Foo&quot;</span>.to_string(), <span class="dv">42</span>);
  
  <span class="ot">assert_eq!</span>(map.get(<span class="st">&quot;Foo&quot;</span>), <span class="kw">Some</span>(&amp;<span class="dv">42</span>));</code></pre>
  <p>Это возможно, так как стандартная библиотека содержит <code>impl Borrow&lt;str&gt; for String</code>.</p>
  <p>Для большинства типов, когда вы хотите получить право собственности или позаимствовать значений, достаточно использовать просто <code>&amp;T</code>. <code>Borrow</code> же становится полезен, когда есть более одного вида занимаемого значения. Это особенно верно для ссылок и срезов: у вас может быть как <code>&amp;T</code>, так и <code>&amp;mut T</code>. Если мы хотим принимать оба этих типа, <code>Borrow</code> как раз для этого подходит:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::borrow::Borrow;
  <span class="kw">use</span> std::fmt::Display;
  
  <span class="kw">fn</span> foo&lt;T: Borrow&lt;<span class="kw">i32</span>&gt; + Display&gt;(a: T) {
      <span class="ot">println!</span>(<span class="st">&quot;a заимствовано: {}&quot;</span>, a);
  }
  
  <span class="kw">let</span> <span class="kw">mut</span> i = <span class="dv">5</span>;
  
  foo(&amp;i);
  foo(&amp;<span class="kw">mut</span> i);</code></pre>
  <p>Это выведет <code>a заимствовано: 5</code> дважды.</p>
  </section>
  <section id="типаж-asref" class="level3">
  <h3>Типаж AsRef</h3>
  <p>Типаж <code>AsRef</code> является преобразующим типажом. Он используется в обобщённом коде для преобразования некоторого значения в ссылку. Например:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> s = <span class="st">&quot;Hello&quot;</span>.to_string();
  
  <span class="kw">fn</span> foo&lt;T: AsRef&lt;<span class="kw">str</span>&gt;&gt;(s: T) {
      <span class="kw">let</span> slice = s.as_ref();
  }</code></pre>
  </section>
  <section id="что-в-каком-случае-следует-использовать" class="level3">
  <h3>Что в каком случае следует использовать?</h3>
  <p>Мы видим, что они вроде одинаковы: имеют дело с владением и заимствованием значения некоторого типа. Тем не менее, эти типажи немного отличаются.</p>
  <p>Используйте <code>Borrow</code>, когда вы хотите абстрагироваться от различных видов заимствований, или когда вы строите структуру данных, которая использует владеющие и заимствованные значения как эквивалентные. Например, это может пригодиться в хэшировании и сравнении.</p>
  <p>Используйте <code>AsRef</code>, когда вы пишете обобщённый код и хотите непосредственно преобразовать что-либо в ссылку.</p>
  </section>
  </section>
  <section id="sec--release-channels" class="level2">
  <h2>Каналы сборок</h2>
  <p>Проект Rust использует концепцию под названием «каналы сборок» для управления сборками. Важно понять этот процесс, чтобы выбрать, какую версию Rust использовать в вашем проекте.</p>
  <section id="обзор" class="level3">
  <h3>Обзор</h3>
  <p>Есть три канала сборок Rust:</p>
  <ul>
  <li>Ночной (Nightly)</li>
  <li>Бета (Beta)</li>
  <li>Стабильный (Stable)</li>
  </ul>
  <p>Новые ночные сборки создаются раз в день. Каждые шесть недель последняя ночная сборка переводится в канал «бета». С этого момента она будет получать только исправления серьёзных ошибок. Шесть недель спустя бета сборка переводится в канал «стабильный» и становится очередной стабильной сборкой <code>1.x</code>.</p>
  <p>Этот процесс происходит параллельно. Так, каждые шесть недель, в один и тот же день, ночная сборка превращается в бета сборку, а бета сборка превращается в стабильную сборку. Это произойдёт одновременно: стабильная сборка получит версию <code>1.x</code>, бета сборка получит версию <code>1.(x + 1)-beta</code>, а ночная сборка станет первой версией <code>1.(x + 2)-nightly</code>.</p>
  </section>
  <section id="выбор-версии" class="level3">
  <h3>Выбор версии</h3>
  <p>Вообще говоря, если у вас нет особых причин, вы должны использовать канал стабильных сборок. Эти сборки предназначены для широкой аудитории.</p>
  <p>Однако, в зависимости от ваших интересов к Rust, вы можете вместо этого выбрать ночную сборку. Основной компромисс заключается в следующем: при выборе канала ночных сборок, вы можете использовать неустойчивые, новые возможности Rust. Тем не менее, нестабильные возможности могут быть изменены, и поэтому любая новая ночная сборка может сломать ваш код. Если же вы выберете стабильную сборку, то не сможете использовать экспериментальные возможности, но следующий релиз Rust не вызовет существенных проблем с критическими изменениями.</p>
  </section>
  <section id="помощь-экосистеме-с-помощью-непрерывной-интеграции" class="level3">
  <h3>Помощь экосистеме с помощью непрерывной интеграции</h3>
  <p>А что насчёт бета канала? Мы призываем всех пользователей Rust, которые используют канал стабильных сборок, также протестировать работу с использованием бета канала в их системах непрерывной интеграции. Это поможет предупредить команду в случае возникновения неожиданных регрессий.</p>
  <p>Кроме того, тестирование работы с использованием ночного канала может выявить регрессии даже раньше, а поэтому, если вас не затруднит создание трех сборок, мы будем признательны тестированию работы с использованием всех трех каналов.</p>
  </section>
  </section>
  </section>
  <section id="sec--syntax-and-semantics" class="level1">
  <h1>Синтаксис и семантика</h1>
  <p>Эта часть разбита на небольшие главы, каждая из которых описывает определённое понятие Rust.</p>
  <p>Если вы хотите изучить Rust «от и до», продолжайте чтение данной части по порядку - вы на верном пути!</p>
  <p>Эти главы также являются справочником понятий, так что если при чтении другого материала вам будет что-то непонятно, вы всегда сможете найти объяснение здесь.</p>
  <section id="sec--variable-bindings" class="level2">
  <h2>Связывание имён</h2>
  <p>Любая реальная программа на Rust посложнее, чем «Hello World», использует <em>связывание имён</em>. Это выглядит так:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="kw">let</span> x = <span class="dv">5</span>;
  }</code></pre>
  <p>Все операции, производимые ниже, будут происходить в функции <code>main()</code>, так как каждый раз вставлять в примеры <code>fn main() {</code> немного утомляет. Убедитесь, что примеры, приведённые в этом разделе, вы вводите в функцию <code>main()</code>, иначе можете получить ошибку при компиляции.</p>
  <p>Во многих языках программирования это называется <em>переменной</em>. Но у связывания переменных в Rust есть пара трюков в рукаве. В левой части выражения <code>let</code> располагается не просто имя переменной, а “<a href="#sec--patterns">шаблон</a>”. Это значит, что мы можем делать вещи вроде этой:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> (x, y) = (<span class="dv">1</span>, <span class="dv">2</span>);</code></pre>
  <p>После завершения этого выражения <code>x</code> будет единицей, a <code>y</code> — двойкой. Шаблоны очень мощны, и о них написана отдельная <a href="#sec--patterns">глава</a>. Но на данный момент нам не нужны эти возможности, так что мы просто будем помнить о них и пойдём дальше.</p>
  <p>Rust — статически типизированный язык программирования, и значит мы должны указывать типы, и они будут проверяться во время компиляции. Так почему же наш первый пример скомпилировался? В Rust есть нечто, называемое <em>выводом типов</em>. Если Rust самостоятельно может понять, какой тип у переменной, то он не требует указывать его.</p>
  <p>Тем не менее, мы можем указать желаемый тип. Он следует после двоеточия (<code>:</code>):</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x: <span class="kw">i32</span> = <span class="dv">5</span>;</code></pre>
  <p>Если бы мы попросили вас прочитать это вслух, вы бы сказали «<code>x</code> - это связывание типа <code>int</code> со значением <code>пять</code>».</p>
  <p>В этом случае мы указали, что <code>x</code> у нас будет 32-битным целым числом со знаком. В Rust есть и другие целочисленные типы. Их имена начинаются с <code>i</code> для целых чисел со знаком и с <code>u</code> для целых чисел без знака. Целые числа могут иметь размер 8, 16, 32 и 64 бита.</p>
  <p>В дальнейших примерах мы будем указывать тип в комментариях. Это будет выглядеть вот так:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="kw">let</span> x = <span class="dv">5</span>; <span class="co">// x: i32</span>
  }</code></pre>
  <p>Обратите внимание на сходство между этим комментарием и синтаксисом, который вы используете с <code>let</code>. Включение такого типа комментариев не является идиоматичным для Rust, но иногда мы будем включать их для того, чтобы помочь вам понять, какие типы будут выведены Rust.</p>
  <p>По умолчанию, связывание <em>неизменяемо</em>. Этот код не скомпилируется:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">5</span>;
  x = <span class="dv">10</span>;</code></pre>
  <p>И вы получите ошибку:</p>
  <pre class="text"><code>error: re-assignment of immutable variable `x`
       x = 10;
       ^~~~~~~</code></pre>
  <p>Если вы хотите, чтобы связывание было изменяемым, вы можете использовать модификатор <code>mut</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> x = <span class="dv">5</span>; <span class="co">// mut x: i32</span>
  x = <span class="dv">10</span>;</code></pre>
  <p>Может показаться, что незачем делать связывание неизменяемым по умолчанию. Но вспомните, на чём в первую очередь фокусируется Rust: на безопасности. Если вы случайно забыли указать <code>mut</code> и изменили связывание, компилятор заметит это, и сообщит вам, что вы попытались изменить не то, что собирались. Если бы по умолчанию связывание было изменяемым, то в приведённой выше ситуации компилятор не сможет вам помочь. Если вы намерены изменить значение переменной, то просто добавьте <code>mut</code>.</p>
  <p>Есть и другие весомые аргументы в пользу того, чтобы по возможности избегать изменяемого состояния, но это выходит за рамки данной книги. В общем, зачастую вы можете избежать явных изменений, и это предпочтительнее в Rust. Тем не менее, иногда без изменения значения просто не обойтись, так что это не запрещено.</p>
  <p>Вернёмся к связыванию. Связывание переменных в Rust имеет ещё одно отличие от других языков: оно требует инициализации перед использованием.</p>
  <p>Давайте приступим к рассмотрению вышесказанного. Измените ваш файл <code>src/main.rs</code> так, что бы он выглядел следующим образом:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="kw">let</span> x: <span class="kw">i32</span>;
  
      <span class="ot">println!</span>(<span class="st">&quot;Hello world!&quot;</span>);
  }</code></pre>
  <p>Используйте команду <code>cargo build</code> в командной строке, чтобы собрать проект. Вы должны получить предупреждение, но программа будет работать и будет выводить строку «Привет, мир!»:</p>
  <pre class="text"><code>   Compiling hello_world v0.0.1 (file:///home/you/projects/hello_world)
  src/main.rs:2:9: 2:10 warning: unused variable: `x`, #[warn(unused_variable)]
     on by default
  src/main.rs:2     let x: i32;
                        ^</code></pre>
  <p>Rust предупредит нас о том, что мы не используем связанную переменную, но от того, что мы её не используем, не будет никакого вреда, поэтому это не ошибка. Однако, всё изменится, если мы попробуем использовать <code>x</code>. Сделаем это. Измените вашу программу так, что бы она выглядела следующим образом:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="kw">let</span> x: <span class="kw">i32</span>;
  
      <span class="ot">println!</span>(<span class="st">&quot;x имеет значение {}&quot;</span>, x);
  }</code></pre>
  <p>И попробуйте собрать проект. Вы получите ошибку:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> build
     <span class="kw">Compiling</span> hello_world v0.0.1 (file:///home/you/projects/hello_world)
  <span class="kw">src</span>/main.rs:<span class="kw">4</span>:39: 4:40 error: use of possibly uninitialized variable: <span class="kw">`x`</span>
  <span class="kw">src</span>/main.rs:<span class="kw">4</span>     println!(<span class="st">&quot;x имеет значение {}&quot;</span>, x);
                                                      ^
  <span class="kw">note</span>: in expansion of format_args!
  <span class="kw">&lt;std</span> macros<span class="kw">&gt;</span>:2:23: 2:77 note: expansion site
  <span class="kw">&lt;std</span> macros<span class="kw">&gt;</span>:1:1: 3:2 note: in expansion of println!
  <span class="kw">src</span>/main.rs:<span class="kw">4</span>:5: 4:42 note: expansion site
  <span class="kw">error</span>: aborting due to previous error
  <span class="kw">Could</span> not compile <span class="kw">`hello_world`</span>.</code></pre>
  <p>Rust не позволит использовать неинициализированную переменную. Далее, поговорим о <code>{}</code>, которые мы добавили в <code>println!</code>.</p>
  <p>Если вы добавите две фигурные скобки (<code>{}</code>, иногда называемые «усами»…) в вашу печатаемую строку, Rust истолкует это как просьбу вставки некоторого значения. <em>Строковая интерполяция</em> — это термин в информатике, который обозначает «вставить посреди строки». Мы добавили запятую, и затем <code>x</code>, чтобы указать, что мы хотим вставить <code>x</code> в строку. Запятая используется для разделения параметров, если в функцию или макрос передаётся больше одного параметра.</p>
  <p>При вставке переменной в строку, Rust проверит её тип и попытается отобразить осмысленное значение. Если вы хотите указать формат более детально, то можете ознакомиться с <a href="http://doc.rust-lang.org/std/fmt/index.html">доступными способами форматирования строк (англ.)</a>. На данный момент мы просто используем способ по умолчанию: печатать целые числа не очень сложно.</p>
  </section>
  <section id="sec--functions" class="level2">
  <h2>Функции</h2>
  <p>Каждая программа на Rust имеет по крайней мере одну функцию — <code>main</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
  }</code></pre>
  <p>Это простейшее объявление функции. Как мы упоминали ранее, ключевое слово <code>fn</code> объявляет функцию. За ним следует её имя, пустые круглые скобки (поскольку эта функция не принимает аргументов), а затем тело функции, заключённое в фигурные скобки. Вот функция <code>foo</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo() {
  }</code></pre>
  <p>Итак, что насчёт аргументов, принимаемых функцией? Вот функция, печатающая число:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> print_number(x: <span class="kw">i32</span>) {
      <span class="ot">println!</span>(<span class="st">&quot;x равен: {}&quot;</span>, x);
  }</code></pre>
  <p>Вот полная программа, использующая функцию <code>print_number</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      print_number(<span class="dv">5</span>);
  }
  
  <span class="kw">fn</span> print_number(x: <span class="kw">i32</span>) {
      <span class="ot">println!</span>(<span class="st">&quot;x равен: {}&quot;</span>, x);
  }</code></pre>
  <p>Как видите, аргументы функций похожи на операторы <code>let</code>: вы можете объявить тип аргумента после двоеточия.</p>
  <p>Вот полная программа, которая складывает два числа и печатает их:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      print_sum(<span class="dv">5</span>, <span class="dv">6</span>);
  }
  
  <span class="kw">fn</span> print_sum(x: <span class="kw">i32</span>, y: <span class="kw">i32</span>) {
      <span class="ot">println!</span>(<span class="st">&quot;сумма чисел: {}&quot;</span>, x + y);
  }</code></pre>
  <p>Аргументы разделяются запятой — и при вызове функции, и при её объявлении.</p>
  <p>В отличие от <code>let</code>, вы <em>должны</em> объявлять типы аргументов функции. Этот код не скомпилируется:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> print_sum(x, y) {
      <span class="ot">println!</span>(<span class="st">&quot;сумма чисел: {}&quot;</span>, x + y);
  }</code></pre>
  <p>Вы увидите такую ошибку:</p>
  <pre class="text"><code>expected one of `!`, `:`, or `@`, found `)`
  fn print_number(x, y) {</code></pre>
  <p>Это осознанное решение при проектировании языка. Бесспорно, вывод типов во всей программе возможен. Однако даже в Haskell считается хорошим стилем явно документировать типы функций, хотя в этом языке и возможен полный вывод типов. Мы считаем, что принудительное объявление типов функций при сохранении локального вывода типов — это хороший компромисс.</p>
  <p>Как насчёт возвращаемого значения? Вот функция, которая прибавляет один к целому:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> add_one(x: <span class="kw">i32</span>) -&gt; <span class="kw">i32</span> {
      x + <span class="dv">1</span>
  }</code></pre>
  <p>Функции в Rust возвращают ровно одно значение, тип которого объявляется после «стрелки». «Стрелка» представляет собой дефис (<code>-</code>), за которым следует знак «больше» (<code>&gt;</code>). Заметьте, что в функции выше нет точки с запятой. Если бы мы добавили её:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> add_one(x: <span class="kw">i32</span>) -&gt; <span class="kw">i32</span> {
      x + <span class="dv">1</span>;
  }</code></pre>
  <p>мы бы получили ошибку:</p>
  <pre class="text"><code>error: not all control paths return a value
  fn add_one(x: i32) -&gt; i32 {
       x + 1;
  }
  
  help: consider removing this semicolon:
       x + 1;
            ^</code></pre>
  <p>Здесь показаны две интересные особенности Rust. Во-первых, это язык, ориентированный на выражения, и во-вторых, смысл точки с запятой отличается от смысла аналогичного символа в других языках с синтаксисом на основе фигурных скобок и точки с запятой. Эти две особенности связаны.</p>
  <p><a name="expressions-vs.-statements"></a> #### Выражения и операторы</p>
  <p>Rust — в первую очередь язык, ориентированный на выражения. Есть только два типа операторов, а всё остальное является выражением.</p>
  <p>А в чём же разница? Выражение возвращает значение, в то время как оператор - нет. Вот почему мы получаем здесь «not all control paths return a value»: оператор <code>х + 1;</code> не возвращает значение. Есть два типа операторов в Rust: «операторы объявления» и «операторы выражения». Все остальное — выражения. Давайте сначала поговорим об операторах объявления.</p>
  <p><em>Оператор объявления</em> — это связывание. В некоторых языках связывание переменных может быть записано как выражение, а не только как оператор. Например, в Ruby:</p>
  <pre class="sourceCode ruby"><code class="sourceCode ruby">x = y = <span class="dv">5</span></code></pre>
  <p>Однако, в Rust использование <code>let</code> для связывания <em>не является</em> выражением. Следующий код вызовет ошибку компиляции:</p>
  <pre class="ignore"><code>let x = (let y = 5); // expected identifier, found keyword `let`</code></pre>
  <p>Здесь компилятор сообщил нам, что ожидал увидеть выражение, но <code>let</code> является оператором, а не выражением.</p>
  <p>Обратите внимание, что присвоение уже связанной переменной (например: <code>y = 5</code>) является выражением, но его значение не особенно полезно. В отличие от других языков, где результатом присваивания является присваиваемое значение (например, <code>5</code> из предыдущего примера), в Rust значением присваивания является пустой кортеж <code>()</code>.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> y = <span class="dv">5</span>;
  
  <span class="kw">let</span> x = (y = <span class="dv">6</span>);  <span class="co">// x будет присвоено значение `()`, а не `6`</span></code></pre>
  <p>Вторым типом операторов в Rust является <em>оператор выражения</em>. Его цель - превратить любое выражение в оператор. В практическом плане, грамматика Rust ожидает, что за операторами будут идти другие операторы. Это означает, что вы используете точку с запятой для отделения выражений друг от друга. Rust выглядит как многие другие языки, которые требуют использовать точку с запятой в конце каждой строки. Вы увидите её в конце почти каждой строки кода на Rust.</p>
  <p>Из-за чего мы говорим «почти»? Вы это уже видели в этом примере:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> add_one(x: <span class="kw">i32</span>) -&gt; <span class="kw">i32</span> {
      x + <span class="dv">1</span>
  }</code></pre>
  <p>Наша функция объявлена как возвращающая <code>i32</code>. Но если в конце есть точка с запятой, то вместо этого функция вернёт <code>()</code>. Компилятор Rust обрабатывает эту ситуацию и предлагает удалить точку с запятой.</p>
  <section id="досрочный-возврат-из-функции" class="level4">
  <h4>Досрочный возврат из функции</h4>
  <p>А что насчёт досрочного возврата из функции? У нас есть для этого ключевое слово <code>return</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo(x: <span class="kw">i32</span>) -&gt; <span class="kw">i32</span> {
      <span class="kw">return</span> x;
  
      <span class="co">// дальнейший код не будет исполнен!</span>
      x + <span class="dv">1</span>
  }</code></pre>
  <p><code>return</code> можно написать в последней строке тела функции, но это считается плохим стилем:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo(x: <span class="kw">i32</span>) -&gt; <span class="kw">i32</span> {
      <span class="kw">return</span> x + <span class="dv">1</span>;
  }</code></pre>
  <p>Если вы никогда не работали с языком, в котором операторы являются выражениями, предыдущее определение без <code>return</code> может показаться вам странным. Но со временем вы просто перестанете замечать это.</p>
  </section>
  <section id="расходящиеся-функции" class="level4">
  <h4>Расходящиеся функции</h4>
  <p>Для функций, которые не возвращают управление («расходящихся»), в Rust есть специальный синтаксис:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> diverges() -&gt; ! {
      <span class="ot">panic!</span>(<span class="st">&quot;Эта функция не возвращает управление!&quot;</span>);
  }</code></pre>
  <p><code>panic!</code> — это макрос, как и <code>println!()</code>, который мы встречали ранее. В отличие от <code>println!()</code>, <code>panic!()</code> вызывает остановку текущего потока исполнения с заданным сообщением.</p>
  <p>Поскольку эта функция вызывает остановку исполнения, она никогда не вернёт управление. Поэтому тип её возвращаемого значения обозначается знаком <code>!</code> и читается как «расходится». Значение расходящейся функции может быть использовано как значение любого типа:</p>
  <pre class="should_panic"><code># fn diverges() -&gt; ! {
  #    panic!(&quot;Эта функция никогда не выходит!&quot;);
  # }
  let x: i32 = diverges();
  let x: String = diverges();</code></pre>
  </section>
  </section>
  <section id="sec--primitive-types" class="level2">
  <h2>Простые типы</h2>
  <p>Язык Rust имеет несколько типов, которые считаются «простыми» («примитивными»). Это означает, что они встроены в язык. Rust структурирован таким образом, что стандартная библиотека также предоставляет ряд полезных типов, построенных на базе этих простых типов, но это самые простые.</p>
  <section id="логический-тип-bool" class="level3">
  <h3>Логический тип (<code>bool</code>)</h3>
  <p>Rust имеет встроенный логический тип, называемый <code>bool</code>. Он может принимать два значения, <code>true</code> и <code>false</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="kw">true</span>;
  
  <span class="kw">let</span> y: <span class="kw">bool</span> = <span class="kw">false</span>;</code></pre>
  <p>Логические типы часто используются в <a href="#sec--if">конструкции <code>if</code></a>.</p>
  <p>Вы можете найти больше информации о логических типах (<code>bool</code>) в <a href="http://doc.rust-lang.org/std/primitive.bool.html">документации к стандартной библиотеке (англ.)</a>.</p>
  </section>
  <section id="символы-char" class="level3">
  <h3>Символы (<code>char</code>)</h3>
  <p>Тип <code>char</code> представляет собой одиночное скалярное значение Unicode. Вы можете создать <code>char</code> с помощью одинарных кавычек: (<code>'</code>)</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="ch">'x'</span>;
  <span class="kw">let</span> two_hearts = <span class="ch">'💕'</span>;</code></pre>
  <p>Это означает, что в отличие от некоторых других языков, <code>char</code> в Rust представлен не одним байтом, а четырьмя.</p>
  <p>Вы можете найти больше информации о символах (<code>char</code>) в <a href="http://doc.rust-lang.org/std/primitive.char.html">документации к стандартной библиотеке (англ.)</a>.</p>
  <p><a name="numeric-types"></a> ### Числовые типы</p>
  <p>Rust имеет целый ряд числовых типов, разделённых на несколько категорий: знаковые и беззнаковые, фиксированного и переменного размера, числа с плавающей точкой и целые числа.</p>
  <p>Эти типы состоят из двух частей: категория и размер. Например, <code>u16</code> представляет собой тип без знака с размером в шестнадцать бит. Чем большим количеством бит представлен тип, тем большее число мы можем задать.</p>
  <p>Если для числового литерала не указан тип, то он будет выведен по умолчанию:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">42</span>; <span class="co">// x имеет тип i32</span>
  
  <span class="kw">let</span> y = <span class="dv">1.0</span>; <span class="co">// y имеет тип f64</span></code></pre>
  <p>Ниже представлен список различных числовых типов, со ссылками на их документацию в стандартной библиотеке:</p>
  <ul>
  <li><a href="http://doc.rust-lang.org/std/primitive.i8.html">i8</a></li>
  <li><a href="http://doc.rust-lang.org/std/primitive.i16.html">i16</a></li>
  <li><a href="http://doc.rust-lang.org/std/primitive.i32.html">i32</a></li>
  <li><a href="http://doc.rust-lang.org/std/primitive.i64.html">i64</a></li>
  <li><a href="http://doc.rust-lang.org/std/primitive.u8.html">u8</a></li>
  <li><a href="http://doc.rust-lang.org/std/primitive.u16.html">u16</a></li>
  <li><a href="http://doc.rust-lang.org/std/primitive.u32.html">u32</a></li>
  <li><a href="http://doc.rust-lang.org/std/primitive.u64.html">u64</a></li>
  <li><a href="http://doc.rust-lang.org/std/primitive.isize.html">isize</a></li>
  <li><a href="http://doc.rust-lang.org/std/primitive.usize.html">usize</a></li>
  <li><a href="http://doc.rust-lang.org/std/primitive.f32.html">f32</a></li>
  <li><a href="http://doc.rust-lang.org/std/primitive.f64.html">f64</a></li>
  </ul>
  <p>Давайте пройдёмся по их категориям.</p>
  <section id="знаковые-и-беззнаковые" class="level4">
  <h4>Знаковые и беззнаковые</h4>
  <p>Целые типы бывают двух видов: знаковые и беззнаковые. Чтобы понять разницу, давайте рассмотрим число с размером в четыре бита. Знаковые четырёхбитные числа, позволяют хранить значения от <code>-8</code> до <code>+7</code>. Знаковые числа используют представление «дополнение до двух» (дополнительный код). Беззнаковые четырёхбитные числа, ввиду того что не нужно хранить отрицательные значения, позволяют хранить значения от <code>0</code> до <code>+15</code>.</p>
  <p>Беззнаковые типы используют <code>u</code> для своей категории, а знаковые типы используют <code>i</code>. <code>i</code> означает «integer». Так, <code>u8</code> представляет собой число без знака с размером восемь бит, а <code>i8</code> представляет собой число со знаком с размером восемь бит.</p>
  </section>
  <section id="типы-фиксированного-размера" class="level4">
  <h4>Типы фиксированного размера</h4>
  <p>Типы с фиксированным размером соответственно имеют фиксированное количество бит в своём представлении. Допустимыми размерами являются <code>8</code>, <code>16</code>, <code>32</code>, <code>64</code>. Таким образом, <code>u32</code> представляет собой целое число без знака с размером 32 бита, а <code>i64</code> — целое число со знаком с размером 64 бита.</p>
  </section>
  <section id="типы-переменного-размера" class="level4">
  <h4>Типы переменного размера</h4>
  <p>Rust также предоставляет типы, размер которых зависит от размера указателя на целевой машине. Эти типы имеют «size» в названии в качестве признака размера, и могут быть знаковыми или беззнаковыми. Таким образом, существует два типа: <code>isize</code> и <code>usize</code>.</p>
  </section>
  <section id="с-плавающей-точкой" class="level4">
  <h4>С плавающей точкой</h4>
  <p>В Rust также есть два типа с плавающей точкой: <code>f32</code> и <code>f64</code>. Они соответствуют IEEE-754 числам с плавающей точкой одинарной и двойной точности соответственно.</p>
  </section>
  </section>
  <section id="массивы" class="level3">
  <h3>Массивы</h3>
  <p>В Rust, как и во многих других языках программирования, есть типы-последовательности, для представления последовательностей неких вещей. Самый простой из них — это <em>массив</em>, то есть последовательность элементов одного и того же типа, имеющая фиксированный размер. Массивы неизменяемы по умолчанию.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> a = [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]; <span class="co">// a: [i32; 3]</span>
  <span class="kw">let</span> <span class="kw">mut</span> m = [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]; <span class="co">// m: [i32; 3]</span></code></pre>
  <p>Массивы имеют тип <code>[T; N]</code>. О значении <code>T</code> мы поговорим позже, когда будем рассматривать <a href="#sec--generics">обобщённое программирование</a>. <code>N</code> — это константа времени компиляции, представляющая собой длину массива.</p>
  <p>Для инициализации всех элементов массива одним и тем же значением есть специальный синтаксис. В этом примере каждый элемент <code>a</code> будет инициализирован значением <code>0</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> a = [<span class="dv">0</span>; <span class="dv">20</span>]; <span class="co">// a: [i32; 20]</span></code></pre>
  <p>Вы можете получить число элементов массива <code>a</code> с помощью метода <code>a.len()</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> a = [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  
  <span class="ot">println!</span>(<span class="st">&quot;Число элементов в a: {}&quot;</span>, a.len());</code></pre>
  <p>Вы можете получить определённый элемент массива с помощью <em>индекса</em>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> names = [<span class="st">&quot;Graydon&quot;</span>, <span class="st">&quot;Brian&quot;</span>, <span class="st">&quot;Niko&quot;</span>]; <span class="co">// names: [&amp;str; 3]</span>
  
  <span class="ot">println!</span>(<span class="st">&quot;Второе имя: {}&quot;</span>, names[<span class="dv">1</span>]);</code></pre>
  <p>Индексы нумеруются с нуля, как и в большинстве языков программирования, поэтому мы получаем первое имя с помощью <code>names[0]</code>, а второе — с помощью <code>names[1]</code>. Пример выше печатает <code>Второе имя: Brian</code>. Если вы попытаетесь использовать индекс, который не входит в массив, вы получите ошибку: при доступе к массивам происходит проверка границ во время исполнения программы. Такая ошибочная попытка доступа — источник многих проблем в других языках системного программирования.</p>
  <p>Вы можете найти больше информации о массивах (<code>array</code>) в <a href="http://doc.rust-lang.org/std/primitive.array.html">документации к стандартной библиотеке (англ.)</a>.</p>
  <p><a name="slices"></a> ### Срезы</p>
  <p><em>Срез</em> — это ссылка на (или «проекция» в) другую структуру данных. Они полезны, когда нужно обеспечить безопасный, эффективный доступ к части массива без копирования. Например, возможно вам нужно сослаться на единственную строку файла, считанного в память. Из-за своей ссылочной природы, срезы создаются не напрямую, а из существующих значений. У срезов есть длина, они могут быть изменяемы или нет, и во многих случаях они ведут себя как массивы:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> a = [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>];
  <span class="kw">let</span> middle = &amp;a[<span class="dv">1.</span>.<span class="dv">4</span>]; <span class="co">// Срез `a`: только элементы 1, 2, и 3</span>
  <span class="kw">let</span> complete = &amp;a[..]; <span class="co">// Срез, содержащий все элементы массива `a`</span></code></pre>
  <p>Срезы имеют тип <code>&amp;[T]</code>. О значении <code>T</code> мы поговорим позже, когда будем рассматривать <a href="#sec--generics">обобщённое программирование</a>.</p>
  <p>Вы можете найти больше информации о срезах (<code>slice</code>) в <a href="http://doc.rust-lang.org/std/primitive.slice.html">документации к стандартной библиотеке (англ.)</a>.</p>
  </section>
  <section id="str" class="level3">
  <h3><code>str</code></h3>
  <p>Тип <code>str</code> в Rust является наиболее простым типом строк. Это <a href="#sec--unsized-types">безразмерный тип</a>, поэтому сам по себе он не очень полезен, но он становится полезным при использовании ссылки, <a href="#sec--strings"><code>&amp;str</code></a>. Пока просто остановимся на этом.</p>
  <p>Вы можете найти больше информации о строках (<code>str</code>) в <a href="http://doc.rust-lang.org/std/primitive.str.html">документации к стандартной библиотеке (англ.)</a>.</p>
  <p><a name="tuples"></a> ### Кортежи</p>
  <p>Кортеж — это последовательность фиксированного размера. Вроде такой:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = (<span class="dv">1</span>, <span class="st">&quot;привет&quot;</span>);</code></pre>
  <p>Этот кортеж из двух элементов создан с помощью скобок и запятой между элементами. Вот тот же код, но с аннотациями типов:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x: (<span class="kw">i32</span>, &amp;<span class="kw">str</span>) = (<span class="dv">1</span>, <span class="st">&quot;привет&quot;</span>);</code></pre>
  <p>Как вы можете видеть, тип кортежа выглядит как сам кортеж, но места элементов занимают типы. Внимательные читатели также отметят, что кортежи гетерогенны: в этом кортеже одновременно хранятся значения типов <code>i32</code> и <code>&amp;str</code>. В языках системного программирования строки немного более сложны, чем в других языках. Пока вы можете читать <code>&amp;str</code> как <em>срез строки</em>. Мы вскоре узнаем об этом больше.</p>
  <p>Можно присваивать один кортеж другому, если они содержат значения одинаковых типов и имеют одинаковую <a href="#arity">арность</a>. Арность кортежей одинакова, когда их длина совпадает.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> x = (<span class="dv">1</span>, <span class="dv">2</span>); <span class="co">// x: (i32, i32)</span>
  <span class="kw">let</span> y = (<span class="dv">2</span>, <span class="dv">3</span>); <span class="co">// y: (i32, i32)</span>
  
  x = y;</code></pre>
  <p>Стоит отметить и ещё один момент, касающийся длины кортежей: кортеж нулевой длины (<code>()</code>; пустой кортеж) часто называют «единичным значением». Соответственно, тип такого значения — «единичный тип».</p>
  <p>Доступ к полям кортежа можно получить с помощью <em>деконструирующего let</em>. Вот пример:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> (x, y, z) = (<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>);
  
  <span class="ot">println!</span>(<span class="st">&quot;x это {}&quot;</span>, x);</code></pre>
  <p>Помните, мы <a href="#sec--variable-bindings">говорили</a>, что левая часть оператора <code>let</code> может больше, чем просто присваивать имена? Мы имели ввиду то, что приведено выше. Мы можем написать слева от <code>let</code> шаблон, и, если он совпадает со значением справа, произойдёт присваивание имён сразу нескольким значениям. В данном случае, <code>let</code> «деконструирует» или «разбивает» кортеж, и присваивает его части трём именам.</p>
  <p>Это очень удобный шаблон программирования, и мы ещё не раз увидим его.</p>
  <p>Вы можете устранить неоднозначность трактовки для кортежа, состоящего из одного элемента, и значения в скобках с помощью запятой:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">(<span class="dv">0</span>,); <span class="co">// одноэлементный кортеж</span>
  (<span class="dv">0</span>); <span class="co">// ноль в круглых скобках</span></code></pre>
  <section id="индексация-кортежей" class="level4">
  <h4>Индексация кортежей</h4>
  <p>Вы также можете получить доступ к полям кортежа с помощью индексации:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> tuple = (<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>);
  
  <span class="kw">let</span> x = tuple.<span class="dv">0</span>;
  <span class="kw">let</span> y = tuple.<span class="dv">1</span>;
  <span class="kw">let</span> z = tuple.<span class="dv">2</span>;
  
  <span class="ot">println!</span>(<span class="st">&quot;x is {}&quot;</span>, x);</code></pre>
  <p>Как и в случае индексации массивов, индексы начинаются с нуля, но здесь, в отличие от массивов, используется <code>.</code>, а не <code>[]</code>.</p>
  <p>Вы можете найти больше информации о кортежах (<code>tuple</code>) в <a href="http://doc.rust-lang.org/std/primitive.tuple.html">документации к стандартной библиотеке (англ.)</a>.</p>
  </section>
  </section>
  <section id="функции" class="level3">
  <h3>Функции</h3>
  <p>Функции тоже имеют тип! Это выглядит следующим образом:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo(x: <span class="kw">i32</span>) -&gt; <span class="kw">i32</span> { x }
  
  <span class="kw">let</span> x: <span class="kw">fn</span>(<span class="kw">i32</span>) -&gt; <span class="kw">i32</span> = foo;</code></pre>
  <p>В данном примере <code>x</code> — это «указатель на функцию», которая принимает в качестве аргумента <code>i32</code> и возвращает <code>i32</code>.</p>
  </section>
  </section>
  <section id="sec--comments" class="level2">
  <h2>Комментарии</h2>
  <p>Теперь, когда у нас есть несколько функций, неплохо бы узнать о комментариях. Комментарии — это заметки, которые вы оставляете для других программистов, чтобы помочь объяснить некоторые вещи в вашем коде. Компилятор в основном игнорирует их («в основном», потому что есть документирующие комментарии и примеры в документации).</p>
  <p>В Rust есть два вида комментариев: <em>строчные комментарии</em> и <em>doc-комментарии</em>.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">// Строчные комментарии — это всё что угодно после '//' и до конца строки.</span>
  
  <span class="kw">let</span> x = <span class="dv">5</span>; <span class="co">// это тоже строчный комментарий.</span>
  
  <span class="co">// Если у вас длинное объяснение для чего-либо, вы можете расположить строчные</span>
  <span class="co">// комментарии один за другим. Поместите пробел между '//' и вашим комментарием,</span>
  <span class="co">// так как это более читаемо.</span></code></pre>
  <p>Другое применение комментария — это doc-комментарий. Doc-комментарий использует <code>///</code> вместо <code>//</code>, и поддерживает Markdown-разметку внутри:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">/// Прибавляем единицу к заданному числу.</span>
  <span class="co">///</span>
  <span class="co">/// # Examples</span>
  <span class="co">///</span>
  <span class="co">/// ```</span>
  <span class="co">/// let five = 5;</span>
  <span class="co">///</span>
  <span class="co">/// assert_eq!(6, add_one(5));</span>
  <span class="co">/// ```</span>
  <span class="kw">fn</span> add_one(x: <span class="kw">i32</span>) -&gt; <span class="kw">i32</span> {
      x + <span class="dv">1</span>
  }</code></pre>
  <p>При написании doc-комментария очень полезно добавлять разделы для аргументов, возвращаемых значений и привести некоторые примеры использования. Заметьте, что здесь мы использовали новый макрос: <code>assert_eq!</code>. Он сравнивает два значения и вызывает <code>panic!</code>, если они не равны. Для документации такие примеры очень полезны. Так же есть и другой макрос, <code>assert!</code>, который вызывает <code>panic!</code> когда значение равно <code>false</code>.</p>
  <p>Вы можете использовать <a href="#sec--documentation"><code>rustdoc</code></a> для генерации HTML- документации из этих doc-комментариев, а так же запуска кода из примеров как тестов.</p>
  </section>
  <section id="sec--if" class="level2">
  <h2>Конструкция <code>if</code></h2>
  <p><code>if</code> в Rust не сильно сложен и больше похож на <code>if</code> в динамически типизированных языках, чем на более традиционный из системных. Давайте поговорим о нём, чтобы вы поняли некоторые его нюансы.</p>
  <p><code>if</code> является одной из форм более общего понятия, именуемого <em>ветвлением</em>. Это название произошло от ветвей деревьев: конечный результат зависит от того, какой из нескольких вариантов будет выбран.</p>
  <p><code>if</code> содержит одно условие, в зависимости от которого будет выполняться одна из двух ветвей:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">5</span>;
  
  <span class="kw">if</span> x == <span class="dv">5</span> {
      <span class="ot">println!</span>(<span class="st">&quot;x равняется пяти!&quot;</span>);
  }</code></pre>
  <p>При изменении значения <code>x</code> на какое-либо другое, эта строчка не будет выведена на экран. Если подробнее, то когда условие будет иметь значение <code>true</code>, следующий после него блок кода выполнится. В противном случае — нет.</p>
  <p>Бывает нужно что-то выполнить, если условие не выполнится (выражение будет иметь значение false). В таком случае можно использовать <code>else</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">5</span>;
  
  <span class="kw">if</span> x == <span class="dv">5</span> {
      <span class="ot">println!</span>(<span class="st">&quot;x равняется пяти!&quot;</span>);
  } <span class="kw">else</span> {
      <span class="ot">println!</span>(<span class="st">&quot;x это не пять :(&quot;</span>);
  }</code></pre>
  <p>Когда необходимо больше одного выбора, можно использовать <code>else if</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">5</span>;
  
  <span class="kw">if</span> x == <span class="dv">5</span> {
      <span class="ot">println!</span>(<span class="st">&quot;x равняется пяти!&quot;</span>);
  } <span class="kw">else</span> <span class="kw">if</span> x == <span class="dv">6</span> {
      <span class="ot">println!</span>(<span class="st">&quot;x это шесть!&quot;</span>);
  } <span class="kw">else</span> {
      <span class="ot">println!</span>(<span class="st">&quot;x это ни пять, ни шесть :(&quot;</span>);
  }</code></pre>
  <p>Всё это довольно прозаично. Однако, вы также можете сделать такую штуку:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">5</span>;
  
  <span class="kw">let</span> y = <span class="kw">if</span> x == <span class="dv">5</span> {
      <span class="dv">10</span>
  } <span class="kw">else</span> {
      <span class="dv">15</span>
  }; <span class="co">// y: i32</span></code></pre>
  <p>Которую мы можем (и должны) записать примерно следующим образом:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">5</span>;
  
  <span class="kw">let</span> y = <span class="kw">if</span> x == <span class="dv">5</span> { <span class="dv">10</span> } <span class="kw">else</span> { <span class="dv">15</span> }; <span class="co">// y: i32</span></code></pre>
  <p>Это работает, потому что <code>if</code> является выражением. Его значением является значение последнего выражения из выбранной ветви. <code>if</code> без <code>else</code> всегда возвращает <code>()</code> в качестве значения.</p>
  </section>
  <section id="sec--loops" class="level2">
  <h2>Циклы</h2>
  <p>На данный момент в Rust есть три способа организовать циклическое исполнение кода. Это <code>loop</code>, <code>while</code> и <code>for</code>. У каждого подхода своё применения.</p>
  <section id="циклы-loop" class="level4">
  <h4>Циклы <code>loop</code></h4>
  <p>Бесконечный цикл (<code>loop</code>) — простейшая форма цикла в Rust. С помощью этого ключевого слова можно организовать цикл, который продолжается, пока не выполнится какой-либо оператор, прерывающий его. Бесконечный цикл в Rust выглядит так:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">loop</span> {
      <span class="ot">println!</span>(<span class="st">&quot;Зациклились!&quot;</span>);
  }</code></pre>
  </section>
  <section id="циклы-while" class="level4">
  <h4>Циклы <code>while</code></h4>
  <p>Цикл <code>while</code> — это ещё один вид конструкции цикла в Rust. Выглядит он так:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> x = <span class="dv">5</span>; <span class="co">// mut x: i32</span>
  <span class="kw">let</span> <span class="kw">mut</span> done = <span class="kw">false</span>; <span class="co">// mut done: bool</span>
  
  <span class="kw">while</span> !done {
      x += x - <span class="dv">3</span>;
  
      <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, x);
  
      <span class="kw">if</span> x % <span class="dv">5</span> == <span class="dv">0</span> {
          done = <span class="kw">true</span>;
      }
  }</code></pre>
  <p>Он применяется, если неизвестно, сколько раз нужно выполнить тело цикла, чтобы получить результат. При каждой итерации цикла проверяется условие, и если оно истинно, то запускается следующая итерация. Иначе цикл <code>while</code> завершается.</p>
  <p>Если вам нужен бесконечный цикл, то можете сделать условие всегда истинным:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">while</span> <span class="kw">true</span> {</code></pre>
  <p>Однако, для такого случая в Rust имеется ключевое слово <code>loop</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">loop</span> {</code></pre>
  <p>В Rust анализатор потока управления обрабатывает конструкцию <code>loop</code> иначе, чем <code>while true</code>, хотя для нас это одно и тоже. На данном этапе изучения Rust нам не важно знать в чем именно различие между этими конструкциями, но если вы хотите сделать бесконечный цикл, то используйте конструкцию <code>loop</code>. Компилятор сможет транслировать ваш код в более эффективный и безопасный машинный код.</p>
  <p><a name="for"></a> #### Циклы <code>for</code></p>
  <p>Цикл <code>for</code> нужен для повторения блока кода определённое количество раз. Циклы <code>for</code> в Rust работают немного иначе, чем в других языках программирования. Например в Си-подобном языке цикл <code>for</code> выглядит так:</p>
  <pre class="sourceCode c"><code class="sourceCode c"><span class="kw">for</span> (x = <span class="dv">0</span>; x &lt; <span class="dv">10</span>; x++) {
      printf( <span class="st">&quot;%d</span><span class="ch">\n</span><span class="st">&quot;</span>, x );
  }</code></pre>
  <p>Однако, этот код в Rust будет выглядеть следующим образом:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">for</span> x in <span class="dv">0.</span>.<span class="dv">10</span> {
      <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, x); <span class="co">// x: i32</span>
  }</code></pre>
  <p>Можно представить цикл более абстрактно:</p>
  <pre class="ignore"><code>for переменная in выражение {
      тело_цикла
  }</code></pre>
  <p>Выражение — это <a href="#sec--iterators">итератор</a>. Их мы будем рассматривать позже в этом руководстве. Итератор возвращает серию элементов, где каждый элемент будет являться одной итерацией цикла. Значение этого элемента затем присваивается <code>переменной</code>, которая будет доступна в теле цикла. После окончания тела цикла, берётся следующее значение итератора и снова выполняется тело цикла. Когда в итераторе закончатся значения, цикл <code>for</code> завершается.</p>
  <p>В нашем примере, <code>0..10</code> — это выражение, которое задаёт начальное и конечное значение, и возвращает итератор. Обратите внимание, что конечное значение не включается в него. В нашем примере будут напечатаны числа от <code>0</code> до <code>9</code>, но не будет напечатано <code>10</code>.</p>
  <p>В Rust намеренно нет цикла <code>for</code> в стиле C. Управлять каждым элементом цикла вручную сложно, и это может приводить к ошибкам даже у опытных программистов на C.</p>
  <section id="перечисление" class="level5">
  <h5>Перечисление</h5>
  <p>Если вы хотите отслеживать число прошедших итераций, используйте функцию <code>.enumerate()</code>.</p>
  <section id="с-интервалами" class="level6">
  <h6>С интервалами</h6>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">for</span> (i,j) in (<span class="dv">5.</span>.<span class="dv">10</span>).enumerate() {
      <span class="ot">println!</span>(<span class="st">&quot;i = {} и j = {}&quot;</span>, i, j);
  }</code></pre>
  <p>Выводит:</p>
  <pre class="text"><code>i = 0 и j = 5
  i = 1 и j = 6
  i = 2 и j = 7
  i = 3 и j = 8
  i = 4 и j = 9</code></pre>
  <p>Не забудьте написать скобки вокруг интервала.</p>
  </section>
  <section id="с-итераторами" class="level6">
  <h6>С итераторами</h6>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">for</span> (linenumber, line) in lines.enumerate() {
      <span class="ot">println!</span>(<span class="st">&quot;{}: {}&quot;</span>, linenumber, line);
  }</code></pre>
  <p>Outputs:</p>
  <pre class="text"><code>0: привет
  1: мир
  2: hello
  3: world</code></pre>
  </section>
  </section>
  </section>
  <section id="раннее-прерывание-цикла" class="level4">
  <h4>Раннее прерывание цикла</h4>
  <p>Давайте ещё раз посмотрим на цикл <code>while</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> x = <span class="dv">5</span>;
  <span class="kw">let</span> <span class="kw">mut</span> done = <span class="kw">false</span>;
  
  <span class="kw">while</span> !done {
      x += x - <span class="dv">3</span>;
  
      <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, x);
  
      <span class="kw">if</span> x % <span class="dv">5</span> == <span class="dv">0</span> {
          done = <span class="kw">true</span>;
      }
  }</code></pre>
  <p>В этом примере в условии для выхода из цикла используется изменяемое имя <code>done</code> логического типа. В Rust имеются два ключевых слова, которые помогают работать с итерациями цикла: <code>break</code> и <code>continue</code>.</p>
  <p>Мы можем переписать цикл с помощью <code>break</code>, чтобы избавиться от переменной <code>done</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> x = <span class="dv">5</span>;
  
  <span class="kw">loop</span> {
      x += x - <span class="dv">3</span>;
  
      <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, x);
  
      <span class="kw">if</span> x % <span class="dv">5</span> == <span class="dv">0</span> { <span class="kw">break</span>; }
  }</code></pre>
  <p>Теперь мы используем бесконечный цикл <code>loop</code> и <code>break</code> для выхода из цикла. Использование явного <code>return</code> также остановит выполнение цикла.</p>
  <p><code>continue</code> похож на <code>break</code>, но вместо выхода из цикла переходит к следующей итерации. Следующий пример отобразит только нечётные числа:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">for</span> x in <span class="dv">0.</span>.<span class="dv">10</span> {
      <span class="kw">if</span> x % <span class="dv">2</span> == <span class="dv">0</span> { <span class="kw">continue</span>; }
  
      <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, x);
  }</code></pre>
  </section>
  <section id="метки-циклов" class="level4">
  <h4>Метки циклов</h4>
  <p>Когда у вас много вложенных циклов, вы можете захотеть указать, к какому именно циклу относится <code>break</code> или <code>continue</code>. Как и во многих других языках, по умолчанию эти операторы будут относиться к самому внутреннему циклу. Если вы хотите прервать внешний цикл, вы можете использовать метку. Так, этот код будет печатать на экране только когда и <code>x</code>, и <code>y</code> нечётны:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="ot">'outer</span>: <span class="kw">for</span> x in <span class="dv">0.</span>.<span class="dv">10</span> {
      <span class="ot">'inner</span>: <span class="kw">for</span> y in <span class="dv">0.</span>.<span class="dv">10</span> {
          <span class="kw">if</span> x % <span class="dv">2</span> == <span class="dv">0</span> { <span class="kw">continue</span> <span class="ot">'outer</span>; } <span class="co">// продолжает цикл по x</span>
          <span class="kw">if</span> y % <span class="dv">2</span> == <span class="dv">0</span> { <span class="kw">continue</span> <span class="ot">'inner</span>; } <span class="co">// продолжает цикл по y</span>
          <span class="ot">println!</span>(<span class="st">&quot;x: {}, y: {}&quot;</span>, x, y);
      }
  }</code></pre>
  </section>
  </section>
  <section id="sec--ownership" class="level2">
  <h2>Владение</h2>
  <p>Эта глава является одной из трёх, описывающих систему владения ресурсами Rust. Эта система представляет собой наиболее уникальную и привлекательную особенность Rust, о которой разработчики должны иметь полное представление. Владение — это то, как Rust достигает своей главной цели — безопасности памяти. Система владения включает в себя несколько различных концепций, каждая из которых рассматривается в своей собственной главе:</p>
  <ul>
  <li>владение, её вы читаете сейчас</li>
  <li><a href="#sec--references-and-borrowing">заимствование</a>, и связанная с ним возможность «ссылки»</li>
  <li><a href="#sec--lifetimes">время жизни</a>, расширение понятия заимствования</li>
  </ul>
  <p>Эти три главы взаимосвязаны, и их порядок важен. Вы должны будете освоить все три главы, чтобы полностью понять систему владения.</p>
  <section id="мета" class="level3">
  <h3>Мета</h3>
  <p>Прежде чем перейти к подробностям, отметим два важных момента в системе владения.</p>
  <p>Rust сфокусирован на безопасности и скорости. Это достигается за счёт «абстракций с нулевой стоимостью» (zero-cost abstractions). Это значит, что в Rust стоимость абстракций должна быть настолько малой, насколько это возможно без ущерба для работоспособности. Система владения ресурсами — это яркий пример абстракции с нулевой стоимостью. Весь анализ, о котором мы будем говорить в этом руководстве, выполняется <em>во время компиляции</em>. Во время исполнения вы не платите за какую-либо из возможностей ничего.</p>
  <p>Тем не менее, эта система всё же имеет определённую стоимость: кривая обучения. Многие новые пользователи Rust «борются с проверкой заимствования» — компилятор Rust отказывается компилировать программу, которая по мнению автора является абсолютно правильной. Это часто происходит потому, что мысленное представление программиста о том, как должно работать владение, не совпадает с реальными правилами, которыми оперирует Rust. Вы, наверное, поначалу также будете испытывать подобные трудности. Однако существует и хорошая новость: более опытные разработчики на Rust говорят, что чем больше они работают с правилами системы владения, тем меньше они борются с компилятором.</p>
  <p>Имея это в виду, давайте перейдём к изучению системы владения.</p>
  </section>
  <section id="владение" class="level3">
  <h3>Владение</h3>
  <p><a href="#sec--variable-bindings">Связанные имена</a> имеют одну особенность в Rust: они «владеют» тем, с чем они связаны. Это означает, что, когда имя выходит за пределы области видимости, ресурс, с которым оно связано, будет освобождён. Например:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo() {
      <span class="kw">let</span> v = <span class="ot">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  }</code></pre>
  <p>Когда <code>v</code> входит в область видимости, создаётся новый <a href="http://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec&lt;T&gt;</code></a>. В данном случае вектор также выделяет из <a href="#sec--the-stack-and-the-heap">кучи</a> пространство для трёх элементов. Когда <code>v</code> выходит из области видимости в конце <code>foo()</code>, Rust очищает все, связанное с вектором, даже динамически выделенную память. Это происходит детерминировано, в конце области видимости.</p>
  <p><a name="move-semantics"></a> ### Семантика перемещения</p>
  <p>Хотя тут есть некоторые тонкости: Rust гарантирует, что существует <em>ровно одно</em> связывание какого-либо ресурса. Например, если у нас есть вектор, то мы можем присвоить этот вектор другому имени:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> v = <span class="ot">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  
  <span class="kw">let</span> v2 = v;</code></pre>
  <p>Но, если после этого мы попытаемся использовать <code>v</code>, то получим ошибку:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> v = <span class="ot">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  
  <span class="kw">let</span> v2 = v;
  
  <span class="ot">println!</span>(<span class="st">&quot;v[0] = {}&quot;</span>, v[<span class="dv">0</span>]);</code></pre>
  <p>Ошибка выглядит следующим образом:</p>
  <pre class="text"><code>error: use of moved value: `v`
  println!(&quot;v[0] = {}&quot;, v[0]);
                          ^</code></pre>
  <p>То же самое произойдёт, если мы определим функцию, которая принимает владение, и попробуем использовать значение после того, как мы передали это значение в качестве аргумента в эту функцию:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> take(v: Vec&lt;<span class="kw">i32</span>&gt;) {
      <span class="co">// что будет здесь не очень важно</span>
  }
  
  <span class="kw">let</span> v = <span class="ot">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  
  take(v);
  
  <span class="ot">println!</span>(<span class="st">&quot;v[0] = {}&quot;</span>, v[<span class="dv">0</span>]);</code></pre>
  <p>Та же самая ошибка: «use of moved value» («используется перемещённое значение»). Когда мы передаём право владения куда-то ещё, мы как бы говорим, что мы «перемещаем» то, на что ссылаемся. При этом не нужно указывать какую-либо специальную аннотацию, Rust делает это по умолчанию.</p>
  <section id="подробности" class="level4">
  <h4>Подробности</h4>
  <p>Причина, по которой мы не можем использовать значение после того, как мы его переместили, неочевидна, но очень важна. Когда мы пишем код вроде этого:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> v = <span class="ot">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  
  <span class="kw">let</span> v2 = v;</code></pre>
  <p>Первая строка создаёт некоторые данные для вектора в <a href="#sec--the-stack-and-the-heap">стеке</a>, <code>v</code>. Данные самого вектора, однако, сохраняются в <a href="#sec--the-stack-and-the-heap">куче</a>, и поэтому стековые данные содержат указатель на данные в куче. Когда мы перемещаем <code>v</code> в <code>v2</code>, то создаётся копия стековых данных для <code>v2</code>. Что будет означать, что два указателя ссылаются на расположенный в куче вектор. Такое поведение могло бы быть проблемой: оно нарушало бы гарантии безопасности Rust, привнося гонки по данным. Поэтому Rust запрещает использование <code>v</code> после того, как мы выполнили его перемещение.</p>
  <p>Важно также отметить, что оптимизация может удалить саму копию байтов на стеке, в зависимости от обстоятельств. Так что это может быть не так уж неэффективно, как выглядит на первый взгляд.</p>
  </section>
  <section id="типы-реализующие-типаж-copy" class="level4">
  <h4>Типы, реализующие типаж <code>Copy</code></h4>
  <p>Мы установили, что как только владение передаётся другому имени, вы больше не можете использовать исходное. Тем не менее, существует <a href="#sec--traits">типаж</a>, который изменяет такое поведение, и он называется <code>Copy</code>. Мы ещё не обсуждали типажи, но пока вы можете думать о них как об аннотациях к конкретному типу, которые придают дополнительное поведение. Например:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> v = <span class="dv">1</span>;
  
  <span class="kw">let</span> v2 = v;
  
  <span class="ot">println!</span>(<span class="st">&quot;v = {}&quot;</span>, v);</code></pre>
  <p>В этом примере <code>v</code> связан с типом <code>i32</code>. Этот тип реализует типаж <code>Copy</code>. Это означает, что когда мы присваиваем значение <code>v</code> имени <code>v2</code>, будет создана копия данных, как и при перемещении. Но, в отличие от перемещения, мы можем использовать <code>v</code> в дальнейшем. Это происходит потому, что в <code>i32</code> нет указателей на данные в каком-либо другом месте. При таком копировании создаётся полная копия.</p>
  <p>Мы будем обсуждать, как сделать свои собственные типы, реализующие типаж <code>Copy</code> в разделе <a href="#sec--traits">Типажи</a>.</p>
  </section>
  </section>
  <section id="больше-чем-владение" class="level3">
  <h3>Больше, чем владение</h3>
  <p>Конечно, если бы нам нужно было вернуть владение обратно из функции, то мы бы написали:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo(v: Vec&lt;<span class="kw">i32</span>&gt;) -&gt; Vec&lt;<span class="kw">i32</span>&gt; {
      <span class="co">// делаем что-либо с v</span>
  
      <span class="co">// возвращаем владение</span>
      v
  }</code></pre>
  <p>Это сильно утомляет. Функция становится тем хуже, чем больше прав владения она хочет забрать себе:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo(v1: Vec&lt;<span class="kw">i32</span>&gt;, v2: Vec&lt;<span class="kw">i32</span>&gt;) -&gt; (Vec&lt;<span class="kw">i32</span>&gt;, Vec&lt;<span class="kw">i32</span>&gt;, <span class="kw">i32</span>) {
      <span class="co">// делаем что-нибудь с v1 и v2</span>
  
      <span class="co">// возвращаем владение и результат нашей функции</span>
      (v1, v2, <span class="dv">42</span>)
  }
  
  <span class="kw">let</span> v1 = <span class="ot">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  <span class="kw">let</span> v2 = <span class="ot">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  
  <span class="kw">let</span> (v1, v2, answer) = foo(v1, v2);</code></pre>
  <p>Брр! Возвращаемый тип, строка возврата, и вызов функции получается намного более сложным.</p>
  <p>К счастью, Rust предлагает такую возможность, как заимствование, которая помогает нам решить эту проблему. Это тема следующего раздела!</p>
  </section>
  </section>
  <section id="sec--references-and-borrowing" class="level2">
  <h2>Ссылки и заимствование</h2>
  <p>Эта глава является одной из трёх, описывающих систему владения ресурсами Rust. Эта система представляет собой наиболее уникальную и привлекательную особенность Rust, о которой разработчики должны иметь полное представление. Владение — это то, как Rust достигает своей главной цели — безопасности памяти. Система владения включает в себя несколько различных концепций, каждая из которых рассматривается в своей собственной главе:</p>
  <ul>
  <li><a href="#sec--ownership">владение</a>, ключевая концепция</li>
  <li>заимствование, её вы читаете сейчас</li>
  <li><a href="#sec--lifetimes">время жизни</a>, расширение понятия заимствования</li>
  </ul>
  <p>Эти три главы взаимосвязаны, и их порядок важен. Вы должны будете освоить все три главы, чтобы полностью понять систему владения.</p>
  <section id="мета-1" class="level3">
  <h3>Мета</h3>
  <p>Прежде чем перейти к подробностям, отметим два важных момента в системе владения.</p>
  <p>Rust сфокусирован на безопасности и скорости. Это достигается за счёт «абстракций с нулевой стоимостью» (zero-cost abstractions). Это значит, что в Rust стоимость абстракций должна быть настолько малой, насколько это возможно без ущерба для работоспособности. Система владения ресурсами — это яркий пример абстракции с нулевой стоимостью. Весь анализ, о котором мы будем говорить в этом руководстве, выполняется <em>во время компиляции</em>. Во время исполнения вы не платите за какую-либо из возможностей ничего.</p>
  <p>Тем не менее, эта система всё же имеет определённую стоимость: кривая обучения. Многие новые пользователи Rust «борются с проверкой заимствования» — компилятор Rust отказывается компилировать программу, которая по мнению автора является абсолютно правильной. Это часто происходит потому, что мысленное представление программиста о том, как должно работать владение, не совпадает с реальными правилами, которыми оперирует Rust. Вы, наверное, поначалу также будете испытывать подобные трудности. Однако существует и хорошая новость: более опытные разработчики на Rust говорят, что чем больше они работают с правилами системы владения, тем меньше они борются с компилятором.</p>
  <p>Имея это в виду, давайте перейдём к изучению системы владения.</p>
  <p><a name="borrowing"></a> ### Заимствование</p>
  <p>В конце главы <a href="#sec--ownership">Владение</a> у нас была убогая функция, которая выглядела так:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo(v1: Vec&lt;<span class="kw">i32</span>&gt;, v2: Vec&lt;<span class="kw">i32</span>&gt;) -&gt; (Vec&lt;<span class="kw">i32</span>&gt;, Vec&lt;<span class="kw">i32</span>&gt;, <span class="kw">i32</span>) {
      <span class="co">// do stuff with v1 and v2</span>
  
      <span class="co">// hand back ownership, and the result of our function</span>
      (v1, v2, <span class="dv">42</span>)
  }
  
  <span class="kw">let</span> v1 = <span class="ot">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  <span class="kw">let</span> v2 = <span class="ot">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  
  <span class="kw">let</span> (v1, v2, answer) = foo(v1, v2);</code></pre>
  <p>Однако, этот код не является идиоматичным с точки зрения Rust, так как он не использует заимствование. Вот первый шаг:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo(v1: &amp;Vec&lt;<span class="kw">i32</span>&gt;, v2: &amp;Vec&lt;<span class="kw">i32</span>&gt;) -&gt; <span class="kw">i32</span> {
      <span class="co">// do stuff with v1 and v2</span>
  
      <span class="co">// return the answer</span>
      <span class="dv">42</span>
  }
  
  <span class="kw">let</span> v1 = <span class="ot">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  <span class="kw">let</span> v2 = <span class="ot">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  
  <span class="kw">let</span> answer = foo(&amp;v1, &amp;v2);
  
  <span class="co">// we can use v1 and v2 here!</span></code></pre>
  <p>Вместо того, чтобы принимать <code>Vec&lt;i32&gt;</code> в качестве аргументов, мы будем принимать ссылки: <code>&amp;Vec&lt;i32&gt;</code>. И вместо передачи <code>v1</code> и <code>v2</code> напрямую, мы будем передавать <code>&amp;v1</code> и <code>&amp;v2</code>. Мы называем тип <code>&amp;T</code> «ссылка», и вместо того, чтобы забирать владение ресурсом, она его заимствует. Имена, которые заимствуют что- то, не освобождают ресурс, когда они выходят из области видимости. Это означает, что, после вызова <code>foo()</code>, мы снова можем использовать наши исходные имена.</p>
  <p>Ссылки являются неизменяемыми, как и имена. Это означает, что внутри <code>foo()</code> векторы не могут быть изменены:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo(v: &amp;Vec&lt;<span class="kw">i32</span>&gt;) {
       v.push(<span class="dv">5</span>);
  }
  
  <span class="kw">let</span> v = <span class="ot">vec!</span>[];
  
  foo(&amp;v);</code></pre>
  <p>выдаёт ошибку:</p>
  <pre class="text"><code>error: cannot borrow immutable borrowed content `*v` as mutable
  v.push(5);
  ^</code></pre>
  <p>Добавление значения изменяет вектор, и поэтому компилятор не позволил нам это сделать.</p>
  </section>
  <section id="ссылки-mut" class="level3">
  <h3>Ссылки &amp;mut</h3>
  <p>Вот второй вид ссылок: <code>&amp;mut T</code>. Это «изменяемая ссылка», которая позволяет изменять ресурс, который вы заимствуете. Например:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> x = <span class="dv">5</span>;
  {
      <span class="kw">let</span> y = &amp;<span class="kw">mut</span> x;
      *y += <span class="dv">1</span>;
  }
  <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, x);</code></pre>
  <p>Этот код напечатает <code>6</code>. Мы создали <code>y</code>, изменяемую ссылку на <code>x</code>, а затем добавили единицу к значению, на которое указывает <code>y</code>. Следует отметить, что <code>x</code> также должно быть помечено как <code>mut</code>. Если бы этого не было, то мы не могли бы получить изменяемую ссылку неизменяемого значения.</p>
  <p>Во всем остальном изменяемые ссылки (<code>&amp;mut</code>) такие же, как и неизменяемые (<code>&amp;</code>). Однако, существует большая разница между этими двумя концепциями, и тем, как они взаимодействуют. Вы можете сказать, что в приведённом выше примере есть что-то подозрительное, потому что нам зачем-то понадобилась дополнительная область видимости, созданная с помощью <code>{</code> и <code>}</code>. Если мы уберем эти скобки, то получим ошибку:</p>
  <pre class="text"><code>error: cannot borrow `x` as immutable because it is also borrowed as mutable
      println!(&quot;{}&quot;, x);
                     ^
  note: previous borrow of `x` occurs here; the mutable borrow prevents
  subsequent moves, borrows, or modification of `x` until the borrow ends
          let y = &amp;mut x;
                       ^
  note: previous borrow ends here
  fn main() {
  
  }
  ^</code></pre>
  <p>Оказывается, есть определённые правила создания ссылок.</p>
  </section>
  <section id="правила" class="level3">
  <h3>Правила</h3>
  <p>Вот правила заимствования в Rust.</p>
  <p>Во-первых, область видимости любой ссылки должна находиться в пределах области видимости владельца. Во-вторых, одновременно у вас может быть только один из двух перечисленных ниже видов заимствования, но не оба сразу:</p>
  <ul>
  <li>одна или более неизменяемых ссылок (<code>&amp;T</code>) на ресурс;</li>
  <li>ровно одна изменяемая ссылка (<code>&amp;mut T</code>) на ресурс.</li>
  </ul>
  <p>Вы можете заметить, что это похоже, хотя и не соответствует точно, определению состояния гонки данных:</p>
  <blockquote>
  <p>Состояние «гонки данных» возникает, когда два или более указателей осуществляют доступ к одной и той же области памяти одновременно, по крайней мере один из них производит запись, и операции не синхронизированы.</p>
  </blockquote>
  <p>Что касается неизменяемых ссылок, то вы можете иметь их столько, сколько хотите, так как ни одна из них не производит запись. Если же вы производите запись, и вам нужно два или больше указателей на одну и ту же область памяти, то вы можете иметь только одну <code>&amp;mut</code> одновременно. Так Rust предотвращает возникновение состояния гонки данных во время компиляции: мы получим ошибку компиляции, если нарушим эти правила.</p>
  <p>Имея это в виду, давайте рассмотрим наш пример еще раз.</p>
  <section id="осмысливаем-области-видимости-thinking-in-scopes" class="level4">
  <h4>Осмысливаем области видимости (Thinking in scopes)</h4>
  <p>Вот код:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> x = <span class="dv">5</span>;
  <span class="kw">let</span> y = &amp;<span class="kw">mut</span> x;
  
  *y += <span class="dv">1</span>;
  
  <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, x);</code></pre>
  <p>Этот код выдает нам такую ошибку:</p>
  <pre class="text"><code>error: cannot borrow `x` as immutable because it is also borrowed as mutable
      println!(&quot;{}&quot;, x);
                     ^</code></pre>
  <p>Это потому, что мы нарушили правила: у нас есть изменяемая ссылка <code>&amp;mut T</code>, указывающая на <code>x</code>, и поэтому мы не можем создать какую-либо <code>&amp;T</code>. Одно из двух. Примечание подсказывает как следует рассматривать эту проблему:</p>
  <pre class="text"><code>note: previous borrow ends here
  fn main() {
  
  }
  ^</code></pre>
  <p>Другими словами, изменяемая ссылка сохраняется до конца нашего примера. А мы хотим, чтобы изменяемое заимствование заканчивалось <em>до</em> того, как мы пытаемся вызвать <code>println!</code> и создать неизменяемое заимствование. В Rust заимствование привязано к области видимости, в которой оно является действительным. И эти области видимости выглядят следующим образом:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> x = <span class="dv">5</span>;
  
  <span class="kw">let</span> y = &amp;<span class="kw">mut</span> x;    <span class="co">// -+ заимствование x через &amp;mut начинается здесь</span>
                     <span class="co">//  |</span>
  *y += <span class="dv">1</span>;           <span class="co">//  |</span>
                     <span class="co">//  |</span>
  <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, x); <span class="co">// -+ - пытаемся позаимствовать x здесь</span>
                     <span class="co">// -+ заимствование x через &amp;mut заканчивается здесь</span></code></pre>
  <p>Конфликт областей видимости: мы не можем создать <code>&amp;x</code> до тех пор, пока <code>y</code> находится в области видимости.</p>
  <p>Поэтому, когда мы добавляем фигурные скобки:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> x = <span class="dv">5</span>;
  
  {                   
      <span class="kw">let</span> y = &amp;<span class="kw">mut</span> x; <span class="co">// -+ заимствование через &amp;mut начинается здесь</span>
      *y += <span class="dv">1</span>;        <span class="co">//  |</span>
  }                   <span class="co">// -+ ... и заканчивается здесь</span>
  
  <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, x);  <span class="co">// &lt;- пытаемся позаимствовать x здесь</span></code></pre>
  <p>Никаких проблем нет. Наша изменяемая ссылка выходит из области видимости до создания неизменяемой. Но область видимости является ключом к определению того, как долго длится заимствование.</p>
  </section>
  <section id="проблемы-которые-предотвращает-заимствование" class="level4">
  <h4>Проблемы, которые предотвращает заимствование</h4>
  <p>Почему нужны эти ограничивающие правила? Ну, как мы уже отметили, эти правила предотвращают гонки данных. Какие виды проблем могут привести к состоянию гонки данных? Вот некоторые из них.</p>
  <section id="недействительный-итератор" class="level5">
  <h5>Недействительный итератор</h5>
  <p>Одним из примеров является «недействительный итератор». Такое может произойти, когда вы пытаетесь изменить коллекцию, которую в данный момент обходите. Проверка заимствования Rust предотвращает это:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> v = <span class="ot">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  
  <span class="kw">for</span> i in &amp;v {
      <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, i);
  }</code></pre>
  <p>Этот код печатает числа от одного до трёх. Когда мы обходим вектор, мы получаем лишь ссылки на элементы. И сам <code>v</code> заимствован как неизменяемый, что означает, что мы не можем изменить его в процессе обхода:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> v = <span class="ot">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  
  <span class="kw">for</span> i in &amp;v {
      <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, i);
      v.push(<span class="dv">34</span>);
  }</code></pre>
  <p>Вот ошибка:</p>
  <pre class="text"><code>error: cannot borrow `v` as mutable because it is also borrowed as immutable
      v.push(34);
      ^
  note: previous borrow of `v` occurs here; the immutable borrow prevents
  subsequent moves or mutable borrows of `v` until the borrow ends
  for i in &amp;v {
            ^
  note: previous borrow ends here
  for i in &amp;v {
      println!(“{}”, i);
      v.push(34);
  }
  ^</code></pre>
  <p>Мы не можем изменить <code>v</code>, потому что он уже заимствован в цикле.</p>
  </section>
  <section id="использование-после-освобождения-use-after-free" class="level5">
  <h5>Использование после освобождения (use after free)</h5>
  <p>Ссылки должны жить так же долго, как и ресурс, на который они ссылаются. Rust проверяет области видимости ваших ссылок, чтобы удостовериться, что это правда.</p>
  <p>Если Rust не будет проверять это свойство, то мы можем случайно использовать ссылку, которая будет недействительна. Например:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> y: &amp;<span class="kw">i32</span>;
  {
      <span class="kw">let</span> x = <span class="dv">5</span>;
      y = &amp;x;
  }
  
  <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, y);</code></pre>
  <p>Мы получим следующую ошибку:</p>
  <pre class="text"><code>error: `x` does not live long enough
      y = &amp;x;
           ^
  note: reference must be valid for the block suffix following statement 0 at
  2:16...
  let y: &amp;i32;
  {
      let x = 5;
      y = &amp;x;
  }
  
  note: ...but borrowed value is only valid for the block suffix following
  statement 0 at 4:18
      let x = 5;
      y = &amp;x;
  }</code></pre>
  <p>Другими словами, <code>y</code> действителен только для той области видимости, где существует <code>x</code>. Как только <code>x</code> выходит из области видимости, ссылка на него становится недействительной. Таким образом, ошибка сообщает, что заимствование «не живет достаточно долго» («does not live long enough»), потому что оно не является действительным столько времени, сколько требуется.</p>
  <p>Такая же проблема возникает, когда ссылка объявлена <em>перед</em> значением, на которое она ссылается. Это происходит потому что ресурсы в одном блоке освобождаются в порядке, противоположном порядку их объявления:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> y: &amp;<span class="kw">i32</span>;
  <span class="kw">let</span> x = <span class="dv">5</span>;
  y = &amp;x;
  
  <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, y);</code></pre>
  <p>Мы получим такую ошибку:</p>
  <pre class="text"><code>error: `x` does not live long enough
  y = &amp;x;
       ^
  note: reference must be valid for the block suffix following statement 0 at
  2:16...
      let y: &amp;i32;
      let x = 5;
      y = &amp;x;
  
      println!(&quot;{}&quot;, y);
  }
  
  note: ...but borrowed value is only valid for the block suffix following
  statement 1 at 3:14
      let x = 5;
      y = &amp;x;
  
      println!(&quot;{}&quot;, y);
  }</code></pre>
  <p>В примере выше <code>y</code> объявлена перед <code>x</code>, т.е. живёт дольше <code>x</code>, а это запрещено.</p>
  </section>
  </section>
  </section>
  </section>
  <section id="sec--lifetimes" class="level2">
  <h2>Время жизни</h2>
  <p>Эта глава является одной из трёх, описывающих систему владения ресурсами Rust. Эта система представляет собой наиболее уникальную и привлекательную особенность Rust, о которой разработчики должны иметь полное представление. Владение — это то, как Rust достигает своей главной цели — безопасности памяти. Система владения включает в себя несколько различных концепций, каждая из которых рассматривается в своей собственной главе:</p>
  <ul>
  <li><a href="#sec--ownership">владение</a>, ключевая концепция</li>
  <li><a href="#sec--references-and-borrowing">заимствование</a>, и связанная с ним возможность «ссылки»</li>
  <li>время жизни, её вы читаете сейчас</li>
  </ul>
  <p>Эти три главы взаимосвязаны, и их порядок важен. Вы должны будете освоить все три главы, чтобы полностью понять систему владения.</p>
  <section id="мета-2" class="level3">
  <h3>Мета</h3>
  <p>Прежде чем перейти к подробностям, отметим два важных момента в системе владения.</p>
  <p>Rust сфокусирован на безопасности и скорости. Это достигается за счёт «абстракций с нулевой стоимостью» (zero-cost abstractions). Это значит, что в Rust стоимость абстракций должна быть настолько малой, насколько это возможно без ущерба для работоспособности. Система владения ресурсами — это яркий пример абстракции с нулевой стоимостью. Весь анализ, о котором мы будем говорить в этом руководстве, выполняется <em>во время компиляции</em>. Во время исполнения вы не платите за какую-либо из возможностей ничего.</p>
  <p>Тем не менее, эта система всё же имеет определённую стоимость: кривая обучения. Многие пользователи Rust занимаются тем, что мы зовём «борьбой с проверкой заимствования» — компилятор Rust отказывается компилировать программу, которая по мнению автора является абсолютно правильной. Это часто происходит потому, что мысленное представление программиста о том, как должно работать владение, не совпадает с реальными правилами, которыми оперирует Rust. Вы, наверное, поначалу также будете испытывать подобные трудности. Однако существует и хорошая новость: более опытные разработчики на Rust говорят, что чем больше они работают с правилами системы владения, тем меньше они борются с компилятором.</p>
  <p>Имея это в виду, давайте перейдём к изучению системы владения.</p>
  </section>
  <section id="время-жизни" class="level3">
  <h3>Время жизни</h3>
  <p>Одалживание ссылки на ресурс, которым кто-то владеет, может быть довольно сложным. Например, представьте себе следующую последовательность операций:</p>
  <ul>
  <li>Мы получаем абстрактную ссылку на какой-то ресурс.</li>
  <li>Мы одалживаем вам ссылку на этот ресурс.</li>
  <li>Мы решаем, что ресурс нам больше не требуется, и освобождаем его, в то время как у вас все еще есть на него ссылка.</li>
  <li>Вы решаете использовать этот ресурс.</li>
  </ul>
  <p>Ой-ой! Ваша ссылка указывает на недопустимый ресурс. Это называется «висячий указатель» или «использование после освобождения», когда ресурсом является память.</p>
  <p>Чтобы исправить это, мы должны убедиться, что четвертый шаг никогда не произойдет после третьего. Система владения в Rust делает это через понятие времени жизни, которое описывает область видимости, на протяжении которой ссылка будет действительна.</p>
  <p>Когда у нас есть функция, которая принимает ссылку в качестве аргумента, мы можем явно или неявно указать время жизни ссылки:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">// неявно</span>
  <span class="kw">fn</span> foo(x: &amp;<span class="kw">i32</span>) {
  }
  
  <span class="co">// явно</span>
  <span class="kw">fn</span> bar&lt;<span class="ot">'a</span>&gt;(x: &amp;<span class="ot">'a</span> <span class="kw">i32</span>) {
  }</code></pre>
  <p>Читается <code>'a</code> как «время жизни a». Технически, все ссылки имеют некоторое время жизни, связанное с ними, но компилятор позволяет опускать его в общих случаях. Прежде чем мы перейдем к этому, давайте разберем пример ниже, с явным указанием времени жизни:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> bar&lt;<span class="ot">'a</span>&gt;(...)</code></pre>
  <p>Эта часть объявляет параметры времени жизни. Она говорит, что <code>bar</code> имеет один параметр времени жизни, <code>'a</code>. Если бы в качестве параметров функции у нас было две ссылки, то это выглядело бы так:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> bar&lt;<span class="ot">'a</span>, <span class="ot">'b</span>&gt;(...)</code></pre>
  <p>Затем в списке параметров функции мы используем заданные параметры времени жизни:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">...(x: &amp;<span class="ot">'a</span> <span class="kw">i32</span>)</code></pre>
  <p>Если бы мы хотели <code>&amp;mut</code> ссылку, то сделали бы так:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">...(x: &amp;<span class="ot">'a</span> <span class="kw">mut</span> <span class="kw">i32</span>)</code></pre>
  <p>Если вы сравните <code>&amp;mut i32</code> с <code>&amp;'a mut i32</code>, то увидите, что они отличаются только определением времени жизни <code>'a</code>, написанным между <code>&amp;</code> и <code>mut i32</code>. <code>&amp;mut i32</code> читается как «изменяемая ссылка на i32», а <code>&amp;'a mut i32</code> — как «изменяемая ссылка на i32 со временем жизни ’a».</p>
  <section id="внутри-structlifetimes.mdstructов" class="level4">
  <h4>Внутри <a href="#sec--structs"><code>struct</code></a>’ов</h4>
  <p>Вы также должны будете явно указать время жизни при работе со <a href="#sec--structs"><code>struct</code></a>’ми:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Foo&lt;<span class="ot">'a</span>&gt; {
      x: &amp;<span class="ot">'a</span> <span class="kw">i32</span>,
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> y = &amp;<span class="dv">5</span>; <span class="co">// то же самое, что и `let _y = 5; let y = &amp;_y;`</span>
      <span class="kw">let</span> f = Foo { x: y };
  
      <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, f.x);
  }</code></pre>
  <p>Как вы можете заметить, структуры также могут иметь время жизни. Так же как и функции,</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Foo&lt;<span class="ot">'a</span>&gt; {</code></pre>
  <p>объявляет время жизни и</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">x: &amp;<span class="ot">'a</span> <span class="kw">i32</span>,</code></pre>
  <p>использует его. Почему же мы должны определять время жизни здесь? Мы должны убедиться, что ссылка на <code>Foo</code> не может жить дольше, чем ссылка на <code>i32</code>, содержащаяся в нем.</p>
  </section>
  <section id="блоки-impl" class="level4">
  <h4>Блоки <code>impl</code></h4>
  <p>Давайте реализуем метод для <code>Foo</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Foo&lt;<span class="ot">'a</span>&gt; {
      x: &amp;<span class="ot">'a</span> <span class="kw">i32</span>,
  }
  
  <span class="kw">impl</span>&lt;<span class="ot">'a</span>&gt; Foo&lt;<span class="ot">'a</span>&gt; {
      <span class="kw">fn</span> x(&amp;<span class="kw">self</span>) -&gt; &amp;<span class="ot">'a</span> <span class="kw">i32</span> { <span class="kw">self</span>.x }
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> y = &amp;<span class="dv">5</span>; <span class="co">// то же самое, что и `let _y = 5; let y = &amp;_y;`</span>
      <span class="kw">let</span> f = Foo { x: y };
  
      <span class="ot">println!</span>(<span class="st">&quot;x is: {}&quot;</span>, f.x());
  }</code></pre>
  <p>Как вы можете видеть, нам нужно объявить время жизни для <code>Foo</code> в строке с <code>impl</code>. Мы повторяем <code>'a</code> дважды, как в функциях: <code>impl&lt;'a&gt;</code> определяет время жизни <code>'a</code>, и <code>Foo&lt;'a&gt;</code> использует его.</p>
  </section>
  <section id="несколько-времён-жизни-multiple-lifetimes" class="level4">
  <h4>Несколько времён жизни (Multiple lifetimes)</h4>
  <p>Если вы имеете несколько ссылок, вы можете использовать одно и то же время жизни несколько раз:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> x_or_y&lt;<span class="ot">'a</span>&gt;(x: &amp;<span class="ot">'a</span> <span class="kw">str</span>, y: &amp;<span class="ot">'a</span> <span class="kw">str</span>) -&gt; &amp;<span class="ot">'a</span> <span class="kw">str</span> {</code></pre>
  <p>Этот код говорит, что <code>x</code> и <code>y</code> находятся в одной области видимости друг с другом, и что возвращаемое значение живо на протяжении той же области видимости. Если вы хотите, чтобы <code>x</code> и <code>y</code> имели разные времена жизни, вы должны использовать параметры нескольких времён жизни:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> x_or_y&lt;<span class="ot">'a</span>, <span class="ot">'b</span>&gt;(x: &amp;<span class="ot">'a</span> <span class="kw">str</span>, y: &amp;<span class="ot">'b</span> <span class="kw">str</span>) -&gt; &amp;<span class="ot">'a</span> <span class="kw">str</span> {</code></pre>
  <p>В этом примере <code>x</code> и <code>y</code> имеют различные области видимости, но возвращаемое значение имеет то же время жизни, что и <code>x</code>.</p>
  </section>
  <section id="осмысливаем-области-видимости-thinking-in-scopes-1" class="level4">
  <h4>Осмысливаем области видимости (Thinking in scopes)</h4>
  <p>Один из способов понять, что же такое время жизни — это визуализировать область, в которой ссылка является действительной. Например:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> main() {
      <span class="kw">let</span> y = &amp;<span class="dv">5</span>;     <span class="co">// -+ y входит в область видимости</span>
                      <span class="co">//  |</span>
      <span class="co">// что-то       //  |</span>
                      <span class="co">//  |</span>
  }                   <span class="co">// -+ y выходит из области видимости</span></code></pre>
  <p>Добавим нашу структуру <code>Foo</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Foo&lt;<span class="ot">'a</span>&gt; {
      x: &amp;<span class="ot">'a</span> <span class="kw">i32</span>,
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> y = &amp;<span class="dv">5</span>;           <span class="co">// -+ y входит в область видимости</span>
      <span class="kw">let</span> f = Foo { x: y }; <span class="co">// -+ f входит в область видимости</span>
      <span class="co">// что-то             //  |</span>
                            <span class="co">//  |</span>
  }                         <span class="co">// -+ f и y выходят из области видимости</span></code></pre>
  <p>Наша <code>f</code> живет в области видимости <code>y</code>, поэтому все работает. Что же произойдёт, если это будет не так? Этот код не будет работать:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Foo&lt;<span class="ot">'a</span>&gt; {
      x: &amp;<span class="ot">'a</span> <span class="kw">i32</span>,
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> x;                    <span class="co">// -+ x входит в область видимости</span>
                                <span class="co">//  |</span>
      {                         <span class="co">//  |</span>
          <span class="kw">let</span> y = &amp;<span class="dv">5</span>;           <span class="co">// ---+ y входит в область видимости</span>
          <span class="kw">let</span> f = Foo { x: y }; <span class="co">// ---+ f входит в область видимости</span>
          x = &amp;f.x;             <span class="co">//  | | здесь ошибка</span>
      }                         <span class="co">// ---+ f и y выходят из области видимости</span>
                                <span class="co">//  |</span>
      <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, x);        <span class="co">//  |</span>
  }                             <span class="co">// -+ x выходит из области видимости</span></code></pre>
  <p>Уф! Как вы можете видеть здесь, области видимости <code>f</code> и <code>y</code> меньше, чем область видимости <code>x</code>. Но когда мы выполняем <code>x = &amp;f.x</code>, мы присваиваем <code>x</code> ссылку на что-то, что вот-вот выйдет из области видимости.</p>
  <p>Присвоение имени времени жизни — это способ задать имя области видимости. Чтобы думать о чём-то, нужно иметь название для этого.</p>
  </section>
  <section id="static" class="level4">
  <h4>’static</h4>
  <p>Время жизни с именем «static» — особенное. Оно обозначает, что что-то имеет время жизни, равное времени жизни всей программы. Большинство программистов на Rust впервые сталкиваются с <code>'static</code>, когда имеют дело со строками:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x: &amp;<span class="ot">'static</span> <span class="kw">str</span> = <span class="st">&quot;Привет, мир.&quot;</span>;</code></pre>
  <p>Строковые литералы имеют тип <code>&amp;'static str</code>, потому что ссылка всегда действительна: строки располагаются в сегменте данных конечного двоичного файла. Другой пример — глобальные переменные:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">static</span> FOO: <span class="kw">i32</span> = <span class="dv">5</span>;
  <span class="kw">let</span> x: &amp;<span class="ot">'static</span> <span class="kw">i32</span> = &amp;FOO;</code></pre>
  <p>В этом примере <code>i32</code> добавляется в сегмент данных двоичного файла, а <code>x</code> ссылается на него.</p>
  </section>
  <section id="опускание-времени-жизни" class="level4">
  <h4>Опускание времени жизни</h4>
  <p>В Rust есть мощный локальный вывод типов. Однако, сигнатуры объявлений верхнего уровня не выводятся, чтобы можно было рассуждать о типах на основании одних лишь сигнатур. Из соображений удобства, введён ограниченный механизм вывода типов сигнатур функций, называемый «опускание времени жизни» («lifetime elision»). Он выводит типы на основании только элементов сигнатуры — тело функции при этом не учитывается. При этом его назначение — это вывести лишь параметры времени жизни аргументов. Для этого он реализует три простых правила. Таким образом, опускание времени жизни упрощает написание сигнатур, одновременно не скрывая реальные типы аргументов.</p>
  <p>Когда речь идет о неявном времени жизни, мы используем термины <em>входное время жизни</em> (<em>input lifetime</em>) и <em>выходное время жизни</em> (<em>output lifetime</em>). <em>Входное время жизни</em> связано с передаваемыми в функцию параметрами, а <em>выходное время жизни</em> связано с возвращаемым функцией значением. Например, эта функция имеет входное время жизни:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo&lt;<span class="ot">'a</span>&gt;(bar: &amp;<span class="ot">'a</span> <span class="kw">str</span>)</code></pre>
  <p>А эта имеет выходное время жизни:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo&lt;<span class="ot">'a</span>&gt;() -&gt; &amp;<span class="ot">'a</span> <span class="kw">str</span></code></pre>
  <p>Эта же имеет как входное, так и выходное время жизни:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo&lt;<span class="ot">'a</span>&gt;(bar: &amp;<span class="ot">'a</span> <span class="kw">str</span>) -&gt; &amp;<span class="ot">'a</span> <span class="kw">str</span></code></pre>
  <p>Ниже представлены три правила:</p>
  <ul>
  <li><p>Каждое неявное время жизни в аргументах функции становится отдельным временем жизни.</p></li>
  <li><p>Если есть ровно одно входное время жизни, явное или неявное, то это время жизни назначается всем неявным выходным временам жизни.</p></li>
  <li><p>Если есть несколько входных времён жизни, но одно из них это <code>&amp;self</code> или <code>&amp;mut   self</code>, то всем неявным выходным временам жизни назначается время жизни <code>self</code>.</p></li>
  </ul>
  <p>В противном случае, неявное задание выходного времени жизни является ошибкой.</p>
  <section id="примеры" class="level5">
  <h5>Примеры</h5>
  <p>Вот некоторые примеры функций, представленные в двух видах: с явно и неявно заданным временем жизни:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> print(s: &amp;<span class="kw">str</span>); <span class="co">// неявно</span>
  <span class="kw">fn</span> print&lt;<span class="ot">'a</span>&gt;(s: &amp;<span class="ot">'a</span> <span class="kw">str</span>); <span class="co">// явно</span>
  
  <span class="kw">fn</span> debug(lvl: <span class="kw">u32</span>, s: &amp;<span class="kw">str</span>); <span class="co">// неявно</span>
  <span class="kw">fn</span> debug&lt;<span class="ot">'a</span>&gt;(lvl: <span class="kw">u32</span>, s: &amp;<span class="ot">'a</span> <span class="kw">str</span>); <span class="co">// явно</span>
  
  <span class="co">// В предыдущем примере для `lvl` не требуется указывать время жизни, потому что</span>
  <span class="co">// это не ссылка (`&amp;`). Только элементы, связанные с ссылками (например, такие</span>
  <span class="co">// как структура, содержащая ссылку) требуют указания времени жизни.</span>
  
  <span class="kw">fn</span> substr(s: &amp;<span class="kw">str</span>, until: <span class="kw">u32</span>) -&gt; &amp;<span class="kw">str</span>; <span class="co">// неявно</span>
  <span class="kw">fn</span> substr&lt;<span class="ot">'a</span>&gt;(s: &amp;<span class="ot">'a</span> <span class="kw">str</span>, until: <span class="kw">u32</span>) -&gt; &amp;<span class="ot">'a</span> <span class="kw">str</span>; <span class="co">// явно</span>
  
  <span class="kw">fn</span> get_str() -&gt; &amp;<span class="kw">str</span>; <span class="co">// НЕКОРРЕКТНО, нет входных параметров</span>
  
  <span class="kw">fn</span> frob(s: &amp;<span class="kw">str</span>, t: &amp;<span class="kw">str</span>) -&gt; &amp;<span class="kw">str</span>; <span class="co">// НЕКОРРЕКТНО, два входных параметра</span>
  <span class="kw">fn</span> frob&lt;<span class="ot">'a</span>, <span class="ot">'b</span>&gt;(s: &amp;<span class="ot">'a</span> <span class="kw">str</span>, t: &amp;<span class="ot">'b</span> <span class="kw">str</span>) -&gt; &amp;<span class="kw">str</span>; <span class="co">// Развёрнуто: Выходное время жизни н</span>
  ↳ <span class="dv">е</span>ясно
  
  <span class="kw">fn</span> get_mut(&amp;<span class="kw">mut</span> <span class="kw">self</span>) -&gt; &amp;<span class="kw">mut</span> T; <span class="co">// неявно</span>
  <span class="kw">fn</span> get_mut&lt;<span class="ot">'a</span>&gt;(&amp;<span class="ot">'a</span> <span class="kw">mut</span> <span class="kw">self</span>) -&gt; &amp;<span class="ot">'a</span> <span class="kw">mut</span> T; <span class="co">// явно</span>
  
  <span class="kw">fn</span> args&lt;T:ToCStr&gt;(&amp;<span class="kw">mut</span> <span class="kw">self</span>, args: &amp;[T]) -&gt; &amp;<span class="kw">mut</span> Command <span class="co">// неявно</span>
  <span class="kw">fn</span> args&lt;<span class="ot">'a</span>, <span class="ot">'b</span>, T:ToCStr&gt;(&amp;<span class="ot">'a</span> <span class="kw">mut</span> <span class="kw">self</span>, args: &amp;<span class="ot">'b</span> [T]) -&gt; &amp;<span class="ot">'a</span> <span class="kw">mut</span> Command <span class="co">// явно</span>
  
  <span class="kw">fn</span> new(buf: &amp;<span class="kw">mut</span> [<span class="kw">u8</span>]) -&gt; BufWriter; <span class="co">// неявно</span>
  <span class="kw">fn</span> new&lt;<span class="ot">'a</span>&gt;(buf: &amp;<span class="ot">'a</span> <span class="kw">mut</span> [<span class="kw">u8</span>]) -&gt; BufWriter&lt;<span class="ot">'a</span>&gt; <span class="co">// явно</span></code></pre>
  </section>
  </section>
  </section>
  </section>
  <section id="sec--mutability" class="level2">
  <h2>Изменяемость (mutability)</h2>
  <p>Изменяемость, то есть возможность изменить что-то, работает в Rust несколько иначе, чем в других языках. Во-первых, по умолчанию связанные имена не изменяемы:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">5</span>;
  x = <span class="dv">6</span>; <span class="co">// ошибка!</span></code></pre>
  <p>Изменяемость можно добавить с помощью ключевого слова <code>mut</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> x = <span class="dv">5</span>;
  
  x = <span class="dv">6</span>; <span class="co">// нет проблем!</span></code></pre>
  <p>Это изменяемое <a href="#sec--variable-bindings">связанное имя</a>. Когда связанное имя изменяемо, это означает, что мы можем поменять связанное с ним значение. В примере выше не то, чтобы само значение <code>x</code> менялось, просто имя <code>x</code> связывается с другим значением типа <code>i32</code>.</p>
  <p>Если же вы хотите изменить само связанное значение, вам понадобится <a href="#sec--references-and-borrowing">изменяемая ссылка</a>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> x = <span class="dv">5</span>;
  <span class="kw">let</span> y = &amp;<span class="kw">mut</span> x;</code></pre>
  <p><code>y</code> — это неизменяемое имя для изменяемой ссылки. Это значит, что <code>y</code> нельзя связать ещё с чем-то (<code>y = &amp;mut z</code>), но можно изменить то, на что указывает связанная ссылка (<code>*y = 5</code>). Тонкая разница.</p>
  <p>Конечно, вы можете объявить и изменяемое имя для изменяемой ссылки:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> x = <span class="dv">5</span>;
  <span class="kw">let</span> <span class="kw">mut</span> y = &amp;<span class="kw">mut</span> x;</code></pre>
  <p>Теперь <code>y</code> можно связать с другим значением, и само это значение тоже можно менять.</p>
  <p>Стоит отметить, что <code>mut</code> — это часть <a href="#sec--patterns">шаблона</a>, поэтому можно делать такие вещи:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> (<span class="kw">mut</span> x, y) = (<span class="dv">5</span>, <span class="dv">6</span>);
  
  <span class="kw">fn</span> foo(<span class="kw">mut</span> x: <span class="kw">i32</span>) {</code></pre>
  <section id="внутренняя-interior-и-внешняя-exterior-изменяемость" class="level3">
  <h3>Внутренняя (interior) и внешняя (exterior) изменяемость</h3>
  <p>Однако, когда мы говорим, что что-либо «неизменяемо» в Rust, это не означает, что оно совсем не может измениться. Мы говорим о «внешней изменяемости». Для примера рассмотрим <a href="http://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc&lt;T&gt;</code></a>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::sync::Arc;
  
  <span class="kw">let</span> x = Arc::new(<span class="dv">5</span>);
  <span class="kw">let</span> y = x.clone();</code></pre>
  <p>Когда мы вызываем метод <code>clone()</code>, <code>Arc&lt;T&gt;</code> должна обновить счётчик ссылок. Мы не использовали модификатор <code>mut</code>, а значит <code>x</code> — неизменяемое имя. Мы не можем получить ссылку (<code>&amp;mut 5</code>) или сделать что-то подобное. И что же?</p>
  <p>Для того чтобы понять это, мы должны вернуться назад к основам философии Rust, к сохранности памяти и механизму, гарантирующему это, к системе <a href="#sec--ownership">владения</a>, и, в частности, к <a href="#borrowing">заимствованию</a>:</p>
  <blockquote>
  <p>Одновременно у вас может быть только один из двух перечисленных ниже видов заимствования, но не оба сразу:</p>
  <ul>
  <li>одна или более неизменяемых ссылок (<code>&amp;T</code>) на ресурс,</li>
  <li>ровно одна изменяемая ссылка (<code>&amp;mut T</code>) на ресурс.</li>
  </ul>
  </blockquote>
  <p>Итак, что же здесь на самом деле является «неизменяемым»? Безопасно ли иметь два указателя на один объект? В случае с <code>Arc&lt;T&gt;</code>, да: изменяемый объект полностью находится внутри самой структуры. По этой причине, метод <code>clone()</code> возвращает неизменяемую ссылку (<code>&amp;T</code>). Если бы он возвращал изменяемую ссылку (<code>&amp;mut T</code>), то у нас были бы проблемы. Таким образом, <code>let mut z = Arc::new(5);</code> объявляет атомарный счётчик ссылок с внешней изменяемостью.</p>
  <p>Другие типы, например те, что определены в модуле <a href="http://doc.rust-lang.org/std/cell/index.html"><code>std::cell</code></a>, напротив, имеют «внутреннюю изменяемость». Например:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::cell::RefCell;
  
  <span class="kw">let</span> x = RefCell::new(<span class="dv">42</span>);
  
  <span class="kw">let</span> y = x.borrow_mut();</code></pre>
  <p>RefCell возвращает изменяемую ссылку <code>&amp;mut</code> при помощи метода <code>borrow_mut()</code>. А не опасно ли это? Что, если мы сделаем так:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::cell::RefCell;
  
  <span class="kw">let</span> x = RefCell::new(<span class="dv">42</span>);
  
  <span class="kw">let</span> y = x.borrow_mut();
  <span class="kw">let</span> z = x.borrow_mut();</code></pre>
  <p>Это приведёт к панике во время исполнения. Вот что делает <code>RefCell</code>: он принудительно выполняет проверку правил заимствования во время исполнения и вызывает <code>panic!</code>, если они были нарушены.</p>
  <p>Стоит отметить, что тип изменяемости — внутренняя или внешняя — определяется самим типом. Нет способа волшебно превратить значение с внутренней изменяемостью в значение со внешней, и наоборот.</p>
  <p>Всё это подводит нас к другим аспектам правил изменяемости Rust. Давайте поговорим о них.</p>
  <section id="изменяемость-на-уровне-полей" class="level4">
  <h4>Изменяемость на уровне полей</h4>
  <p>Изменяемость — это свойство либо ссылки (<code>&amp;mut</code>), либо имени (<code>let mut</code>). Это значит, что, например, у вас не может быть <a href="#sec--structs">структуры</a>, часть полей которой изменяется, а другая часть — нет:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Point {
      x: <span class="kw">i32</span>,
      <span class="kw">mut</span> y: <span class="kw">i32</span>, <span class="co">// нельзя</span>
  }</code></pre>
  <p>Изменяемость структуры определяется при её связывании:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Point {
      x: <span class="kw">i32</span>,
      y: <span class="kw">i32</span>,
  }
  
  <span class="kw">let</span> <span class="kw">mut</span> a = Point { x: <span class="dv">5</span>, y: <span class="dv">6</span> };
  
  a.x = <span class="dv">10</span>;
  
  <span class="kw">let</span> b = Point { x: <span class="dv">5</span>, y: <span class="dv">6</span>};
  
  b.x = <span class="dv">10</span>; <span class="co">// error: cannot assign to immutable field `b.x`</span></code></pre>
  <p>Однако, используя <a href="http://doc.rust-lang.org/std/cell/struct.Cell.html"><code>Cell&lt;T&gt;</code></a>, вы можете эмулировать изменяемость на уровне полей:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::cell::Cell;
  
  <span class="kw">struct</span> Point {
      x: <span class="kw">i32</span>,
      y: Cell&lt;<span class="kw">i32</span>&gt;,
  }
  
  <span class="kw">let</span> point = Point { x: <span class="dv">5</span>, y: Cell::new(<span class="dv">6</span>) };
  
  point.y.set(<span class="dv">7</span>);
  
  <span class="ot">println!</span>(<span class="st">&quot;y: {:?}&quot;</span>, point.y);</code></pre>
  <p>Это выведет на экран <code>y: Cell { value: 7 }</code>. Мы успешно изменили значение <code>y</code>.</p>
  </section>
  </section>
  </section>
  <section id="sec--structs" class="level2">
  <h2>Структуры</h2>
  <p>Структуры (<code>struct</code>) — это один из способов создания более сложных типов данных. Например, если мы рассчитываем что-то с использованием координат 2D пространства, то нам понадобятся оба значения — <code>x</code> и <code>y</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> origin_x = <span class="dv">0</span>;
  <span class="kw">let</span> origin_y = <span class="dv">0</span>;</code></pre>
  <p>Структура позволяет нам объединить эти два значения в один тип с <code>x</code> и <code>y</code> в качестве имен полей:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Point {
      x: <span class="kw">i32</span>,
      y: <span class="kw">i32</span>,
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> origin = Point { x: <span class="dv">0</span>, y: <span class="dv">0</span> }; <span class="co">// origin: Point</span>
  
      <span class="ot">println!</span>(<span class="st">&quot;Начало координат находится в ({}, {})&quot;</span>, origin.x, origin.y);
  }</code></pre>
  <p>Этот код делает много разных вещей, поэтому давайте разберём его по порядку. Мы объявляем структуру с помощью ключевого слова <code>struct</code>, за которым следует имя объявляемой структуры. Обычно, имена типов-структур начинаются с заглавной буквы и используют чередующийся регистр букв: название <code>PointInSpace</code> выглядит привычно, а <code>Point_In_Space</code> — нет.</p>
  <p>Как всегда, мы можем создать экземпляр нашей структуры с помощью оператора <code>let</code>. Однако в данном случае мы используем синтаксис вида <code>ключ: значение</code> для установки значения каждого поля. Порядок инициализации полей не обязательно должен совпадать с порядком их объявления.</p>
  <p>Наконец, поскольку у полей есть имена, мы можем получить к ним доступ с помощью операции <code>точка</code>: <code>origin.x</code>.</p>
  <p>Значения, хранимые в структурах, неизменяемы по умолчанию. В этом плане они не отличаются от других именованных сущностей. Чтобы они стали изменяемы, используйте ключевое слово <code>mut</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Point {
      x: <span class="kw">i32</span>,
      y: <span class="kw">i32</span>,
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> <span class="kw">mut</span> point = Point { x: <span class="dv">0</span>, y: <span class="dv">0</span> };
  
      point.x = <span class="dv">5</span>;
  
      <span class="ot">println!</span>(<span class="st">&quot;Точка находится в ({}, {})&quot;</span>, point.x, point.y);
  }</code></pre>
  <p>Этот код напечатает <code>Точка находится в (5, 0)</code>.</p>
  <p>Rust не поддерживает изменяемость отдельных полей, поэтому вы не можете написать что-то вроде такого:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Point {
      <span class="kw">mut</span> x: <span class="kw">i32</span>,
      y: <span class="kw">i32</span>,
  }</code></pre>
  <p>Изменяемость — это свойство имени, а не самой структуры. Если вы привыкли к управлению изменяемостью на уровне полей, сначала это может показаться непривычным, но на самом деле такое решение сильно упрощает вещи. Оно даже позволяет вам делать имена изменяемыми только на короткое время:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Point {
      x: <span class="kw">i32</span>,
      y: <span class="kw">i32</span>,
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> <span class="kw">mut</span> point = Point { x: <span class="dv">0</span>, y: <span class="dv">0</span> };
  
      point.x = <span class="dv">5</span>;
  
      <span class="kw">let</span> point = point; <span class="co">// это новое имя неизменяемо</span>
  
      point.y = <span class="dv">6</span>; <span class="co">// это вызывает ошибку</span>
  }</code></pre>
  <p>Структуры так же могут содержать <code>&amp;mut</code> ссылки, это позволяет вам производить подобные преобразования:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Point {
      x: <span class="kw">i32</span>,
      y: <span class="kw">i32</span>,
  }
  
  <span class="kw">struct</span> PointRef&lt;<span class="ot">'a</span>&gt; {
      x: &amp;<span class="ot">'a</span> <span class="kw">mut</span> <span class="kw">i32</span>,
      y: &amp;<span class="ot">'a</span> <span class="kw">mut</span> <span class="kw">i32</span>,
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> <span class="kw">mut</span> point = Point { x: <span class="dv">0</span>, y: <span class="dv">0</span> };
  
      {
          <span class="kw">let</span> r = PointRef { x: &amp;<span class="kw">mut</span> point.x, y: &amp;<span class="kw">mut</span> point.y };
  
          *r.x = <span class="dv">5</span>;
          *r.y = <span class="dv">6</span>;
      }
  
      <span class="ot">assert_eq!</span>(<span class="dv">5</span>, point.x);
      <span class="ot">assert_eq!</span>(<span class="dv">6</span>, point.y);
  }</code></pre>
  <section id="синтаксис-обновления-update-syntax" class="level3">
  <h3>Синтаксис обновления (update syntax)</h3>
  <p>Вы можете включить в описание структуры <code>..</code> чтобы показать, что вы хотите использовать значения полей какой-то другой структуры. Например:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Point3d {
      x: <span class="kw">i32</span>,
      y: <span class="kw">i32</span>,
      z: <span class="kw">i32</span>,
  }
  
  <span class="kw">let</span> <span class="kw">mut</span> point = Point3d { x: <span class="dv">0</span>, y: <span class="dv">0</span>, z: <span class="dv">0</span> };
  point = Point3d { y: <span class="dv">1</span>, .. point };</code></pre>
  <p>Этот код присваивает <code>point</code> новое <code>y</code>, но оставляет старые <code>x</code> и <code>z</code>. Это не обязательно должна быть та же самая структура — вы можете использовать этот синтаксис когда создаёте новые структуры, чтобы скопировать значения неуказанных полей:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> origin = Point3d { x: <span class="dv">0</span>, y: <span class="dv">0</span>, z: <span class="dv">0</span> };
  <span class="kw">let</span> point = Point3d { z: <span class="dv">1</span>, x: <span class="dv">2</span>, .. origin };</code></pre>
  </section>
  <section id="кортежные-структуры" class="level3">
  <h3>Кортежные структуры</h3>
  <p>В Rust есть ещё один тип данных, который представляет собой нечто среднее между <a href="#tuples">кортежем</a> и структурой. Он называется <em>кортежной структурой</em>. Кортежные структуры именуются, а вот у их полей имён нет:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Color(<span class="kw">i32</span>, <span class="kw">i32</span>, <span class="kw">i32</span>);
  <span class="kw">struct</span> Point(<span class="kw">i32</span>, <span class="kw">i32</span>, <span class="kw">i32</span>);
  
  <span class="kw">let</span> black = Color(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>);
  <span class="kw">let</span> origin = Point(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>);</code></pre>
  <p>Эти два объекта различны, несмотря на то, что у них одинаковые значения.</p>
  <p>Почти всегда, вместо кортежной структуры лучше использовать обычную структуру. Мы бы скорее объявили типы <code>Color</code> и <code>Point</code> вот так:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Color {
      red: <span class="kw">i32</span>,
      blue: <span class="kw">i32</span>,
      green: <span class="kw">i32</span>,
  }
  
  <span class="kw">struct</span> Point {
      x: <span class="kw">i32</span>,
      y: <span class="kw">i32</span>,
      z: <span class="kw">i32</span>,
  }</code></pre>
  <p>Хорошие имена важны, и хотя значения в кортежной структуре могут быть так же получены с помощью операции <code>точка</code>, структуры дают нам настоящее имя, а не позицию.</p>
  <p>Однако, <em>есть</em> один случай, когда кортежные структуры очень полезны. Это кортежная структура с всего одним элементом. Такое использование называется <em>новым типом</em>, потому что оно позволяет создать новый тип, отличный от типа значения, содержащегося в кортежной структуре. При этом новый тип обозначает что-то другое:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Inches(<span class="kw">i32</span>);
  
  <span class="kw">let</span> length = Inches(<span class="dv">10</span>);
  
  <span class="kw">let</span> Inches(integer_length) = length;
  <span class="ot">println!</span>(<span class="st">&quot;Длина в дюймах: {}&quot;</span>, integer_length);</code></pre>
  <p>Как вы можете видеть в данном примере, извлечь вложенный целый тип можно с помощью деконструирующего <code>let</code>. Мы обсуждали это выше, в разделе «кортежи». В данном случае, оператор <code>let Inches(integer_length)</code> присваивает <code>10</code> имени <code>integer_length</code>.</p>
  </section>
  <section id="unit-подобные-структуры" class="level3">
  <h3>Unit-подобные структуры</h3>
  <p>Вы можете объявить структуру без полей вообще:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Electron;
  
  <span class="kw">let</span> x = Electron;</code></pre>
  <p>Такие структуры называют «unit-подобные» («unit-like»), потому что они похожи на пустой кортеж <code>()</code>, иногда называемый «unit». Как и кортежные структуры, их называют новым типом.</p>
  <p>Сами по себе они редко бывают полезны (хотя иногда их используют в качестве меток), но в сочетании с другими возможностями их использование имеет смысл. Например, для использования библиотеки может быть необходимо создать структуру, которая реализует определенный <a href="#sec--traits">типаж</a> для обработки событий. Если у вас нет данных, которые нужно поместить в структуру, то можно просто создать unit-подобную структуру.</p>
  </section>
  </section>
  <section id="sec--enums" class="level2">
  <h2>Перечисления</h2>
  <p>В Rust <em>перечисление</em> (<code>enum</code>) — это тип данных, который представляет собой один из нескольких возможных вариантов. Каждый вариант в перечислении может быть также связан с другими данными:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">enum</span> Message {
      Quit,
      ChangeColor(<span class="kw">i32</span>, <span class="kw">i32</span>, <span class="kw">i32</span>),
      Move { x: <span class="kw">i32</span>, y: <span class="kw">i32</span> },
      Write(String),
  }</code></pre>
  <p>Синтаксис для объявления вариантов схож с синтаксисом для объявления структур: у вас могут быть варианты без данных (как unit-подобные структуры), варианты с именованными данными и варианты с безымянными данными (подобно кортежным структурам). Варианты перечисления имеют один и тот же тип, и в отличии от структур не являются определением отдельных типов. Значение перечисления может соответствовать любому из вариантов. Из-за этого перечисления иногда называют <em>тип-сумма</em> (<em>sum-type</em>): множество возможных значений перечисления — это сумма множеств возможных значений каждого варианта.</p>
  <p>Мы используем синтаксис <code>::</code> чтобы использовать имя каждого из вариантов. Их область видимости ограничена именем самого перечисления. Это позволяет использовать оба варианта из примера ниже совместно:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x: Message = Message::Move { x: <span class="dv">3</span>, y: <span class="dv">4</span> };
  
  <span class="kw">enum</span> BoardGameTurn {
      Move { squares: <span class="kw">i32</span> },
      Pass,
  }
  
  <span class="kw">let</span> y: BoardGameTurn = BoardGameTurn::Move { squares: <span class="dv">1</span> };</code></pre>
  <p>Оба варианта имеют одинаковое имя <code>Move</code>, но поскольку область видимости каждого из них ограничена именем соответствующего перечисления, они могут быть использованы без конфликтов.</p>
  <p>Значение перечисления, в дополнение к любым данным, которые связаны с ним, содержит информацию о том, какой именно это вариант. Это иногда называют <em>размеченное объединение</em> (<em>tagged union</em>), поскольку данные включают в себя метку, обозначающую что это за тип.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> process_color_change(msg: Message) {
      <span class="kw">let</span> Message::ChangeColor(r, g, b) = msg; <span class="co">// ошибка времени компиляции</span>
  }</code></pre>
  <p>То, что пользовательские типы по умолчанию не поддерживают операции, может показаться довольно ограниченным. Но это ограничение, которое мы всегда можем преодолеть. Есть два способа: реализовать операцию самостоятельно, или воспользоваться сопоставлением с образцом с помощью <a href="#sec--match"><code>match</code></a>, о котором вы узнаете в следующем разделе. Пока мы еще недостаточно знаем Rust, чтобы реализовывать операции, но мы научимся делать это в разделе <a href="#sec--traits"><code>traits</code></a>.</p>
  <section id="конструкторы-как-функции" class="level3">
  <h3>Конструкторы как функции</h3>
  <p>Конструктор перечисления может быть также использован как обычная функция. Например:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> m = Message::Write(<span class="st">&quot;Hello, world&quot;</span>.to_string());</code></pre>
  <p>тоже самое, что и</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo(x: String) -&gt; Message {
      Message::Write(x)
  }
  
  <span class="kw">let</span> x = foo(<span class="st">&quot;Hello, world&quot;</span>.to_string());</code></pre>
  <p>На данный момент это не так уж и полезно для нас, но когда мы перейдем к <a href="#sec--closures">замыканиям</a>, мы поговорим о передаче функций в роли аргумента другой функции. Например, с помощью <a href="#sec--iterators">итераторов</a> мы можем преобразовывать вектор строк в вектор состоящий из <code>Message::Write</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">
  <span class="kw">let</span> v = <span class="ot">vec!</span>[<span class="st">&quot;Hello&quot;</span>.to_string(), <span class="st">&quot;World&quot;</span>.to_string()];
  
  <span class="kw">let</span> v1: Vec&lt;Message&gt; = v.into_iter().map(Message::Write).collect();</code></pre>
  </section>
  </section>
  <section id="sec--match" class="level2">
  <h2>Конструкция <code>match</code></h2>
  <p>Простого <code>if</code>/<code>else</code> часто недостаточно, потому что нужно проверить больше, чем два возможных варианта. Да и к тому же условия в <code>else</code> часто становятся очень сложными. Как же решить эту проблему?</p>
  <p>В Rust есть ключевое слово <code>match</code>, позволяющее заменить группы операторов <code>if</code>/<code>else</code> чем-то более удобным. Смотрите:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">5</span>;
  
  <span class="kw">match</span> x {
      <span class="dv">1</span> =&gt; <span class="ot">println!</span>(<span class="st">&quot;один&quot;</span>),
      <span class="dv">2</span> =&gt; <span class="ot">println!</span>(<span class="st">&quot;два&quot;</span>),
      <span class="dv">3</span> =&gt; <span class="ot">println!</span>(<span class="st">&quot;три&quot;</span>),
      <span class="dv">4</span> =&gt; <span class="ot">println!</span>(<span class="st">&quot;четыре&quot;</span>),
      <span class="dv">5</span> =&gt; <span class="ot">println!</span>(<span class="st">&quot;пять&quot;</span>),
      _ =&gt; <span class="ot">println!</span>(<span class="st">&quot;что-то ещё&quot;</span>),
  }</code></pre>
  <p><code>match</code> принимает выражение и выбирает одну из ветвей исполнения согласно его значению. Каждая <em>ветвь</em> имеет форму <code>значение =&gt; выражение</code>. Выражение ветви вычисляется, когда значение данной ветви совпадает со значением, принятым оператором <code>match</code> (в данном случае, <code>x</code>). Эта конструкция называется <code>match</code> (сопоставление), потому что она выполняет сопоставление значения неким «шаблонам». Глава «<a href="#sec--patterns">Шаблоны</a>» описывает все шаблоны, которые можно использовать в <code>match</code>.</p>
  <p>Так в чём же преимущества данной конструкции? Их несколько. Во-первых, ветви <code>match</code> <em>проверяются на полноту</em>. Видите последнюю ветвь, со знаком подчёркивания (<code>_</code>)? Если мы удалим её, Rust выдаст ошибку:</p>
  <pre class="text"><code>error: non-exhaustive patterns: `_` not covered</code></pre>
  <p>Другими словами, компилятор сообщает нам, что мы забыли сопоставить какие-то значения. Поскольку <code>x</code> — это целое число, оно может принимать разные значения — например, <code>6</code>. Однако, если мы убираем ветвь <code>_</code>, ни одна ветвь не совпадёт, поэтому такой код не скомпилируется. <code>_</code> — это «совпадение с любым значением». Если ни одна другая ветвь не совпала, совпадёт ветвь с <code>_</code>. Поскольку в примере выше есть ветвь с <code>_</code>, мы покрываем всё множество значений <code>x</code>, и наша программа скомпилируется.</p>
  <p><code>match</code> также является выражением. Это значит, что мы можем использовать его в правой части оператора <code>let</code> или непосредственно как выражение:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">5</span>;
  
  <span class="kw">let</span> numer = <span class="kw">match</span> x {
      <span class="dv">1</span> =&gt; <span class="st">&quot;one&quot;</span>,
      <span class="dv">2</span> =&gt; <span class="st">&quot;two&quot;</span>,
      <span class="dv">3</span> =&gt; <span class="st">&quot;three&quot;</span>,
      <span class="dv">4</span> =&gt; <span class="st">&quot;four&quot;</span>,
      <span class="dv">5</span> =&gt; <span class="st">&quot;five&quot;</span>,
      _ =&gt; <span class="st">&quot;something else&quot;</span>,
  };</code></pre>
  <p>Иногда с помощью <code>match</code> можно удобно преобразовать значения одного типа в другой.</p>
  <section id="сопоставление-с-образцом-для-перечислений" class="level3">
  <h3>Сопоставление с образцом для перечислений</h3>
  <p>Другой полезный способ использования <code>match</code> — обработка возможных вариантов перечисления:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">enum</span> Message {
      Quit,
      ChangeColor(<span class="kw">i32</span>, <span class="kw">i32</span>, <span class="kw">i32</span>),
      Move { x: <span class="kw">i32</span>, y: <span class="kw">i32</span> },
      Write(String),
  }
  
  <span class="kw">fn</span> quit() { <span class="co">/* ... */</span> }
  <span class="kw">fn</span> change_color(r: <span class="kw">i32</span>, g: <span class="kw">i32</span>, b: <span class="kw">i32</span>) { <span class="co">/* ... */</span> }
  <span class="kw">fn</span> move_cursor(x: <span class="kw">i32</span>, y: <span class="kw">i32</span>) { <span class="co">/* ... */</span> }
  
  <span class="kw">fn</span> process_message(msg: Message) {
      <span class="kw">match</span> msg {
          Message::Quit =&gt; quit(),
          Message::ChangeColor(r, g, b) =&gt; change_color(r, g, b),
          Message::Move { x: x, y: y } =&gt; move_cursor(x, y),
          Message::Write(s) =&gt; <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, s),
      };
  }</code></pre>
  <p>Как обычно, компилятор Rust проверяет полноту, поэтому в <code>match</code> должна быть ветвь для каждого варианта перечисления. Если какой-то вариант отсутствует, программа не скомпилируется и вам придётся использовать <code>_</code>.</p>
  <p>Здесь мы не можем использовать обычный <code>if</code> вместо <code>match</code>, в отличие от кода, который мы видели раньше. Но мы могли бы использовать <a href="#sec--if-let"><code>if let</code></a> — его можно воспринимать как сокращённую форму записи <code>match</code>.</p>
  </section>
  </section>
  <section id="sec--patterns" class="level2">
  <h2>Шаблоны сопоставления <code>match</code></h2>
  <p>Шаблоны достаточно часто используются в Rust. Мы уже использовали их в разделе <a href="#sec--variable-bindings">Связывание переменных</a>, в разделе <a href="#sec--match">Конструкция <code>match</code></a>, а также в некоторых других местах. Давайте коротко пробежимся по всем возможностям, которые можно реализовать с помощью шаблонов!</p>
  <p>Быстро освежим в памяти: сопоставлять с шаблоном литералы можно либо напрямую, либо с использованием символа <code>_</code>, который означает <em>любой</em> случай:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">1</span>;
  
  <span class="kw">match</span> x {
      <span class="dv">1</span> =&gt; <span class="ot">println!</span>(<span class="st">&quot;один&quot;</span>),
      <span class="dv">2</span> =&gt; <span class="ot">println!</span>(<span class="st">&quot;два&quot;</span>),
      <span class="dv">3</span> =&gt; <span class="ot">println!</span>(<span class="st">&quot;три&quot;</span>),
      _ =&gt; <span class="ot">println!</span>(<span class="st">&quot;что угодно&quot;</span>),
  }</code></pre>
  <p>Этот код напечатает <code>один</code>.</p>
  <section id="сопоставление-с-несколькими-шаблонами" class="level3">
  <h3>Сопоставление с несколькими шаблонами</h3>
  <p>Вы можете сопоставлять с несколькими шаблонами, используя <code>|</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">1</span>;
  
  <span class="kw">match</span> x {
      <span class="dv">1</span> | <span class="dv">2</span> =&gt; <span class="ot">println!</span>(<span class="st">&quot;один или два&quot;</span>),
      <span class="dv">3</span> =&gt; <span class="ot">println!</span>(<span class="st">&quot;три&quot;</span>),
      _ =&gt; <span class="ot">println!</span>(<span class="st">&quot;что угодно&quot;</span>),
  }</code></pre>
  <p>Этот код напечатает <code>один или два</code>.</p>
  </section>
  <section id="деструктуризация" class="level3">
  <h3>Деструктуризация</h3>
  <p>Если вы работаете с составным типом данных, вроде <a href="#sec--structs"><code>struct</code></a>, вы можете разобрать его на части («деструктурировать») внутри шаблона:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Point {
      x: <span class="kw">i32</span>,
      y: <span class="kw">i32</span>,
  }
  
  <span class="kw">let</span> origin = Point { x: <span class="dv">0</span>, y: <span class="dv">0</span> };
  
  <span class="kw">match</span> origin {
      Point { x, y } =&gt; <span class="ot">println!</span>(<span class="st">&quot;({},{})&quot;</span>, x, y),
  }</code></pre>
  <p>Мы можем использовать <code>:</code>, чтобы привязать значение к новому имени.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Point {
      x: <span class="kw">i32</span>,
      y: <span class="kw">i32</span>,
  }
  
  <span class="kw">let</span> origin = Point { x: <span class="dv">0</span>, y: <span class="dv">0</span> };
  
  <span class="kw">match</span> origin {
      Point { x: x1, y: y1 } =&gt; <span class="ot">println!</span>(<span class="st">&quot;({},{})&quot;</span>, x1, y1),
  }</code></pre>
  <p>Если нас интересуют только некоторые значения, мы можем не давать имена всем составляющим:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Point {
      x: <span class="kw">i32</span>,
      y: <span class="kw">i32</span>,
  }
  
  <span class="kw">let</span> origin = Point { x: <span class="dv">0</span>, y: <span class="dv">0</span> };
  
  <span class="kw">match</span> origin {
      Point { x, .. } =&gt; <span class="ot">println!</span>(<span class="st">&quot;x равен {}&quot;</span>, x),
  }</code></pre>
  <p>Этот код напечатает <code>x равен 0</code>.</p>
  <p>Вы можете использовать это в любом сопоставлении: не обязательно игнорировать именно первый элемент:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Point {
      x: <span class="kw">i32</span>,
      y: <span class="kw">i32</span>,
  }
  
  <span class="kw">let</span> origin = Point { x: <span class="dv">0</span>, y: <span class="dv">0</span> };
  
  <span class="kw">match</span> origin {
      Point { y, .. } =&gt; <span class="ot">println!</span>(<span class="st">&quot;y равен {}&quot;</span>, y),
  }</code></pre>
  <p>Этот код напечатает <code>y равен 0</code>.</p>
  <p>Можно произвести деструктуризацию любого составного типа данных — например, <a href="#tuples">кортежей</a> и <a href="#sec--enums">перечислений</a>.</p>
  </section>
  <section id="игнорирование-связывания" class="level3">
  <h3>Игнорирование связывания</h3>
  <p>Вы можете использовать в шаблоне <code>_</code>, чтобы проигнорировать соответствующее значение. Например, вот сопоставление <code>Result&lt;T, E&gt;</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">match</span> some_value {
      <span class="kw">Ok</span>(value) =&gt; <span class="ot">println!</span>(<span class="st">&quot;получили значение: {}&quot;</span>, value),
      <span class="kw">Err</span>(_) =&gt; <span class="ot">println!</span>(<span class="st">&quot;произошла ошибка&quot;</span>),
  }</code></pre>
  <p>В первой ветви мы привязываем значение варианта <code>Ok</code> к имени <code>value</code>. А в ветви обработки варианта <code>Err</code> мы используем <code>_</code>, чтобы проигнорировать конкретную ошибку, и просто печатаем общее сообщение.</p>
  <p><code>_</code> допустим в любом шаблоне, который связывает имена. Это можно использовать, чтобы проигнорировать части большой структуры:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> coordinate() -&gt; (<span class="kw">i32</span>, <span class="kw">i32</span>, <span class="kw">i32</span>) {
      <span class="co">// создаём и возвращаем какой-то кортеж из трёх элементов</span>
  }
  
  <span class="kw">let</span> (x, _, z) = coordinate();</code></pre>
  <p>Здесь мы связываем первый и последний элемент кортежа с именами <code>x</code> и <code>z</code> соответственно, а второй элемент игнорируем.</p>
  <p>Похожим образом, в шаблоне можно использовать <code>..</code>, чтобы проигнорировать несколько значений.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">enum</span> OptionalTuple {
      Value(<span class="kw">i32</span>, <span class="kw">i32</span>, <span class="kw">i32</span>),
      Missing,
  }
  
  <span class="kw">let</span> x = OptionalTuple::Value(<span class="dv">5</span>, -<span class="dv">2</span>, <span class="dv">3</span>);
  
  <span class="kw">match</span> x {
      OptionalTuple::Value(..) =&gt; <span class="ot">println!</span>(<span class="st">&quot;Получили кортеж!&quot;</span>),
      OptionalTuple::Missing =&gt; <span class="ot">println!</span>(<span class="st">&quot;Вот неудача.&quot;</span>),
  }</code></pre>
  <p>Этот код печатает <code>Получили кортеж!</code>.</p>
  </section>
  <section id="ref-и-ref-mut" class="level3">
  <h3>ref и ref mut</h3>
  <p>Если вы хотите получить <a href="#sec--references-and-borrowing">ссылку</a>, то используйте ключевое слово <code>ref</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">5</span>;
  
  <span class="kw">match</span> x {
      <span class="kw">ref</span> r =&gt; <span class="ot">println!</span>(<span class="st">&quot;Получили ссылку на {}&quot;</span>, r),
  }</code></pre>
  <p>Этот код напечатает <code>Получили ссылку на 5</code>.</p>
  <p>Здесь <code>r</code> внутри <code>match</code> имеет тип <code>&amp;i32</code>. Другими словами, ключевое слово <code>ref</code> <em>создает</em> ссылку, для использования в шаблоне. Если вам нужна изменяемая ссылка, то <code>ref mut</code> будет работать аналогичным образом:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> x = <span class="dv">5</span>;
  
  <span class="kw">match</span> x {
      <span class="kw">ref</span> <span class="kw">mut</span> mr =&gt; <span class="ot">println!</span>(<span class="st">&quot;Получили изменяемую ссылку на {}&quot;</span>, mr),
  }</code></pre>
  </section>
  <section id="сопоставление-с-диапазоном" class="level3">
  <h3>Сопоставление с диапазоном</h3>
  <p>Вы можете сопоставлять с диапазоном значений, используя <code>...</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">1</span>;
  
  <span class="kw">match</span> x {
      <span class="dv">1</span> ... <span class="dv">5</span> =&gt; <span class="ot">println!</span>(<span class="st">&quot;от одного до пяти&quot;</span>),
      _ =&gt; <span class="ot">println!</span>(<span class="st">&quot;что угодно&quot;</span>),
  }</code></pre>
  <p>Этот код напечатает <code>от одного до пяти</code>.</p>
  <p>Диапазоны в основном используются с числами или одиночными символами (<code>char</code>).</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="ch">'💅'</span>;
  
  <span class="kw">match</span> x {
      <span class="ch">'а'</span> ... <span class="ch">'и'</span> =&gt; <span class="ot">println!</span>(<span class="st">&quot;ранняя буква&quot;</span>),
      <span class="ch">'к'</span> ... <span class="ch">'я'</span> =&gt; <span class="ot">println!</span>(<span class="st">&quot;поздняя буква&quot;</span>),
      _ =&gt; <span class="ot">println!</span>(<span class="st">&quot;что-то ещё&quot;</span>),
  }</code></pre>
  <p>Этот код напечатает <code>что-то ещё</code>.</p>
  </section>
  <section id="связывание" class="level3">
  <h3>Связывание</h3>
  <p>Вы можете связать значение с именем с помощью символа <code>@</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">1</span>;
  
  <span class="kw">match</span> x {
      e @ <span class="dv">1</span> ... <span class="dv">5</span> =&gt; <span class="ot">println!</span>(<span class="st">&quot;получили элемент диапазона {}&quot;</span>, e),
      _ =&gt; <span class="ot">println!</span>(<span class="st">&quot;что угодно&quot;</span>),
  }</code></pre>
  <p>Этот код напечатает <code>получили элемент диапазона 1</code>. Это полезно, когда вы хотите сделать сложное сопоставление для части структуры данных:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="ot">#[</span>derive<span class="ot">(</span>Debug<span class="ot">)]</span>
  <span class="kw">struct</span> Person {
      name: <span class="kw">Option</span>&lt;String&gt;,
  }
  
  <span class="kw">let</span> name = <span class="st">&quot;Steve&quot;</span>.to_string();
  <span class="kw">let</span> <span class="kw">mut</span> x: <span class="kw">Option</span>&lt;Person&gt; = <span class="kw">Some</span>(Person { name: <span class="kw">Some</span>(name) });
  <span class="kw">match</span> x {
      <span class="kw">Some</span>(Person { name: <span class="kw">ref</span> a @ <span class="kw">Some</span>(_), .. }) =&gt; <span class="ot">println!</span>(<span class="st">&quot;{:?}&quot;</span>, a),
      _ =&gt; {}
  }</code></pre>
  <p>Этот код напечатает <code>Some(&quot;Steve&quot;)</code>: мы связали внутреннюю <code>name</code> с <code>a</code>.</p>
  <p>Если вы используете <code>@</code> совместно с <code>|</code>, то вы должны убедиться, что имя связывается в каждой из частей шаблона:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">5</span>;
  
  <span class="kw">match</span> x {
      e @ <span class="dv">1</span> ... <span class="dv">5</span> | e @ <span class="dv">8</span> ... <span class="dv">10</span> =&gt; <span class="ot">println!</span>(<span class="st">&quot;получили элемент диапазона {}&quot;</span>, e),
      _ =&gt; <span class="ot">println!</span>(<span class="st">&quot;что угодно&quot;</span>),
  }</code></pre>
  </section>
  <section id="ограничители-шаблонов" class="level3">
  <h3>Ограничители шаблонов</h3>
  <p>Вы можете ввести <em>ограничители шаблонов</em> (<em>match guards</em>) с помощью <code>if</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">enum</span> OptionalInt {
      Value(<span class="kw">i32</span>),
      Missing,
  }
  
  <span class="kw">let</span> x = OptionalInt::Value(<span class="dv">5</span>);
  
  <span class="kw">match</span> x {
      OptionalInt::Value(i) <span class="kw">if</span> i &gt; <span class="dv">5</span> =&gt; <span class="ot">println!</span>(<span class="st">&quot;Получили целое больше пяти!&quot;</span>),
      OptionalInt::Value(..) =&gt; <span class="ot">println!</span>(<span class="st">&quot;Получили целое!&quot;</span>),
      OptionalInt::Missing =&gt; <span class="ot">println!</span>(<span class="st">&quot;Неудача.&quot;</span>),
  }</code></pre>
  <p>Этот код напечатает <code>Получили целое!</code>.</p>
  <p>Если вы используете <code>if</code> с несколькими шаблонами, он применяется к обоим частям:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">4</span>;
  <span class="kw">let</span> y = <span class="kw">false</span>;
  
  <span class="kw">match</span> x {
      <span class="dv">4</span> | <span class="dv">5</span> <span class="kw">if</span> y =&gt; <span class="ot">println!</span>(<span class="st">&quot;да&quot;</span>),
      _ =&gt; <span class="ot">println!</span>(<span class="st">&quot;нет&quot;</span>),
  }</code></pre>
  <p>Этот код печатает <code>нет</code>, потому что <code>if</code> применяется ко всему <code>4 | 5</code>, а не только к <code>5</code>. Другими словами, приоритет <code>if</code> выглядит так:</p>
  <pre class="text"><code>(4 | 5) if y =&gt; ...</code></pre>
  <p>а не так:</p>
  <pre class="text"><code>4 | (5 if y) =&gt; ...</code></pre>
  </section>
  <section id="заключение-3" class="level3">
  <h3>Заключение</h3>
  <p>Вот так! Существует много разных способов использования конструкции сопоставления с шаблоном, и все они могут быть смешаны и состыкованы, в зависимости от того, что вы хотите сделать:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">match</span> x {
      Foo { x: <span class="kw">Some</span>(<span class="kw">ref</span> name), y: <span class="kw">None</span> } =&gt; ...
  }</code></pre>
  <p>Шаблоны — это очень мощный инструмент. Используйте их.</p>
  </section>
  </section>
  <section id="sec--method-syntax" class="level2">
  <h2>Синтаксис методов</h2>
  <p>Функции — это хорошо, но если вы хотите вызвать несколько связных функций для каких-либо данных, то это может быть неудобно. Рассмотрим этот код:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">baz(bar(foo)));</code></pre>
  <p>Читать данную строку кода следует слева направо, поэтому мы наблюдаем такой порядок: «baz bar foo». Но он противоположен порядку, в котором функции будут вызываться: «foo bar baz». Было бы классно записать вызовы в том порядке, в котором они происходят, не так ли?</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">foo.bar().baz();</code></pre>
  <p>К счастью, как вы уже наверно догадались, это возможно! Rust предоставляет возможность использовать такой <em>синтаксис вызова метода</em> с помощью ключевого слова <code>impl</code>.</p>
  <section id="вызов-методов" class="level3">
  <h3>Вызов методов</h3>
  <p>Вот как это работает:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Circle {
      x: <span class="kw">f64</span>,
      y: <span class="kw">f64</span>,
      radius: <span class="kw">f64</span>,
  }
  
  <span class="kw">impl</span> Circle {
      <span class="kw">fn</span> area(&amp;<span class="kw">self</span>) -&gt; <span class="kw">f64</span> {
          std::<span class="kw">f64</span>::consts::PI * (<span class="kw">self</span>.radius * <span class="kw">self</span>.radius)
      }
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> c = Circle { x: <span class="dv">0.0</span>, y: <span class="dv">0.0</span>, radius: <span class="dv">2.0</span> };
      <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, c.area());
  }</code></pre>
  <p>Этот код напечатает <code>12.566371</code>.</p>
  <p>Мы создали структуру, которая представляет собой круг. Затем мы написали блок <code>impl</code> и определили метод <code>area</code> внутри него.</p>
  <p>Методы принимают специальный первый параметр, <code>&amp;self</code>. Есть три возможных варианта: <code>self</code>, <code>&amp;self</code> и <code>&amp;mut self</code>. Вы можете думать об этом специальном параметре как о <code>x</code> в <code>x.foo()</code>. Три варианта соответствуют трем возможным видам элемента <code>x</code>: <code>self</code> — если это просто значение в стеке, <code>&amp;self</code> — если это ссылка и <code>&amp;mut self</code> — если это изменяемая ссылка. Мы передаем параметр <code>&amp;self</code> в метод <code>area</code>, поэтому мы можем использовать его так же, как и любой другой параметр. Так как мы знаем, что это <code>Circle</code>, мы можем получить доступ к полю <code>radius</code> так же, как если бы это была любая другая структура.</p>
  <p>По умолчанию следует использовать <code>&amp;self</code>, также как следует предпочитать заимствование владению, а неизменные ссылки изменяемым. Вот пример, включающий все три варианта:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Circle {
      x: <span class="kw">f64</span>,
      y: <span class="kw">f64</span>,
      radius: <span class="kw">f64</span>,
  }
  
  <span class="kw">impl</span> Circle {
      <span class="kw">fn</span> reference(&amp;<span class="kw">self</span>) {
         <span class="ot">println!</span>(<span class="st">&quot;принимаем self по ссылке!&quot;</span>);
      }
  
      <span class="kw">fn</span> mutable_reference(&amp;<span class="kw">mut</span> <span class="kw">self</span>) {
         <span class="ot">println!</span>(<span class="st">&quot;принимаем self по изменяемой ссылке!&quot;</span>);
      }
  
      <span class="kw">fn</span> takes_ownership(<span class="kw">self</span>) {
         <span class="ot">println!</span>(<span class="st">&quot;принимаем владение self!&quot;</span>);
      }
  }</code></pre>
  </section>
  <section id="цепочка-вызовов-методов" class="level3">
  <h3>Цепочка вызовов методов</h3>
  <p>Итак, теперь мы знаем, как вызвать метод, например <code>foo.bar()</code>. Но что насчет нашего первоначального примера, <code>foo.bar().baz()</code>? Это называется «цепочка вызовов», и мы можем сделать это, вернув <code>self</code>.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Circle {
      x: <span class="kw">f64</span>,
      y: <span class="kw">f64</span>,
      radius: <span class="kw">f64</span>,
  }
  
  <span class="kw">impl</span> Circle {
      <span class="kw">fn</span> area(&amp;<span class="kw">self</span>) -&gt; <span class="kw">f64</span> {
          std::<span class="kw">f64</span>::consts::PI * (<span class="kw">self</span>.radius * <span class="kw">self</span>.radius)
      }
  
      <span class="kw">fn</span> grow(&amp;<span class="kw">self</span>, increment: <span class="kw">f64</span>) -&gt; Circle {
          Circle { x: <span class="kw">self</span>.x, y: <span class="kw">self</span>.y, radius: <span class="kw">self</span>.radius + increment }
      }
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> c = Circle { x: <span class="dv">0.0</span>, y: <span class="dv">0.0</span>, radius: <span class="dv">2.0</span> };
      <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, c.area());
  
      <span class="kw">let</span> d = c.grow(<span class="dv">2.0</span>).area();
      <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, d);
  }</code></pre>
  <p>Проверьте тип возвращаемого значения:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> grow(&amp;<span class="kw">self</span>) -&gt; Circle {</code></pre>
  <p>Мы просто указываем, что возвращается <code>Circle</code>. С помощью этого метода мы можем создать новый круг, площадь которого будет в 100 раз больше, чем у старого.</p>
  </section>
  <section id="статические-методы" class="level3">
  <h3>Статические методы</h3>
  <p>Вы также можете определить методы, которые не принимают параметр <code>self</code>. Вот шаблон программирования, который очень распространен в коде на Rust:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Circle {
      x: <span class="kw">f64</span>,
      y: <span class="kw">f64</span>,
      radius: <span class="kw">f64</span>,
  }
  
  <span class="kw">impl</span> Circle {
      <span class="kw">fn</span> new(x: <span class="kw">f64</span>, y: <span class="kw">f64</span>, radius: <span class="kw">f64</span>) -&gt; Circle {
          Circle {
              x: x,
              y: y,
              radius: radius,
          }
      }
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> c = Circle::new(<span class="dv">0.0</span>, <span class="dv">0.0</span>, <span class="dv">2.0</span>);
  }</code></pre>
  <p>Этот <em>статический метод</em>, который создает новый <code>Circle</code>. Обратите внимание, что статические методы вызываются с помощью синтаксиса: <code>Struct::method()</code>, а не <code>ref.method()</code>.</p>
  </section>
  <section id="шаблон-строитель-builder-pattern" class="level3">
  <h3>Шаблон «строитель» (Builder Pattern)</h3>
  <p>Давайте предположим, что нам нужно, чтобы наши пользователи могли создавать круги и чтобы у них была возможность задавать только те свойства, которые им нужны. В противном случае, атрибуты <code>x</code> и <code>y</code> будут <code>0.0</code>, а <code>radius</code> будет <code>1.0</code>. Rust не поддерживает перегрузку методов, именованные аргументы или переменное количество аргументов. Вместо этого мы используем шаблон «строитель». Он выглядит следующим образом:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Circle {
      x: <span class="kw">f64</span>,
      y: <span class="kw">f64</span>,
      radius: <span class="kw">f64</span>,
  }
  
  <span class="kw">impl</span> Circle {
      <span class="kw">fn</span> area(&amp;<span class="kw">self</span>) -&gt; <span class="kw">f64</span> {
          std::<span class="kw">f64</span>::consts::PI * (<span class="kw">self</span>.radius * <span class="kw">self</span>.radius)
      }
  }
  
  <span class="kw">struct</span> CircleBuilder {
      x: <span class="kw">f64</span>,
      y: <span class="kw">f64</span>,
      radius: <span class="kw">f64</span>,
  }
  
  <span class="kw">impl</span> CircleBuilder {
      <span class="kw">fn</span> new() -&gt; CircleBuilder {
          CircleBuilder { x: <span class="dv">0.0</span>, y: <span class="dv">0.0</span>, radius: <span class="dv">0.0</span>, }
      }
  
      <span class="kw">fn</span> x(&amp;<span class="kw">mut</span> <span class="kw">self</span>, coordinate: <span class="kw">f64</span>) -&gt; &amp;<span class="kw">mut</span> CircleBuilder {
          <span class="kw">self</span>.x = coordinate;
          <span class="kw">self</span>
      }
  
      <span class="kw">fn</span> y(&amp;<span class="kw">mut</span> <span class="kw">self</span>, coordinate: <span class="kw">f64</span>) -&gt; &amp;<span class="kw">mut</span> CircleBuilder {
          <span class="kw">self</span>.y = coordinate;
          <span class="kw">self</span>
      }
  
      <span class="kw">fn</span> radius(&amp;<span class="kw">mut</span> <span class="kw">self</span>, radius: <span class="kw">f64</span>) -&gt; &amp;<span class="kw">mut</span> CircleBuilder {
          <span class="kw">self</span>.radius = radius;
          <span class="kw">self</span>
      }
  
      <span class="kw">fn</span> finalize(&amp;<span class="kw">self</span>) -&gt; Circle {
          Circle { x: <span class="kw">self</span>.x, y: <span class="kw">self</span>.y, radius: <span class="kw">self</span>.radius }
      }
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> c = CircleBuilder::new()
                  .x(<span class="dv">1.0</span>)
                  .y(<span class="dv">2.0</span>)
                  .radius(<span class="dv">2.0</span>)
                  .finalize();
  
      <span class="ot">println!</span>(<span class="st">&quot;площадь: {}&quot;</span>, c.area());
      <span class="ot">println!</span>(<span class="st">&quot;x: {}&quot;</span>, c.x);
      <span class="ot">println!</span>(<span class="st">&quot;y: {}&quot;</span>, c.y);
  }</code></pre>
  <p>Всё, что мы сделали здесь — это создали ещё одну структуру, <code>CircleBuilder</code>. В ней мы определили методы строителя. Также мы определили метод <code>area()</code> в <code>Circle</code>. Мы также сделали еще один метод в <code>CircleBuilder</code>: <code>finalize()</code>. Этот метод создаёт наш окончательный <code>Circle</code> из строителя. Таким образом, мы можем использовать методы <code>CircleBuilder</code> чтобы уточнить создание <code>Circle</code>.</p>
  </section>
  </section>
  <section id="sec--vectors" class="level2">
  <h2>Вектора</h2>
  <p>«Вектор» — это динамический или, по-другому, «растущий» массив, реализованный в виде стандартного библиотечного типа <a href="http://doc.rust-lang.org/std/vec/index.html"><code>Vec&lt;T&gt;</code></a> (где <code>&lt;T&gt;</code> является <a href="#sec--generics">обобщённым типом</a>). Вектора всегда размещают данные в куче. Вы можете создавать их с помощью макроса <code>vec!</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> v = <span class="ot">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>]; <span class="co">// v: Vec&lt;i32&gt;</span></code></pre>
  <p>(Заметьте, что, в отличие от макроса <code>println!</code>, который мы использовали ранее, с <code>vec!</code> используются квадратные скобки <code>[]</code>. Rust разрешает использование и круглых, и квадратных скобок в обеих ситуациях — это просто стилистическое соглашение.)</p>
  <p>Для создания вектора из повторяющихся значений есть другая форма <code>vec!</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> v = <span class="ot">vec!</span>[<span class="dv">0</span>; <span class="dv">10</span>]; <span class="co">// десять нулей</span></code></pre>
  <section id="доступ-к-элементам" class="level4">
  <h4>Доступ к элементам</h4>
  <p>Чтобы получить значение по определенному индексу в векторе, мы используем <code>[]</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> v = <span class="ot">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>];
  
  <span class="ot">println!</span>(<span class="st">&quot;Третий элемент вектора v равен {}&quot;</span>, v[<span class="dv">2</span>]);</code></pre>
  <p>Индексы отсчитываются от <code>0</code>, так что третьим элементом является <code>v[2]</code>.</p>
  </section>
  <section id="обход" class="level4">
  <h4>Обход</h4>
  <p>Вы можете обойти элементы вектора с помощью <code>for</code>. Есть три варианта:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> v = <span class="ot">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>];
  
  <span class="kw">for</span> i in &amp;v {
      <span class="ot">println!</span>(<span class="st">&quot;Ссылка {}&quot;</span>, i);
  }
  
  <span class="kw">for</span> i in &amp;<span class="kw">mut</span> v {
      <span class="ot">println!</span>(<span class="st">&quot;Изменяемая ссылка {}&quot;</span>, i);
  }
  
  <span class="kw">for</span> i in v {
      <span class="ot">println!</span>(<span class="st">&quot;Владение вектором и его элементами {}&quot;</span>, i);
  }</code></pre>
  <p>У векторов есть много других полезных методов, о которых вы можете прочитать в <a href="http://doc.rust-lang.org/std/vec/index.html">документации API</a>.</p>
  </section>
  </section>
  <section id="sec--strings" class="level2">
  <h2>Строки</h2>
  <p>Строки — важное понятие для любого программиста. Система обработки строк в Rust немного отличается от других языков, потому что это язык системного программирования. Работать со структурами данных с переменным размером довольно сложно, и строки — как раз такая структура данных. Кроме того, работа со строками в Rust также отличается и от некоторых системных языков, таких как C.</p>
  <p>Давайте разбираться в деталях. <em>string</em> — это последовательность скалярных значений юникод, закодированных в виде потока байт UTF-8. Все строки должны быть гарантированно валидными UTF-8 последовательностями. Кроме того, строки не оканчиваются нулём и могут содержать нулевые байты.</p>
  <p>В Rust есть два основных типа строк: <code>&amp;str</code> и <code>String</code>. Сперва поговорим о <code>&amp;str</code> — это «строковый срез». Строковые срезы имеют фиксированный размер и не могут быть изменены. Они представляют собой ссылку на последовательность байт UTF-8:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> greeting = <span class="st">&quot;Всем привет.&quot;</span>; <span class="co">// greeting: &amp;'static str</span></code></pre>
  <p><code>&quot;Всем привет.&quot;</code> — это строковый литерал, его тип — <code>&amp;'static str</code>. Строковые литералы являются статически размещенными строковыми срезами. Это означает, что они сохраняются внутри нашей скомпилированной программы и существуют в течение всего периода ее выполнения. Имя <code>greeting</code> представляет собой ссылку на эту статически размещенную строку. Любая функция, ожидающая строковый срез, может также принять в качестве аргумента строковый литерал.</p>
  <p>Строковые литералы могут состоять из нескольких строк. Такие литералы можно записывать в двух разных формах. Первая будет включать в себя перевод на новую строку и ведущие пробелы:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> s = <span class="st">&quot;foo</span>
  <span class="st">    bar&quot;</span>;
  
  <span class="ot">assert_eq!</span>(<span class="st">&quot;foo</span><span class="ch">\n</span><span class="st">        bar&quot;</span>, s);</code></pre>
  <p>Вторая форма, включающая в себя <code>\</code>, вырезает пробелы и перевод на новую строку:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> s = <span class="st">&quot;foo\</span>
  <span class="st">    bar&quot;</span>; 
  
  <span class="ot">assert_eq!</span>(<span class="st">&quot;foobar&quot;</span>, s);</code></pre>
  <p>Но в Rust есть не только <code>&amp;str</code>. Тип <code>String</code> представляет собой строку, размещенную в куче. Эта строка расширяема, и она также гарантированно является последовательностью UTF-8. <code>String</code> обычно создаётся путем преобразования из строкового среза с использованием метода <code>to_string</code>.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> s = <span class="st">&quot;Привет&quot;</span>.to_string(); <span class="co">// mut s: String</span>
  <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, s);
  
  s.push_str(<span class="st">&quot;, мир.&quot;</span>);
  <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, s);</code></pre>
  <p><code>String</code> преобразуются в <code>&amp;str</code> с помощью <code>&amp;</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> takes_slice(slice: &amp;<span class="kw">str</span>) {
      <span class="ot">println!</span>(<span class="st">&quot;Получили: {}&quot;</span>, slice);
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> s = <span class="st">&quot;Привет&quot;</span>.to_string();
      takes_slice(&amp;s);
  }</code></pre>
  <p>Это преобразование не происходит в случае функций, которые принимают какой-то типаж <code>&amp;str</code>, а не сам <code>&amp;str</code>. Например, у метода <a href="https://doc.rust-lang.org/stable/std/net/struct.TcpStream.html#method.connect"><code>TcpStream::connect</code></a> есть параметр типа <code>ToSocketAddrs</code>. Сюда можно передать <code>&amp;str</code>, но <code>String</code> нужно явно преобразовать с помощью <code>&amp;*</code>.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::net::TcpStream;
  
  TcpStream::connect(<span class="st">&quot;192.168.0.1:3000&quot;</span>); <span class="co">// параметр &amp;str</span>
  
  <span class="kw">let</span> addr_string = <span class="st">&quot;192.168.0.1:3000&quot;</span>.to_string();
  TcpStream::connect(&amp;*addr_string); <span class="co">// преобразуем addr_string в &amp;str</span></code></pre>
  <p>Представление <code>String</code> как <code>&amp;str</code> — дешёвая операция, но преобразование <code>&amp;str</code> в <code>String</code> предполагает выделение памяти. Не стоит делать это без необходимости!</p>
  <section id="индексация" class="level4">
  <h4>Индексация</h4>
  <p>Поскольку строки являются валидными UTF-8 последовательностями, то они не поддерживают индексацию:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> s = <span class="st">&quot;привет&quot;</span>;
  
  <span class="ot">println!</span>(<span class="st">&quot;Первая буква s — {}&quot;</span>, s[<span class="dv">0</span>]); <span class="co">// ОШИБКА!!!</span></code></pre>
  <p>Как правило, доступ к вектору с помощью <code>[]</code> является очень быстрой операцией. Но поскольку каждый символ в строке, закодированной UTF-8, может быть представлен несколькими байтами, то при поиске вы должны перебрать n-ое количество литер в строке. Это значительно более дорогая операция, а мы не хотим вводить в заблуждение. Кроме того, «литера» — это не совсем то, что определено в Unicode. Мы можем выбрать как рассматривать строку: как отдельные байты или как кодовые единицы (codepoints):</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> hachiko = <span class="st">&quot;忠犬ハチ公&quot;</span>;
  
  <span class="kw">for</span> b in hachiko.as_bytes() {
      <span class="ot">print!</span>(<span class="st">&quot;{}, &quot;</span>, b);
  }
  
  <span class="ot">println!</span>(<span class="st">&quot;&quot;</span>);
  
  <span class="kw">for</span> c in hachiko.chars() {
      <span class="ot">print!</span>(<span class="st">&quot;{}, &quot;</span>, c);
  }
  
  <span class="ot">println!</span>(<span class="st">&quot;&quot;</span>);</code></pre>
  <p>Этот код напечатает:</p>
  <pre class="text"><code>229, 191, 160, 231, 138, 172, 227, 131, 143, 227, 131, 129, 229, 133, 172, 
  忠, 犬, ハ, チ, 公, </code></pre>
  <p>Как вы можете видеть, количество байт больше, чем количество символов (<code>char</code>).</p>
  <p>Вы можете получить что-то наподобие индекса, как показано ниже:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> dog = hachiko.chars().nth(<span class="dv">1</span>); <span class="co">// что-то вроде hachiko[1]</span></code></pre>
  <p>Это подчеркивает, что мы должны пройти по списку <code>chars</code> от его начала.</p>
  </section>
  <section id="срезы" class="level4">
  <h4>Срезы</h4>
  <p>Вы можете получить срез строки с помощью синтаксиса срезов:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> dog = <span class="st">&quot;hachiko&quot;</span>;
  <span class="kw">let</span> hachi = &amp;dog[<span class="dv">0.</span>.<span class="dv">5</span>];</code></pre>
  <p>Но заметьте, что это индексы <em>байтов</em>, а не <em>символов</em>. Поэтому этот код запаникует:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> dog = <span class="st">&quot;忠犬ハチ公&quot;</span>;
  <span class="kw">let</span> hachi = &amp;dog[<span class="dv">0.</span>.<span class="dv">2</span>];</code></pre>
  <p>с такой ошибкой:</p>
  <pre class="text"><code>thread '&lt;main&gt;' panicked at 'index 0 and/or 2 in `忠犬ハチ公` do not lie on
  character boundary'</code></pre>
  </section>
  <section id="конкатенация" class="level4">
  <h4>Конкатенация</h4>
  <p>Если у вас есть <code>String</code>, то вы можете присоединить к нему в конец <code>&amp;str</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> hello = <span class="st">&quot;Hello &quot;</span>.to_string();
  <span class="kw">let</span> world = <span class="st">&quot;world!&quot;</span>;
  
  <span class="kw">let</span> hello_world = hello + world;</code></pre>
  <p>Но если у вас есть две <code>String</code>, то необходимо использовать <code>&amp;</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> hello = <span class="st">&quot;Hello &quot;</span>.to_string();
  <span class="kw">let</span> world = <span class="st">&quot;world!&quot;</span>.to_string();
  
  <span class="kw">let</span> hello_world = hello + &amp;world;</code></pre>
  <p>Это потому, что <code>&amp;String</code> может быть автоматически приведен к <code>&amp;str</code>. Эта возможность называется «<a href="#sec--deref-coercions">Приведение при разыменовании</a>».</p>
  </section>
  </section>
  <section id="sec--generics" class="level2">
  <h2>Обобщённое программирование</h2>
  <p>Иногда, при написании функции или типа данных, мы можем захотеть, чтобы они работали для нескольких типов аргументов. К счастью, у Rust есть возможность, которая даёт нам лучший способ реализовать это: обобщённое программирование. Обобщённое программирование называется «параметрическим полиморфизмом» в теории типов. Это означает, что типы или функции имеют несколько форм (poly — кратно, morph — форма) по данному параметру («параметрический»).</p>
  <p>В любом случае, хватит о теории типов; давайте рассмотрим какой-нибудь обобщённый код. Стандартная библиотека Rust предоставляет тип <code>Option&lt;T&gt;</code>, который является обобщённым типом:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">enum</span> <span class="kw">Option</span>&lt;T&gt; {
      <span class="kw">Some</span>(T),
      <span class="kw">None</span>,
  }</code></pre>
  <p>Часть <code>&lt;T&gt;</code>, которую вы раньше уже видели несколько раз, указывает, что это обобщённый тип данных. Внутри перечисления, везде, где мы видим <code>T</code>, мы подставляем вместо этого абстрактного типа тот, который используется в обобщении. Вот пример использования <code>Option&lt;T&gt;</code> с некоторыми дополнительными аннотациями типов:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x: <span class="kw">Option</span>&lt;<span class="kw">i32</span>&gt; = <span class="kw">Some</span>(<span class="dv">5</span>);</code></pre>
  <p>В определении типа мы используем <code>Option&lt;i32&gt;</code>. Обратите внимание, что это очень похоже на <code>Option&lt;T&gt;</code>. С той лишь разницей, что, в данном конкретном <code>Option</code>, <code>T</code> имеет значение <code>i32</code>. В правой стороне выражения мы используем <code>Some(T)</code>, где <code>T</code> равно <code>5</code>. Так как <code>5</code> является представителем типа <code>i32</code>, то типы по обе стороны совпадают, поэтому компилятор счастлив. Если же они не совпадают, то мы получим ошибку:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x: <span class="kw">Option</span>&lt;<span class="kw">f64</span>&gt; = <span class="kw">Some</span>(<span class="dv">5</span>);
  <span class="co">// error: mismatched types: expected `core::option::Option&lt;f64&gt;`,</span>
  <span class="co">// found `core::option::Option&lt;_&gt;` (expected f64 but found integral variable)</span></code></pre>
  <p>Но это не значит, что мы не можем сделать <code>Option&lt;T&gt;</code>, который содержит <code>f64</code>! Просто типы должны совпадать:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x: <span class="kw">Option</span>&lt;<span class="kw">i32</span>&gt; = <span class="kw">Some</span>(<span class="dv">5</span>);
  <span class="kw">let</span> y: <span class="kw">Option</span>&lt;<span class="kw">f64</span>&gt; = <span class="kw">Some</span>(<span class="dv">5.0f64</span>);</code></pre>
  <p>Это просто прекрасно. Одно определение — многостороннее использование.</p>
  <p>Обобщать можно более, чем по одному параметру. Рассмотрим другой обобщённый тип из стандартной библиотеки Rust — <code>Result&lt;T, E&gt;</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">enum</span> <span class="kw">Result</span>&lt;T, E&gt; {
      <span class="kw">Ok</span>(T),
      <span class="kw">Err</span>(E),
  }</code></pre>
  <p>Этот тип является обобщённым сразу для <em>двух</em> типов: <code>T</code> и <code>E</code>. Кстати, заглавные буквы могут быть любыми. Мы могли бы определить <code>Result&lt;T, E&gt;</code> как:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">enum</span> <span class="kw">Result</span>&lt;A, Z&gt; {
      <span class="kw">Ok</span>(A),
      <span class="kw">Err</span>(Z),
  }</code></pre>
  <p>если бы захотели. Соглашение гласит, что первый обобщённый параметр для ‘типа’ должен быть <code>T</code>, и что для ‘ошибки’ используется <code>E</code>. Но Rust не проверяет этого.</p>
  <p>Тип <code>Result&lt;T, E&gt;</code> предназначен для того, чтобы возвращать результат вычисления, и имеет возможность вернуть ошибку, если произойдёт какой-либо сбой.</p>
  <section id="обобщённые-функции" class="level4">
  <h4>Обобщённые функции</h4>
  <p>Мы можем задавать функции, которые принимают обобщённые типы, с помощью аналогичного синтаксиса:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> takes_anything&lt;T&gt;(x: T) {
      <span class="co">// делаем что-то с x</span>
  }</code></pre>
  <p>Синтаксис состоит из двух частей: <code>&lt;T&gt;</code> говорит о том, что «эта функция является обобщённой по одному типу, <code>T</code>», а <code>x: T</code> говорит о том, что «х имеет тип <code>T</code>».</p>
  <p>Несколько аргументов могут иметь один и тот же обобщённый тип:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> takes_two_of_the_same_things&lt;T&gt;(x: T, y: T) {
      <span class="co">// ...</span>
  }</code></pre>
  <p>Мы можем написать версию, которая принимает несколько типов:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> takes_two_things&lt;T, U&gt;(x: T, y: U) {
      <span class="co">// ...</span>
  }</code></pre>
  <p>Обобщённые функции наиболее полезны в связке с «ограничениями по типажам», о которых мы расскажем в главе <a href="#sec--traits">Типажи</a>.</p>
  </section>
  <section id="обобщённые-структуры" class="level4">
  <h4>Обобщённые структуры</h4>
  <p>Вы также можете задать обобщённый тип для <code>struct</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Point&lt;T&gt; {
      x: T,
      y: T,
  }
  
  <span class="kw">let</span> int_origin = Point { x: <span class="dv">0</span>, y: <span class="dv">0</span> };
  <span class="kw">let</span> float_origin = Point { x: <span class="dv">0.0</span>, y: <span class="dv">0.0</span> };</code></pre>
  <p>Аналогично функциям, мы также объявляем обобщённые параметры в <code>&lt;T&gt;</code>, а затем используем их в объявлении типа <code>x: T</code>.</p>
  </section>
  </section>
  <section id="sec--traits" class="level2">
  <h2>Типажи</h2>
  <p>Типаж — это возможность объяснить компилятору, что данный тип должен предоставлять определённую функциональность.</p>
  <p>Вы помните ключевое слово <code>impl</code>, используемое для вызова функции через синтаксис метода?</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Circle {
      x: <span class="kw">f64</span>,
      y: <span class="kw">f64</span>,
      radius: <span class="kw">f64</span>,
  }
  
  <span class="kw">impl</span> Circle {
      <span class="kw">fn</span> area(&amp;<span class="kw">self</span>) -&gt; <span class="kw">f64</span> {
          std::<span class="kw">f64</span>::consts::PI * (<span class="kw">self</span>.radius * <span class="kw">self</span>.radius)
      }
  }</code></pre>
  <p>Типажи схожи, за исключением того, что мы определяем типаж, содержащий лишь сигнатуру метода, а затем реализуем этот типаж для нужной структуры. Например, как показано ниже:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Circle {
      x: <span class="kw">f64</span>,
      y: <span class="kw">f64</span>,
      radius: <span class="kw">f64</span>,
  }
  
  <span class="kw">trait</span> HasArea {
      <span class="kw">fn</span> area(&amp;<span class="kw">self</span>) -&gt; <span class="kw">f64</span>;
  }
  
  <span class="kw">impl</span> HasArea <span class="kw">for</span> Circle {
      <span class="kw">fn</span> area(&amp;<span class="kw">self</span>) -&gt; <span class="kw">f64</span> {
          std::<span class="kw">f64</span>::consts::PI * (<span class="kw">self</span>.radius * <span class="kw">self</span>.radius)
      }
  }</code></pre>
  <p>Как вы можете видеть, блок <code>trait</code> очень похож на блок <code>impl</code>. Различие состоит лишь в том, что тело метода не определяется, а определяется только его сигнатура. Когда мы реализуем типаж, мы используем <code>impl Trait for Item</code>, а не просто <code>impl Item</code>.</p>
  <p>Мы можем использовать типажи для ограничения обобщённых типов. Рассмотрим похожую функцию, которая также не компилируется, и выводит ошибку:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> print_area&lt;T&gt;(shape: T) {
      <span class="ot">println!</span>(<span class="st">&quot;This shape has an area of {}&quot;</span>, shape.area());
  }</code></pre>
  <p>Rust выводит:</p>
  <pre class="text"><code>error: type `T` does not implement any method in scope named `area`</code></pre>
  <p>Поскольку <code>T</code> может быть любого типа, мы не можем быть уверены, что он реализует метод <code>area</code>. Но мы можем добавить «ограничение по типажу» к нашему обобщённому типу <code>T</code>, гарантируя, что он будет соответствовать требованиям:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> print_area&lt;T: HasArea&gt;(shape: T) {
      <span class="ot">println!</span>(<span class="st">&quot;This shape has an area of {}&quot;</span>, shape.area());
  }</code></pre>
  <p>Синтаксис <code>&lt;T: HasArea&gt;</code> означает «любой тип, реализующий типаж <code>HasArea</code>». Так как типажи определяют сигнатуры типов функций, мы можем быть уверены, что любой тип, который реализует <code>HasArea</code>, будет иметь метод <code>.area()</code>.</p>
  <p>Вот расширенный пример того, как это работает:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">trait</span> HasArea {
      <span class="kw">fn</span> area(&amp;<span class="kw">self</span>) -&gt; <span class="kw">f64</span>;
  }
  
  <span class="kw">struct</span> Circle {
      x: <span class="kw">f64</span>,
      y: <span class="kw">f64</span>,
      radius: <span class="kw">f64</span>,
  }
  
  <span class="kw">impl</span> HasArea <span class="kw">for</span> Circle {
      <span class="kw">fn</span> area(&amp;<span class="kw">self</span>) -&gt; <span class="kw">f64</span> {
          std::<span class="kw">f64</span>::consts::PI * (<span class="kw">self</span>.radius * <span class="kw">self</span>.radius)
      }
  }
  
  <span class="kw">struct</span> Square {
      x: <span class="kw">f64</span>,
      y: <span class="kw">f64</span>,
      side: <span class="kw">f64</span>,
  }
  
  <span class="kw">impl</span> HasArea <span class="kw">for</span> Square {
      <span class="kw">fn</span> area(&amp;<span class="kw">self</span>) -&gt; <span class="kw">f64</span> {
          <span class="kw">self</span>.side * <span class="kw">self</span>.side
      }
  }
  
  <span class="kw">fn</span> print_area&lt;T: HasArea&gt;(shape: T) {
      <span class="ot">println!</span>(<span class="st">&quot;Площадь этой фигуры равна {}&quot;</span>, shape.area());
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> c = Circle {
          x: <span class="dv">0.0f64</span>,
          y: <span class="dv">0.0f64</span>,
          radius: <span class="dv">1.0f64</span>,
      };
  
      <span class="kw">let</span> s = Square {
          x: <span class="dv">0.0f64</span>,
          y: <span class="dv">0.0f64</span>,
          side: <span class="dv">1.0f64</span>,
      };
  
      print_area(c);
      print_area(s);
  }</code></pre>
  <p>Ниже показан вывод программы:</p>
  <pre class="text"><code>Площадь этой фигуры равна 3.141593
  Площадь этой фигуры равна 1</code></pre>
  <p>Как вы можете видеть, теперь <code>print_area</code> не только является обобщённой функцией, но и гарантирует, что будет получен корректный тип. Если же мы передадим некорректный тип:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">print_area(<span class="dv">5</span>);</code></pre>
  <p>Мы получим ошибку времени компиляции:</p>
  <pre class="text"><code>error: the trait `HasArea` is not implemented for the type `_` [E0277]</code></pre>
  <p>До сих пор мы добавляли реализации типажей лишь для структур, но реализовать типаж можно для любого типа. Технически, мы <em>могли бы</em> реализовать <code>HasArea</code> для <code>i32</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">trait</span> HasArea {
      <span class="kw">fn</span> area(&amp;<span class="kw">self</span>) -&gt; <span class="kw">f64</span>;
  }
  
  <span class="kw">impl</span> HasArea <span class="kw">for</span> <span class="kw">i32</span> {
      <span class="kw">fn</span> area(&amp;<span class="kw">self</span>) -&gt; <span class="kw">f64</span> {
          <span class="ot">println!</span>(<span class="st">&quot;это нелепо&quot;</span>);
  
          *<span class="kw">self</span> <span class="kw">as</span> <span class="kw">f64</span>
      }
  }
  
  <span class="dv">5.</span>area();</code></pre>
  <p>Хотя технически это возможно, реализация методов для примитивных типов считается плохим стилем программирования.</p>
  <p>Может показаться, что такой подход легко приводит к бардаку в коде, однако есть два ограничения, связанные с реализацией типажей, которые мешают коду выйти из-под контроля. Во-первых, если типаж не определён в нашей области видимости, он не применяется. Например, стандартная библиотека предоставляет типаж <a href="https://doc.rust-lang.org/stable/std/io/trait.Write.html"><code>Write</code></a>, который добавляет типу <code>File</code> функциональность ввода-вывода. По умолчанию у <code>File</code> не будет этих методов:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> f = std::fs::File::open(<span class="st">&quot;foo.txt&quot;</span>).ok().expect(<span class="st">&quot;Не могу открыть foo.txt&quot;</span>);
  <span class="kw">let</span> buf = b<span class="st">&quot;whatever&quot;</span>; <span class="co">// литерал строки байт. buf: &amp;[u8; 8]</span>
  <span class="kw">let</span> result = f.write(buf);</code></pre>
  <p>Вот ошибка:</p>
  <pre class="text"><code>error: type `std::fs::File` does not implement any method in scope named `write`
  let result = f.write(buf);
                 ^~~~~~~~~~</code></pre>
  <p>Сначала мы должны сделать <code>use</code> для типажа <code>Write</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::io::Write;
  
  <span class="kw">let</span> <span class="kw">mut</span> f = std::fs::File::open(<span class="st">&quot;foo.txt&quot;</span>).ok().expect(<span class="st">&quot;Не могу открыть foo.txt&quot;</span>);
  <span class="kw">let</span> buf = b<span class="st">&quot;whatever&quot;</span>;
  <span class="kw">let</span> result = f.write(buf);</code></pre>
  <p>Это скомпилируется без ошибки.</p>
  <p>Благодаря такой логике работы, даже если кто-то сделает что-то страшное — например, добавит методы <code>i32</code>, это не коснётся вас, пока вы не импортируете типаж.</p>
  <p>Второе ограничение реализации типажей — это то, что или типаж, или тип, для которого вы реализуете типаж, должен быть реализован вами. Мы могли бы определить <code>HasArea</code> для <code>i32</code>, потому что <code>HasArea</code> — это наш код. Но если бы мы попробовали реализовать для <code>i32</code> <code>ToString</code> — типаж, предоставляемый Rust — мы бы не смогли сделать это, потому что ни типаж, ни тип не реализован нами.</p>
  <p>Последнее, что нужно сказать о типажах: обобщённые функции с ограничением по типажам используют <em>мономорфизацию</em> (<em>mono</em>: один, <em>morph</em>: форма), поэтому они диспетчеризуются статически. Что это значит? Посмотрите главу <a href="#sec--trait-objects">Типажи-объекты</a>, чтобы получить больше информации.</p>
  <section id="множественные-ограничения-по-типажам" class="level3">
  <h3>Множественные ограничения по типажам</h3>
  <p>Вы уже видели, как можно ограничить обобщённый параметр типа определённым типажом:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo&lt;T: Clone&gt;(x: T) {
      x.clone();
  }</code></pre>
  <p>Если вам нужно больше одного ограничения, вы можете использовать <code>+</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::fmt::Debug;
  
  <span class="kw">fn</span> foo&lt;T: Clone + Debug&gt;(x: T) {
      x.clone();
      <span class="ot">println!</span>(<span class="st">&quot;{:?}&quot;</span>, x);
  }</code></pre>
  <p>Теперь тип <code>T</code> должен реализовавать как типаж <code>Clone</code>, так и типаж <code>Debug</code>.</p>
  </section>
  <section id="утверждение-where" class="level3">
  <h3>Утверждение where</h3>
  <p>Написание функций с несколькими обобщёнными типами и небольшим количеством ограничений по типажам выглядит не так уж плохо, но, с увеличением количества зависимостей, синтаксис получается более неуклюжим:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::fmt::Debug;
  
  <span class="kw">fn</span> foo&lt;T: Clone, K: Clone + Debug&gt;(x: T, y: K) {
      x.clone();
      y.clone();
      <span class="ot">println!</span>(<span class="st">&quot;{:?}&quot;</span>, y);
  }</code></pre>
  <p>Имя функции находится слева, а список параметров — далеко справа. Ограничения загромождают место.</p>
  <p>Есть решение и для этой проблемы, и оно называется «утверждение <code>where</code>»:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::fmt::Debug;
  
  <span class="kw">fn</span> foo&lt;T: Clone, K: Clone + Debug&gt;(x: T, y: K) {
      x.clone();
      y.clone();
      <span class="ot">println!</span>(<span class="st">&quot;{:?}&quot;</span>, y);
  }
  
  <span class="kw">fn</span> bar&lt;T, K&gt;(x: T, y: K) where T: Clone, K: Clone + Debug {
      x.clone();
      y.clone();
      <span class="ot">println!</span>(<span class="st">&quot;{:?}&quot;</span>, y);
  }
  
  <span class="kw">fn</span> main() {
      foo(<span class="st">&quot;Привет&quot;</span>, <span class="st">&quot;мир&quot;</span>);
      bar(<span class="st">&quot;Привет&quot;</span>, <span class="st">&quot;мир&quot;</span>);
  }</code></pre>
  <p><code>foo()</code> использует синтаксис, показанный ранее, а <code>bar()</code> использует утверждение <code>where</code>. Все, что нам нужно сделать, это убрать ограничения при определении типов параметров, а затем добавить <code>where</code> после списка параметров. В более длинных списках можно использовать пробелы:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::fmt::Debug;
  
  <span class="kw">fn</span> bar&lt;T, K&gt;(x: T, y: K)
      where T: Clone,
            K: Clone + Debug {
  
      x.clone();
      y.clone();
      <span class="ot">println!</span>(<span class="st">&quot;{:?}&quot;</span>, y);
  }</code></pre>
  <p>Такая гибкость может добавить ясности в сложных ситуациях.</p>
  <p>На самом деле <code>where</code> не только упрощает написание, это более мощная возможность. Например:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">trait</span> ConvertTo&lt;Output&gt; {
      <span class="kw">fn</span> convert(&amp;<span class="kw">self</span>) -&gt; Output;
  }
  
  <span class="kw">impl</span> ConvertTo&lt;<span class="kw">i64</span>&gt; <span class="kw">for</span> <span class="kw">i32</span> {
      <span class="kw">fn</span> convert(&amp;<span class="kw">self</span>) -&gt; <span class="kw">i64</span> { *<span class="kw">self</span> <span class="kw">as</span> <span class="kw">i64</span> }
  }
  
  <span class="co">// может быть вызван с T == i32</span>
  <span class="kw">fn</span> normal&lt;T: ConvertTo&lt;<span class="kw">i64</span>&gt;&gt;(x: &amp;T) -&gt; <span class="kw">i64</span> {
      x.convert()
  }
  
  <span class="co">// может быть вызван с T == i64</span>
  <span class="kw">fn</span> inverse&lt;T&gt;() -&gt; T
          <span class="co">// использует ConvertTo как если бы это было «ConvertFrom&lt;i32&gt;»</span>
          where <span class="kw">i32</span>: ConvertTo&lt;T&gt; {
      <span class="dv">1i32</span>.convert()
  }</code></pre>
  <p>Этот код демонстрирует дополнительные преимущества использования утверждения <code>where</code>: оно позволяет задавать ограничение, где с левой стороны располагается произвольный тип (в данном случае <code>i32</code>), а не только простой параметр типа (вроде <code>T</code>).</p>
  </section>
  <section id="методы-по-умолчанию" class="level3">
  <h3>Методы по умолчанию</h3>
  <p>Есть еще одна особенность типажей, о которой стоит поговорить: методы по умолчанию. Проще всего показать это на примере:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">trait</span> Foo {
      <span class="kw">fn</span> is_valid(&amp;<span class="kw">self</span>) -&gt; <span class="kw">bool</span>;
  
      <span class="kw">fn</span> is_invalid(&amp;<span class="kw">self</span>) -&gt; <span class="kw">bool</span> { !<span class="kw">self</span>.is_valid() }
  }</code></pre>
  <p>В типах, реализующих типаж <code>Foo</code>, нужно реализовать метод <code>is_valid()</code>, а <code>is_invalid()</code> будет реализован по-умолчанию. Его поведение можно переопределить:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> UseDefault;
  
  <span class="kw">impl</span> Foo <span class="kw">for</span> UseDefault {
      <span class="kw">fn</span> is_valid(&amp;<span class="kw">self</span>) -&gt; <span class="kw">bool</span> {
          <span class="ot">println!</span>(<span class="st">&quot;Вызван UseDefault.is_valid.&quot;</span>);
          <span class="kw">true</span>
      }
  }
  
  <span class="kw">struct</span> OverrideDefault;
  
  <span class="kw">impl</span> Foo <span class="kw">for</span> OverrideDefault {
      <span class="kw">fn</span> is_valid(&amp;<span class="kw">self</span>) -&gt; <span class="kw">bool</span> {
          <span class="ot">println!</span>(<span class="st">&quot;Вызван OverrideDefault.is_valid.&quot;</span>);
          <span class="kw">true</span>
      }
  
      <span class="kw">fn</span> is_invalid(&amp;<span class="kw">self</span>) -&gt; <span class="kw">bool</span> {
          <span class="ot">println!</span>(<span class="st">&quot;Вызван OverrideDefault.is_invalid!&quot;</span>);
          <span class="kw">true</span> <span class="co">// эта реализация противоречит сама себе!</span>
      }
  }
  
  <span class="kw">let</span> default = UseDefault;
  assert!(!default.is_invalid()); <span class="co">// печатает «Вызван UseDefault.is_valid.»</span>
  
  <span class="kw">let</span> over = OverrideDefault;
  assert!(over.is_invalid()); <span class="co">// печатает «Вызван OverrideDefault.is_invalid!»</span></code></pre>
  </section>
  <section id="наследование" class="level3">
  <h3>Наследование</h3>
  <p>Иногда чтобы реализовать один типаж, нужно реализовать типажи, от которых он зависит:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">trait</span> Foo {
      <span class="kw">fn</span> foo(&amp;<span class="kw">self</span>);
  }
  
  <span class="kw">trait</span> FooBar : Foo {
      <span class="kw">fn</span> foobar(&amp;<span class="kw">self</span>);
  }</code></pre>
  <p>Типы, реализующие <code>FooBar</code>, должны реализовывать <code>Foo</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Baz;
  
  <span class="kw">impl</span> Foo <span class="kw">for</span> Baz {
      <span class="kw">fn</span> foo(&amp;<span class="kw">self</span>) { <span class="ot">println!</span>(<span class="st">&quot;foo&quot;</span>); }
  }
  
  <span class="kw">impl</span> FooBar <span class="kw">for</span> Baz {
      <span class="kw">fn</span> foobar(&amp;<span class="kw">self</span>) { <span class="ot">println!</span>(<span class="st">&quot;foobar&quot;</span>); }
  }</code></pre>
  <p>Если мы забудем реализовать <code>Foo</code>, компилятор скажет нам об этом:</p>
  <pre class="text"><code>error: the trait `main::Foo` is not implemented for the type `main::Baz` [E0277]</code></pre>
  </section>
  </section>
  <section id="sec--drop" class="level2">
  <h2>Типаж <code>Drop</code> (сброс)</h2>
  <p>Мы обсудили типажи. Теперь давайте поговорим о конкретном типаже, предоставляемом стандартной библиотекой Rust. Этот типаж — <a href="http://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a> (сброс) — позволяет выполнить некоторый код, когда значение выходит из области видимости. Например:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> HasDrop;
  
  <span class="kw">impl</span> <span class="kw">Drop</span> <span class="kw">for</span> HasDrop {
      <span class="kw">fn</span> drop(&amp;<span class="kw">mut</span> <span class="kw">self</span>) {
          <span class="ot">println!</span>(<span class="st">&quot;Сбрасываем!&quot;</span>);
      }
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> x = HasDrop;
  
      <span class="co">// сделаем что-то</span>
  
  } <span class="co">// тут x выходит из области видимости</span></code></pre>
  <p>Когда <code>x</code> выходит из области видимости в конце <code>main()</code>, исполнится код реализации типажа <code>Drop</code>. У него один метод, который тоже называется <code>drop()</code>. Он принимает изменяемую ссылку на себя (<code>self</code>).</p>
  <p>Вот и всё! Работа <code>Drop</code> достаточно проста, но есть несколько тонкостей. Например, значения сбрасываются в порядке, обратном порядку их объявления. Вот ещё пример:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Firework {
      strength: <span class="kw">i32</span>,
  }
  
  <span class="kw">impl</span> <span class="kw">Drop</span> <span class="kw">for</span> Firework {
      <span class="kw">fn</span> drop(&amp;<span class="kw">mut</span> <span class="kw">self</span>) {
          <span class="ot">println!</span>(<span class="st">&quot;БАБАХ силой {}!!!&quot;</span>, <span class="kw">self</span>.strength);
      }
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> firecracker = Firework { strength: <span class="dv">1</span> };
      <span class="kw">let</span> tnt = Firework { strength: <span class="dv">100</span> };
  }</code></pre>
  <p>Этот код выведет следующее:</p>
  <pre class="text"><code>БАБАХ силой 100!!!
  БАБАХ силой 1!!!</code></pre>
  <p>Сначала взрывается тринитротолуоловая бомба (<code>tnt</code>), потому что она была объявлена последней. За ней взрывается шутиха (<code>firecracker</code>). Первым вошёл, последним вышел.</p>
  <p>Так зачем нужен <code>Drop</code>? Часто <code>Drop</code> используют, чтобы освободить ресурсы, представленные структурой (<code>struct</code>). Например, счётчик ссылок <a href="http://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc&lt;T&gt;</code></a> уменьшает число активных ссылок в <code>drop()</code>, и когда оно достигает нуля, освобождает хранимое значение.</p>
  </section>
  <section id="sec--if-let" class="level2">
  <h2>Конструкция <code>if let</code></h2>
  <p>Иногда хочется сделать определённые вещи менее неуклюже. Например, скомбинировать <code>if</code> и <code>let</code> чтобы более удобно сделать сопоставление с образцом. Для этого есть <code>if let</code>.</p>
  <p>В качестве примера рассмотрим <code>Option&lt;T&gt;</code>. Если это <code>Some&lt;T&gt;</code>, мы хотим вызвать функцию на этом значении, а если это <code>None</code> — не делать ничего. Вроде такого:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">match</span> option {
      <span class="kw">Some</span>(x) =&gt; { foo(x) },
      <span class="kw">None</span> =&gt; {},
  }</code></pre>
  <p>Здесь необязательно использовать <code>match</code>. <code>if</code> тоже подойдёт:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">if</span> option.is_some() {
      <span class="kw">let</span> x = option.unwrap();
      foo(x);
  }</code></pre>
  <p>Но оба этих варианта выглядят странно. Мы можем исправить это с помощью <code>if let</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">if</span> <span class="kw">let</span> <span class="kw">Some</span>(x) = option {
      foo(x);
  }</code></pre>
  <p>Если <a href="#sec--patterns">сопоставление с образцом</a> успешно, имена в образце связываются с соответствующими частями разбираемого значения, и блок исполняется. Если значение не соответствует образцу, ничего не происходит.</p>
  <p>Если вы хотите делать что-то ещё при несовпадении с образцом, используйте <code>else</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">if</span> <span class="kw">let</span> <span class="kw">Some</span>(x) = option {
      foo(x);
  } <span class="kw">else</span> {
      bar();
  }</code></pre>
  <section id="while-let" class="level4">
  <h4><code>while let</code></h4>
  <p>Похожим образом, <code>while let</code> можно использовать для перебора значений, пока они соответствуют образцу. Код вроде такого:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">loop</span> {
      <span class="kw">match</span> option {
          <span class="kw">Some</span>(x) =&gt; <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, x),
          _ =&gt; <span class="kw">break</span>,
      }
  }</code></pre>
  <p>Превращается в такой:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">while</span> <span class="kw">let</span> <span class="kw">Some</span>(x) = option {
      <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, x);
  }</code></pre>
  </section>
  </section>
  <section id="sec--trait-objects" class="level2">
  <h2>Типажи-объекты</h2>
  <p>Когда код включает в себя полиморфизм, то должен быть механизм, чтобы определить, какая конкретная версия будет фактически вызвана. Это называется ‘диспетчеризация.’ Есть две основные формы диспетчеризации: статическая и динамическая. Хотя Rust и отдает предпочтение статической диспетчеризации, он также поддерживает динамическую диспетчеризацию через механизм, называемый ‘типажи-объекты.’</p>
  <section id="подготовка" class="level4">
  <h4>Подготовка</h4>
  <p>Для остальной части этой главы нам потребуется типаж и несколько его реализаций. Давайте создадим простой типаж <code>Foo</code>. Он содержит один метод, который возвращает <code>String</code>.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">trait</span> Foo {
      <span class="kw">fn</span> method(&amp;<span class="kw">self</span>) -&gt; String;
  }</code></pre>
  <p>Также мы реализуем этот типаж для <code>u8</code> и <code>String</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">impl</span> Foo <span class="kw">for</span> <span class="kw">u8</span> {
      <span class="kw">fn</span> method(&amp;<span class="kw">self</span>) -&gt; String { <span class="ot">format!</span>(<span class="st">&quot;u8: {}&quot;</span>, *<span class="kw">self</span>) }
  }
  
  <span class="kw">impl</span> Foo <span class="kw">for</span> String {
      <span class="kw">fn</span> method(&amp;<span class="kw">self</span>) -&gt; String { <span class="ot">format!</span>(<span class="st">&quot;string: {}&quot;</span>, *<span class="kw">self</span>) }
  }</code></pre>
  </section>
  <section id="статическая-диспетчеризация" class="level4">
  <h4>Статическая диспетчеризация</h4>
  <p>Мы можем использовать этот типаж для выполнения статической диспетчеризации с помощью ограничения типажом:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> do_something&lt;T: Foo&gt;(x: T) {
      x.method();
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> x = <span class="dv">5u8</span>;
      <span class="kw">let</span> y = <span class="st">&quot;Hello&quot;</span>.to_string();
  
      do_something(x);
      do_something(y);
  }</code></pre>
  <p>Здесь Rust использует ‘мономорфизацию’ для статической диспетчеризации. Это означает, что Rust создаст специальную версию <code>do_something()</code> для каждого из типов: <code>u8</code> и <code>String</code>, а затем заменит все места вызовов на вызовы этих специализированных функций. Другими словами, Rust сгенерирует нечто вроде этого:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> do_something_u8(x: <span class="kw">u8</span>) {
      x.method();
  }
  
  <span class="kw">fn</span> do_something_string(x: String) {
      x.method();
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> x = <span class="dv">5u8</span>;
      <span class="kw">let</span> y = <span class="st">&quot;Hello&quot;</span>.to_string();
  
      do_something_u8(x);
      do_something_string(y);
  }</code></pre>
  <p>Статическая диспетчеризация имеет большой потенциал: она позволяет вызывать функцию, которая будет встроена, потому что вызываемая версия этой функции известна на этапе компиляции, а встраивание — это ключ к хорошей оптимизации. Статическая диспетчеризация быстра, но это достигается путем компромисса: происходит ‘раздувание кода’ в связи с большим количеством копий одной и той же функции, по одной для каждого типа, расположенных в бинарном файле.</p>
  <p>Кроме того, компиляторы не совершенны и могут «оптимизировать» код так, что он станет медленнее. Например, встроенные функции будут слишком охотно раздувать кэш команд (правила кэширования все вокруг нас). Это одна из причин, по которой <code>#[inline]</code> и <code>#[inline(always)]</code> следует использовать осторожно, и почему использование динамической диспетчеризации иногда более эффективно.</p>
  <p>Тем не менее, в общем случае более эффективно использовать статическую диспетчеризацию. Кроме того, всегда можно иметь тонкую статически- диспетчеризуемую обертку для функции, которая выполняет динамическую диспетчеризацию, но не наоборот. То есть статические вызовы являются более гибкими. По этой причине стандартная библиотека старается быть статически диспетчеризуемой везде, где это возможно.</p>
  </section>
  <section id="динамическая-диспетчеризация" class="level4">
  <h4>Динамическая диспетчеризация</h4>
  <p>Rust обеспечивает динамическую диспетчеризацию через механизм под названием ‘типажи-объекты’. Типажи-объекты, такие как <code>&amp;Foo</code> или <code>Box&lt;Foo&gt;</code>, это обычные переменные, хранящие значения <em>любого</em> типа, реализующего данный типаж. Конкретный тип типажа-объекта может быть определен только на этапе выполнения.</p>
  <p>Типаж-объект может быть получен из указателя на конкретный тип, который реализует этот типаж, путем его <code>явного приведения</code> (например, <code>&amp;x as &amp;Foo</code>) или <code>неявного приведения</code> (например, используя <code>&amp;x</code> в качестве аргумента функции, которая принимает <code>&amp;Foo</code>).</p>
  <p>Явное и неявное приведение типажа-объекта также работает для таких указателей, как <code>&amp;mut T</code> в <code>&amp;mut Foo</code> и <code>Box&lt;T&gt;</code> в <code>Box&lt;Foo&gt;</code>, но это все на данный момент. Явное и неявное приведение идентичны.</p>
  <p>Эта операция может рассматриваться как «затирание» знания компилятора о конкретном типе указателя, поэтому типажи-объекты иногда называют «затиранием типов».</p>
  <p>Возвращаясь к примеру выше, мы можем использовать тот же самый типаж для выполнения динамической диспетчеризации с типажами-объектами путем явного приведения типа:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">
  <span class="kw">fn</span> do_something(x: &amp;Foo) {
      x.method();
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> x = <span class="dv">5u8</span>;
      do_something(&amp;x <span class="kw">as</span> &amp;Foo);
  }</code></pre>
  <p>или неявного приведения типа:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">
  <span class="kw">fn</span> do_something(x: &amp;Foo) {
      x.method();
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> x = <span class="st">&quot;Hello&quot;</span>.to_string();
      do_something(&amp;x);
  }</code></pre>
  <p>Функция, которая принимает типаж-объект, не обладает специализированными копиями для каждого из типов, которые реализуют типаж <code>Foo</code>: генерируется только одна копия. Часто (но не всегда), в результате происходит уменьшение раздувания кода. Тем не менее, это происходит за счет более медленного вызова виртуальных функций, и, по существу, блокирования любой возможности встраивания и связанных с этим оптимизаций.</p>
  <section id="почему-указатели" class="level5">
  <h5>Почему указатели?</h5>
  <p>В отличие от многих управляемых языков, Rust по умолчанию не размещает значения по указателю, так как типы могут иметь различные размеры. Знать размер значения во время компиляции важно прежде всего для выполнения таких задач, как передача значения в качестве аргумента в функцию, что вызывает помещение переданного значения в стек, и выделение (и освобождение) места на куче для сохранения значения там.</p>
  <p>Для <code>Foo</code> допускается иметь значение, которое может быть либо <code>String</code> (24 байт), либо <code>u8</code> (1 байт), либо любой другой тип, для которого в соответствующих крейтах может быть реализован <code>Foo</code> (возможно абсолютно любое число байт). Так как этот другой тип может быть сколь угодно большими, то нет никакого способа, гарантирующего, что последний вариант будет работать, если значения сохраняются без указателя.</p>
  <p>Размещение значения по указателю означает, что, когда мы имеем дело с типажом- объектом, размер самого значения не важен, а важен лишь размер указателя.</p>
  </section>
  <section id="представление" class="level5">
  <h5>Представление</h5>
  <p>Методы типажа можно вызвать для типажа-объекта с помощью специальной записи указателей на функции, традиционно называемой ‘виртуальная таблица’ (‘vtable’) (создается и управляется компилятором).</p>
  <p>Типажи-объекты являются одновременно и простыми и сложными: их основное представление и устройство довольно прямолинейно, но есть некоторые тонкости относительно обнаружения сообщений об ошибках и странного поведения.</p>
  <p>Давайте начнем с простого, с рантайм представления типажа-объекта. Модуль <code>std::raw</code> содержит структуры с макетами, которые являются такими же, как и сложные встроенные типы, <a href="http://doc.rust-lang.org/std/raw/struct.TraitObject.html">в том числе типажи-объекты</a>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">struct</span> TraitObject {
      <span class="kw">pub</span> data: *<span class="kw">mut</span> (),
      <span class="kw">pub</span> vtable: *<span class="kw">mut</span> (),
  }</code></pre>
  <p>То есть типаж-объект, такой как <code>&amp;Foo</code>, состоит из указателя на «данные» и указателя на «виртуальную таблицу».</p>
  <p>Указатель <code>data</code> адресует данные (какого-то неизвестного типа <code>T</code>), которые хранит типаж-объект, а указатель <code>vtable</code> указывает на виртуальную таблицу («таблица виртуальных методов»), которая соответствует реализации <code>Foo</code> для <code>T</code>.</p>
  <p>По существу, виртуальная таблица — это структура указателей на функции, указывающих на конкретный кусок машинного кода для каждого метода в реализации. Вызов метода наподобие <code>trait_object.method()</code> возвращает правильный указатель из виртуальной таблицы, а затем динамически вызывает метод по этому указателю. Например:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> FooVtable {
      destructor: <span class="kw">fn</span>(*<span class="kw">mut</span> ()),
      size: usize,
      align: usize,
      method: <span class="kw">fn</span>(*const ()) -&gt; String,
  }
  
  <span class="co">// u8:</span>
  
  <span class="kw">fn</span> call_method_on_u8(x: *const ()) -&gt; String {
      <span class="co">// компилятор гарантирует, что эта функция вызывается только</span>
      <span class="co">// с `x`, указывающим на u8</span>
      <span class="kw">let</span> byte: &amp;<span class="kw">u8</span> = <span class="kw">unsafe</span> { &amp;*(x <span class="kw">as</span> *const <span class="kw">u8</span>) };
  
      byte.method()
  }
  
  <span class="kw">static</span> Foo_for_u8_vtable: FooVtable = FooVtable {
      destructor: <span class="co">/* магия компилятора */</span>,
      size: <span class="dv">1</span>,
      align: <span class="dv">1</span>,
  
      <span class="co">// преобразование в указатель на функцию</span>
      method: call_method_on_u8 <span class="kw">as</span> <span class="kw">fn</span>(*const ()) -&gt; String,
  };
  
  
  <span class="co">// String:</span>
  
  <span class="kw">fn</span> call_method_on_String(x: *const ()) -&gt; String {
      <span class="co">// компилятор гарантирует, что эта функция вызывается только</span>
      <span class="co">// с `x`, указывающим на String</span>
      <span class="kw">let</span> string: &amp;String = <span class="kw">unsafe</span> { &amp;*(x <span class="kw">as</span> *const String) };
  
      string.method()
  }
  
  <span class="kw">static</span> Foo_for_String_vtable: FooVtable = FooVtable {
      destructor: <span class="co">/* магия компилятора */</span>,
      <span class="co">// значения для 64-битного компьютера, для 32-битного они в 2 раза меньше</span>
      size: <span class="dv">24</span>,
      align: <span class="dv">8</span>,
  
      method: call_method_on_String <span class="kw">as</span> <span class="kw">fn</span>(*const ()) -&gt; String,
  };</code></pre>
  <p>Поле <code>destructor</code> в каждой виртуальной таблице указывает на функцию, которая будет очищать любые ресурсы типа этой виртуальной таблицы, для <code>u8</code> она тривиальна, но для <code>String</code> она будет освобождать память. Это необходимо для владельцев типажей-объектов, таких как <code>Box&lt;Foo&gt;</code>, для которых необходимо очищать выделенную память как для <code>Box</code>, так и для внутреннего типа, когда они выходят из области видимости. Поля <code>size</code> и <code>align</code> хранят размер затёртого типа, и его требования к выравниванию; по существу, они не использовался в момент, так как информация встроенного в деструктор, но будет использоваться в будущем, так как объекты отличительным признакам постепенно становится более гибким.</p>
  <p>Предположим, у нас есть несколько значений, которые реализуют <code>Foo</code>, тогда явный вид создания и использования типажей-объектов <code>Foo</code> может выглядеть примерно как (игнорируются несоответствия типов: в любом случае, они всего лишь указатели):</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> a: String = <span class="st">&quot;foo&quot;</span>.to_string();
  <span class="kw">let</span> x: <span class="kw">u8</span> = <span class="dv">1</span>;
  
  <span class="co">// let b: &amp;Foo = &amp;a;</span>
  <span class="kw">let</span> b = TraitObject {
      <span class="co">// store the data</span>
      data: &amp;a,
      <span class="co">// store the methods</span>
      vtable: &amp;Foo_for_String_vtable
  };
  
  <span class="co">// let y: &amp;Foo = x;</span>
  <span class="kw">let</span> y = TraitObject {
      <span class="co">// store the data</span>
      data: &amp;x,
      <span class="co">// store the methods</span>
      vtable: &amp;Foo_for_u8_vtable
  };
  
  <span class="co">// b.method();</span>
  (b.vtable.method)(b.data);
  
  <span class="co">// y.method();</span>
  (y.vtable.method)(y.data);</code></pre>
  </section>
  </section>
  </section>
  <section id="sec--closures" class="level2">
  <h2>Замыкания</h2>
  <p>Помимо именованных функций Rust предоставляет еще и анонимные функции. Анонимные функции, которые имеют связанное окружение, называются ‘замыкания’. Они так называются потому что они замыкают свое окружение. Как мы увидим далее, Rust имеет реально крутую реализацию замыканий.</p>
  <section id="синтаксис" class="level3">
  <h3>Синтаксис</h3>
  <p>Замыкания выглядят следующим образом:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> plus_one = |x: <span class="kw">i32</span>| x + <span class="dv">1</span>;
  
  <span class="ot">assert_eq!</span>(<span class="dv">2</span>, plus_one(<span class="dv">1</span>));</code></pre>
  <p>Мы создаем связывание, <code>plus_one</code>, и присваиваем ему замыкание. Аргументы замыкания располагаются между двумя символами <code>|</code>, а телом замыкания является выражение, в данном случае: <code>x + 1</code>. Помните, что <code>{ }</code> также является выражением, поэтому тело замыкания может содержать много строк:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> plus_two = |x| {
      <span class="kw">let</span> <span class="kw">mut</span> result: <span class="kw">i32</span> = x;
  
      result += <span class="dv">1</span>;
      result += <span class="dv">1</span>;
  
      result
  };
  
  <span class="ot">assert_eq!</span>(<span class="dv">4</span>, plus_two(<span class="dv">2</span>));</code></pre>
  <p>Обратите внимание, что есть несколько небольших различий между замыканиями и обычными функциями, определенными с помощью <code>fn</code>. Первое отличие состоит в том, что для замыкания мы не должны указывать ни типы аргументов, которые оно принимает, ни тип возвращаемого им значения. Мы можем:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> plus_one = |x: <span class="kw">i32</span>| -&gt; <span class="kw">i32</span> { x + <span class="dv">1</span> };
  
  <span class="ot">assert_eq!</span>(<span class="dv">2</span>, plus_one(<span class="dv">1</span>));</code></pre>
  <p>Но мы не должны. Почему так? В основном, это было сделано из эргономических соображений (соображений удобства). В то время как для именованных функций явное указание типа является полезным для таких аспектов как документация и вывод типа, типы замыканий редко документируют, поскольку они анонимны. К тому же, они не вызывают «ошибок на расстоянии» (error-at-a-distance), которые могут вызывать именованные функции. Такие ошибки могут возникать, когда локальное изменение (например, в теле одной из функций) вызывает изменение вывода типов. Компилятор пытается подобрать типы в окружающей программе под уже другие типы в изменённой функции, и часто оказывается, что имена имеют другие типы, нежели мы ожидали. В результате происходит ошибка «на расстоянии» — возможно, в другой функции, использующей изменённую.</p>
  <p>Второе отличие — синтаксис очень похож, но все же немного отличается. Мы добавили пробелы здесь, чтобы было нагляднее:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span>  plus_one_v1   (x: <span class="kw">i32</span> ) -&gt; <span class="kw">i32</span> { x + <span class="dv">1</span> }
  <span class="kw">let</span> plus_one_v2 = |x: <span class="kw">i32</span> | -&gt; <span class="kw">i32</span> { x + <span class="dv">1</span> };
  <span class="kw">let</span> plus_one_v3 = |x: <span class="kw">i32</span> |          x + <span class="dv">1</span>  ;</code></pre>
  <p>Есть небольшие различия, но принцип аналогичен.</p>
  </section>
  <section id="замыкания-и-их-окружение" class="level3">
  <h3>Замыкания и их окружение</h3>
  <p>Замыкания называются так потому, что они ‘замыкают свое окружение.’ Это выглядит следующим образом:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> num = <span class="dv">5</span>;
  <span class="kw">let</span> plus_num = |x: <span class="kw">i32</span>| x + num;
  
  <span class="ot">assert_eq!</span>(<span class="dv">10</span>, plus_num(<span class="dv">5</span>));</code></pre>
  <p>Это замыкание, <code>plus_num</code>, ссылается на связанную с помощью оператора <code>let</code> переменную <code>num</code>, расположенную в своей области видимости. Если говорить более конкретно, то оно заимствует связывание. Если мы сделаем что-то, что противоречило бы связыванию, то получим ошибку. Например этот код:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> num = <span class="dv">5</span>;
  <span class="kw">let</span> plus_num = |x: <span class="kw">i32</span>| x + num;
  
  <span class="kw">let</span> y = &amp;<span class="kw">mut</span> num;</code></pre>
  <p>Который выдаст следующие ошибки:</p>
  <pre class="text"><code>error: cannot borrow `num` as mutable because it is also borrowed as immutable
      let y = &amp;mut num;
                   ^~~
  note: previous borrow of `num` occurs here due to use in closure; the immutable
    borrow prevents subsequent moves or mutable borrows of `num` until the borrow
    ends
      let plus_num = |x| x + num;
                     ^~~~~~~~~~~
  note: previous borrow ends here
  fn main() {
      let mut num = 5;
      let plus_num = |x| x + num;
      
      let y = &amp;mut num;
  }
  ^</code></pre>
  <p>Подробное и к тому же полезное сообщение об ошибке! Как говорится в этом сообщении, мы не можем получить изменяемый заем переменной <code>num</code> потому что замыкание уже заимствует его. Если же мы обеспечим выход замыкания из области видимости, то мы сможем:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> num = <span class="dv">5</span>;
  {
      <span class="kw">let</span> plus_num = |x: <span class="kw">i32</span>| x + num;
  
  } <span class="co">// plus_num goes out of scope, borrow of num ends</span>
  
  <span class="kw">let</span> y = &amp;<span class="kw">mut</span> num;</code></pre>
  <p>Однако, Rust также может забирать право владения и перемещать свое окружение, если этого требует замыкание:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> nums = <span class="ot">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  
  <span class="kw">let</span> takes_nums = || nums;
  
  <span class="ot">println!</span>(<span class="st">&quot;{:?}&quot;</span>, nums);</code></pre>
  <p>Этот код выдаст:</p>
  <pre class="text"><code>note: `nums` moved into closure environment here because it has type
    `[closure(()) -&gt; collections::vec::Vec&lt;i32&gt;]`, which is non-copyable
  let takes_nums = || nums;
                      ^~~~~~~</code></pre>
  <p><code>Vec&lt;T&gt;</code> обладает правом владения на свое содержимое, и поэтому, когда мы ссылаемся на него в нашем замыкании, мы должны забрать право владения на <code>nums</code>. Это тоже самое, как если бы мы передавали <code>nums</code> в функцию, которая забирала бы право владения на него.</p>
  <section id="перемещающие-замыкания-move-closures" class="level4">
  <h4>Перемещающие замыкания (<code>move</code> closures)</h4>
  <p>Мы можем заставить наше замыкание забирать право владения на свое окружение с помощью ключевого слова <code>move</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> num = <span class="dv">5</span>;
  
  <span class="kw">let</span> owns_num = move |x: <span class="kw">i32</span>| x + num;</code></pre>
  <p>Теперь, когда указано ключевое слово <code>move</code>, переменные следуют нормальной семантике перемещения. В данном примере <code>5</code> реализует <code>Copy</code>, поэтому <code>owns_num</code> становится владельцем копии <code>num</code>. Так в чем же разница?</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> num = <span class="dv">5</span>;
  
  {
      <span class="kw">let</span> <span class="kw">mut</span> add_num = |x: <span class="kw">i32</span>| num += x;
  
      add_num(<span class="dv">5</span>);
  }
  
  <span class="ot">assert_eq!</span>(<span class="dv">10</span>, num);</code></pre>
  <p>Итак, в этом примере наше замыкание принимает изменяемую ссылку на <code>num</code>. Затем, когда мы вызываем замыкание <code>add_num</code>, то, как мы и ожидали, оно изменяет значение внутри. Нам также необходимо объявить <code>add_num</code> как <code>mut</code>, потому что оно изменяет свое окружение.</p>
  <p>Если же мы будем использовать <code>move</code> замыкание, то получим следующие отличия:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> num = <span class="dv">5</span>;
  
  {
      <span class="kw">let</span> <span class="kw">mut</span> add_num = move |x: <span class="kw">i32</span>| num += x;
  
      add_num(<span class="dv">5</span>);
  }
  
  <span class="ot">assert_eq!</span>(<span class="dv">5</span>, num);</code></pre>
  <p>Мы всего лишь получаем <code>5</code>. Вместо того, чтобы получать изменяемый заем на <code>num</code>, мы получаем право владения на копию.</p>
  <p>Вот еще один способ думать о <code>move</code> замыканиях: они предоставляют замыкание со своим собственным фреймом стека. Без <code>move</code> замыкание может быть связано с фреймом стека, который его создал, в то время как <code>move</code> замыкание содержит свой собственный фрейм стека. Это означает, например, что вы не можете вернуть не <code>move</code> замыкание из функции.</p>
  <p>Но прежде чем говорить о получении в качестве аргумента и возвращении замыкания, мы должны поговорить о том, как реализуются замыкания. Как системный язык программирования, Rust дает вам кучу контроля над тем, что делает ваш код, и замыкания не являются исключением.</p>
  </section>
  </section>
  <section id="реализация-замыканий" class="level3">
  <h3>Реализация замыканий</h3>
  <p>Реализация замыканий в Rust немного отличается от других языков. Фактически, она представляет из себя просто синтаксический сахар для типажей. Перед тем как читать дальше, настоятельно рекомендуем изучить главу <a href="#sec--traits">Типажи</a>, а также главу <a href="#sec--trait-objects">Типажи-объекты</a>, в которой говорится о типажах-объектах.</p>
  <p>Изучили? Хорошо.</p>
  <p>Ключ к пониманию того, как замыкания работают изнутри звучит немного странно: использование <code>()</code> для вызова функции, как например <code>foo()</code>, представляет собой перегружаемую операцию. Исходя из этого, все остальное встает на свои места. В Rust мы используем систему типажей для перегрузки операций. Вызов функций не является исключением. Существуют три отдельных типажа для их перегрузки:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">trait</span> Fn&lt;Args&gt; : FnMut&lt;Args&gt; {
      <span class="kw">extern</span> <span class="st">&quot;rust-call&quot;</span> <span class="kw">fn</span> call(&amp;<span class="kw">self</span>, args: Args) -&gt; <span class="kw">Self</span>::Output;
  }
  
  <span class="kw">pub</span> <span class="kw">trait</span> FnMut&lt;Args&gt; : FnOnce&lt;Args&gt; {
      <span class="kw">extern</span> <span class="st">&quot;rust-call&quot;</span> <span class="kw">fn</span> call_mut(&amp;<span class="kw">mut</span> <span class="kw">self</span>, args: Args) -&gt; <span class="kw">Self</span>::Output;
  }
  
  <span class="kw">pub</span> <span class="kw">trait</span> FnOnce&lt;Args&gt; {
      <span class="kw">type</span> Output;
  
      extern &quot;rust-call&quot; fn call_once(self, args: Args) -&gt; Self::Output;
  }</code></pre>
  <p>Вы можете заметить некоторые различия между этими типажами, но есть одно главное различие — <code>self</code>: <code>Fn</code> принимает <code>&amp;self</code>, <code>FnMut</code> принимает <code>&amp;mut self</code>, <code>FnOnce</code> принимает <code>self</code>. Это покрывает все три вида <code>self</code> с помощью обычного синтаксиса вызова методов. Мы разделили их на три типажа, вместо того, чтобы иметь один. Это дает нам большее количество контроля над тем, какого вида замыкания мы можем принять.</p>
  <p>Использование <code>|| {}</code> при создании замыканий является синтаксическим сахаром для этих трех типажей. Rust будет генерировать структуру для окружения, реализующую (<code>impl</code>) соответствующий типаж, а затем использовать его.</p>
  </section>
  <section id="передача-замыканий-в-качестве-аргументов" class="level3">
  <h3>Передача замыканий в качестве аргументов</h3>
  <p>Теперь, когда мы знаем, что замыкания являются типажами, получается, что мы уже знаем, как принимать и возвращать замыкания: как и любой другой типаж!</p>
  <p>Это также означает, что мы можем выбирать между статической и динамической диспетчеризацией. Во-первых, давайте напишем функцию, которая принимает что-то вызываемое, вызывает это что-то и возвращает результат:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> call_with_one&lt;F&gt;(some_closure: F) -&gt; <span class="kw">i32</span>
      where F : Fn(<span class="kw">i32</span>) -&gt; <span class="kw">i32</span> {
  
      some_closure(<span class="dv">1</span>)
  }
  
  <span class="kw">let</span> answer = call_with_one(|x| x + <span class="dv">2</span>);
  
  <span class="ot">assert_eq!</span>(<span class="dv">3</span>, answer);</code></pre>
  <p>Мы передаем наше замыкание <code>|x| x + 2</code>, в функцию <code>call_with_one</code>. Она же делает то, о чем говорит ее название: вызывает замыкание, передавая ему <code>1</code> в качестве аргумента.</p>
  <p>Давайте рассмотрим сигнатуру функции <code>call_with_one</code> более подробно:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> call_with_one&lt;F&gt;(some_closure: F) -&gt; <span class="kw">i32</span></code></pre>
  <p>Мы принимаем один параметр, который имеет тип <code>F</code>. Мы также возвращаем <code>i32</code>. Эта часть не интересна. Следующим важным моментом является:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">    where F : Fn(<span class="kw">i32</span>) -&gt; <span class="kw">i32</span> {</code></pre>
  <p>Так как <code>Fn</code> является типажом, мы можем связать с ним наш обобщенный параметр. В этом примере, замыкание принимает <code>i32</code> в качестве аргумента и возвращает <code>i32</code>, поэтому связывание, которое мы используем, выглядит так: <code>Fn(i32) -&gt; i32</code>.</p>
  <p>Здесь есть еще один ключевой момент: так как мы ограничиваем обобщённый параметр с помощью типажа, то будет применена мономорфизация, и поэтому в замыкании будет использоваться статическая диспетчеризация. Это довольно лаконично (аккуратно). Во многих языках для замыканий по существу используется выделение памяти в куче, и поэтому всегда будет использоваться динамическая диспетчеризация. В Rust мы можем выделить память для окружения замыкания в стеке и использовать статическую диспетчеризацию вызова. Это случается довольно часто с итераторами и их адаптерами, которые нередко принимают замыкания в качестве аргументов.</p>
  <p>Конечно, если нам нужна динамическая диспетчеризация, мы также можем использовать и ее. Обычно для этого случая используется типаж-объект:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> call_with_one(some_closure: &amp;Fn(<span class="kw">i32</span>) -&gt; <span class="kw">i32</span>) -&gt; <span class="kw">i32</span> {
      some_closure(<span class="dv">1</span>)
  }
  
  <span class="kw">let</span> answer = call_with_one(&amp;|x| x + <span class="dv">2</span>);
  
  <span class="ot">assert_eq!</span>(<span class="dv">3</span>, answer);</code></pre>
  <p>Теперь наша функция в качетве аргумента принимает типаж-объект <code>&amp;Fn</code>. Поэтому мы должны создать ссылку на замыкание а затем передать ее в функцию <code>call_with_one</code>, для этого мы используем <code>&amp;||</code>.</p>
  </section>
  <section id="возврат-замыканий" class="level3">
  <h3>Возврат замыканий</h3>
  <p>Что очень характерно для кода в функциональном стиле — возвращать замыкания в различных ситуациях. Если вы попытаетесь вернуть замыкание, то можете столкнуться с ошибкой. Сперва это может показаться странным, но мы с этим разберемся. Вот как вы, наверное, попытаетесь вернуть замыкание из функции:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> factory() -&gt; (Fn(<span class="kw">i32</span>) -&gt; <span class="kw">i32</span>) {
      <span class="kw">let</span> num = <span class="dv">5</span>;
  
      |x| x + num
  }
  
  <span class="kw">let</span> f = factory();
  
  <span class="kw">let</span> answer = f(<span class="dv">1</span>);
  <span class="ot">assert_eq!</span>(<span class="dv">6</span>, answer);</code></pre>
  <p>Это выдаст следующие длинные, взаимосвязанные ошибки:</p>
  <pre class="text"><code>error: the trait `core::marker::Sized` is not implemented for the type
  `core::ops::Fn(i32) -&gt; i32` [E0277]
  fn factory() -&gt; (Fn(i32) -&gt; i32) {
                  ^~~~~~~~~~~~~~~~
  note: `core::ops::Fn(i32) -&gt; i32` does not have a constant size known at compile-time
  fn factory() -&gt; (Fn(i32) -&gt; i32) {
                  ^~~~~~~~~~~~~~~~
  error: the trait `core::marker::Sized` is not implemented for the type `core::ops::Fn(
  ↳ i32) -&gt; i32` [E0277]
  let f = factory();
      ^
  note: `core::ops::Fn(i32) -&gt; i32` does not have a constant size known at compile-time
  let f = factory();
      ^</code></pre>
  <p>Для того чтобы вернуть что-то из функции, Rust должен знать, какой размер имеет тип возвращаемого значения. Но так как <code>Fn</code> является типажом, то в качестве него могут выступать совершенно разные объекты, с разными размерами: много различных типов могут реализовать <code>Fn</code>. Самый простой способ передать что-то неопределенного размера — передать ссылку на это что-то, так как ссылки имеют известный размер. Таким образом, следовало бы написать так:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> factory() -&gt; &amp;(Fn(<span class="kw">i32</span>) -&gt; <span class="kw">i32</span>) {
      <span class="kw">let</span> num = <span class="dv">5</span>;
  
      |x| x + num
  }
  
  <span class="kw">let</span> f = factory();
  
  <span class="kw">let</span> answer = f(<span class="dv">1</span>);
  <span class="ot">assert_eq!</span>(<span class="dv">6</span>, answer);</code></pre>
  <p>Но тогда мы получим другую ошибку:</p>
  <pre class="text"><code>error: missing lifetime specifier [E0106]
  fn factory() -&gt; &amp;(Fn(i32) -&gt; i32) {
                  ^~~~~~~~~~~~~~~~~</code></pre>
  <p>Верно. Так как у нас используется ссылка, то мы должны задать ее время жизни. Так наша функция <code>factory()</code> не принимает никаких аргументов, то элизия (сокрытие) здесь не уместна. Какое время жизни мы должны выбрать? <code>'static</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> factory() -&gt; &amp;<span class="ot">'static</span> (Fn(<span class="kw">i32</span>) -&gt; <span class="kw">i32</span>) {
      <span class="kw">let</span> num = <span class="dv">5</span>;
  
      |x| x + num
  }
  
  <span class="kw">let</span> f = factory();
  
  <span class="kw">let</span> answer = f(<span class="dv">1</span>);
  <span class="ot">assert_eq!</span>(<span class="dv">6</span>, answer);</code></pre>
  <p>Но мы получим еще ошибку:</p>
  <pre class="text"><code>error: mismatched types:
   expected `&amp;'static core::ops::Fn(i32) -&gt; i32`,
      found `[closure &lt;anon&gt;:7:9: 7:20]`
  (expected &amp;-ptr,
      found closure) [E0308]
           |x| x + num
           ^~~~~~~~~~~
  </code></pre>
  <p>Эта ошибка сообщает нам, что ожидается использование <code>&amp;'static Fn(i32) -&gt; i32</code>, а используется <code>[closure &lt;anon&gt;:7:9: 7:20]</code>. Подождите, что?</p>
  <p>Поскольку каждое замыкание (в индивидуальном порядке) генерирует свою собственную <code>struct</code> для окружения и реализует <code>Fn</code> и компанию, то эти типы являются анонимными. Они существуют исключительно для этого замыкания. Поэтому Rust показывает их как <code>closure &lt;anon&gt;</code>, а не в виде какого-то автоматически сгенерированного имени.</p>
  <p>Но почему же наше замыкание не реализует <code>&amp;'static Fn</code>? Как мы обсуждали ранее, замыкание заимствует свое окружение. И в этом случае наше окружение представляет собой выделеную в стеке память, содержащую значение связанной переменной <code>num</code> - <code>5</code>. Из-за этого заем имеет срок жизни фрейма стека. Так что, когда мы вернем это замыкание, то вызов функции будет завершен, а фрейм стека уйдет, и наше замыкание захватит окружение, содержащее в памяти мусор!</p>
  <p>Так что же делать? Этот код <em>почти</em> работает:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> factory() -&gt; Box&lt;Fn(<span class="kw">i32</span>) -&gt; <span class="kw">i32</span>&gt; {
      <span class="kw">let</span> num = <span class="dv">5</span>;
  
      Box::new(|x| x + num)
  }
  <span class="kw">let</span> f = factory();
  
  <span class="kw">let</span> answer = f(<span class="dv">1</span>);
  <span class="ot">assert_eq!</span>(<span class="dv">6</span>, answer);</code></pre>
  <p>Мы используем типаж-объект, полученный в результате упаковки (<code>Box</code>) типажа <code>Fn</code>. И остаётся только одна, последняя проблема:</p>
  <pre class="text"><code>error: closure may outlive the current function, but it borrows `num`,
  which is owned by the current function [E0373]
  Box::new(|x| x + num)
           ^~~~~~~~~~~</code></pre>
  <p>Мы все еще по-прежнему ссылаемся на родительский фрейм стека. С этим последним исправлением мы сможем наконец выполнить нашу задачу:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> factory() -&gt; Box&lt;Fn(<span class="kw">i32</span>) -&gt; <span class="kw">i32</span>&gt; {
      <span class="kw">let</span> num = <span class="dv">5</span>;
  
      Box::new(move |x| x + num)
  }
  <span class="kw">let</span> f = factory();
  
  <span class="kw">let</span> answer = f(<span class="dv">1</span>);
  <span class="ot">assert_eq!</span>(<span class="dv">6</span>, answer);</code></pre>
  <p>Благодаря изменению внутреннего замыкания на <code>move Fn</code> будет создаваться новый фрейм стека для нашего замыкания. А благодаря упаковке (<code>Box</code>) замыкания, получается известный размер возвращаемого значения, и позволяет ему избежать (быть независимым от) нашего фрейма стека.</p>
  </section>
  </section>
  <section id="sec--ufcs" class="level2">
  <h2>Универсальный синтаксис вызова функций (UFCS)</h2>
  <p>Иногда, функции могут иметь одинаковые имена. Рассмотрим этот код:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">trait</span> Foo {
      <span class="kw">fn</span> f(&amp;<span class="kw">self</span>);
  }
  
  <span class="kw">trait</span> Bar {
      <span class="kw">fn</span> f(&amp;<span class="kw">self</span>);
  }
  
  <span class="kw">struct</span> Baz;
  
  <span class="kw">impl</span> Foo <span class="kw">for</span> Baz {
      <span class="kw">fn</span> f(&amp;<span class="kw">self</span>) { <span class="ot">println!</span>(<span class="st">&quot;Baz’s impl of Foo&quot;</span>); }
  }
  
  <span class="kw">impl</span> Bar <span class="kw">for</span> Baz {
      <span class="kw">fn</span> f(&amp;<span class="kw">self</span>) { <span class="ot">println!</span>(<span class="st">&quot;Baz’s impl of Bar&quot;</span>); }
  }
  
  <span class="kw">let</span> b = Baz;</code></pre>
  <p>Если мы попытаемся вызвать <code>b.f()</code>, то получим ошибку:</p>
  <pre class="text"><code>error: multiple applicable methods in scope [E0034]
  b.f();
    ^~~
  note: candidate #1 is defined in an impl of the trait `main::Foo` for the type
  `main::Baz`
      fn f(&amp;self) { println!(&quot;Baz’s impl of Foo&quot;); }
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  note: candidate #2 is defined in an impl of the trait `main::Bar` for the type
  `main::Baz`
      fn f(&amp;self) { println!(&quot;Baz’s impl of Bar&quot;); }
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  </code></pre>
  <p>Нам нужен способ указать, какой конкретно метод нужен, чтобы устранить неоднозначность. Эта возможность называется «универсальный синтаксис вызова функций», и выглядит это так:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">Foo::f(&amp;b);
  Bar::f(&amp;b);</code></pre>
  <p>Давайте разберемся.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">Foo::
  Bar::</code></pre>
  <p>Эти части вызова задают один из двух видов типажей: <code>Foo</code> и <code>Bar</code>. Это то, что на самом деле устраняет неоднозначность между двумя методами: Rust вызывает метод того типажа, имя которого вы используете.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">f(&amp;b)</code></pre>
  <p>Когда мы вызываем метод, используя <a href="#sec--method-syntax">синтаксис вызова метода</a>, как например <code>b.f()</code>, Rust автоматически заимствует <code>b</code>, если <code>f()</code> принимает в качестве аргумента <code>&amp;self</code>. В этом же случае, Rust не будет использовать автоматическое заимствование, и поэтому мы должны явно передать <code>&amp;b</code>.</p>
  <section id="форма-с-угловыми-скобками" class="level3">
  <h3>Форма с угловыми скобками</h3>
  <p>Форма UFCS, о которой мы только что говорили:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">Trait::method(args);</code></pre>
  <p>Это сокращенная форма записи. Ниже представлена расширенная форма записи, которая требуется в некоторых ситуациях:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">&lt;Type <span class="kw">as</span> Trait&gt;::method(args);</code></pre>
  <p>Синтаксис <code>&lt;&gt;::</code> является средством предоставления подсказки типа. Тип располагается внутри <code>&lt;&gt;</code>. В этом случае типом является <code>Type as Trait</code>, указывающий, что мы хотим здесь вызвать <code>Trait</code> версию метода. Часть <code>as Trait</code> является необязательной, если вызов не является неоднозначным. То же самое что с угловыми скобками, отсюда и короткая форма.</p>
  <p>Вот пример использования длинной формы записи.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">trait</span> Foo {
      <span class="kw">fn</span> clone(&amp;<span class="kw">self</span>);
  }
  
  <span class="ot">#[</span>derive<span class="ot">(</span>Clone<span class="ot">)]</span>
  <span class="kw">struct</span> Bar;
  
  <span class="kw">impl</span> Foo <span class="kw">for</span> Bar {
      <span class="kw">fn</span> clone(&amp;<span class="kw">self</span>) {
          <span class="ot">println!</span>(<span class="st">&quot;Making a clone of Bar&quot;</span>);
  
          &lt;Bar <span class="kw">as</span> Clone&gt;::clone(<span class="kw">self</span>);
      }
  }</code></pre>
  <p>Этот код вызывает метод <code>clone()</code> типажа <code>Clone</code>, а не типажа <code>Foo</code>.</p>
  </section>
  </section>
  <section id="sec--crates-and-modules" class="level2">
  <h2>Контейнеры (crates) и модули (modules)</h2>
  <p>Когда проект начинает разрастаться, то хорошей практикой разработки программного обеспечения считается: разбить его на небольшие кусочки, а затем собрать их вместе. Также важно иметь четко определенный интерфейс, так как часть вашей функциональности является приватной, а часть — публичной. Для облегчения такого рода вещей Rust обладает модульной системой.</p>
  <section id="основные-термины-контейнеры-и-модули" class="level3">
  <h3>Основные термины: контейнеры и модули</h3>
  <p>Rust имеет два различных термина, которые относятся к модульной системе: <em>контейнер</em> и <em>модуль</em>. Контейнер — это синоним <em>библиотеки</em> или <em>пакета</em> на других языках. Именно поэтому инструмент управления пакетами в Rust называется Cargo: вы пересылаете ваши контейнеры другим с помощью Cargo. Контейнеры могут производить исполняемый файл или библиотеку, в зависимости от проекта.</p>
  <p>Каждый контейнер имеет неявный <em>корневой модуль</em>, содержащий код для этого контейнера. В рамках этого базового модуля можно определить дерево суб-модулей. Модули позволяют разделить ваш код внутри контейнера.</p>
  <p>В качестве примера, давайте сделаем контейнер <em>phrases</em>, который выдает нам различные фразы на разных языках. Чтобы не усложнять пример, мы будем использовать два вида фраз: «greetings» и «farewells», и два языка для этих фраз: английский и японский (日本語). Мы будем использовать следующий шаблон модуля:</p>
  <pre class="text"><code>                                    +-----------+
                                  +---| greetings |
                                  |   +-----------+
                    +---------+   |
                +---| english |---+
                |   +---------+   |   +-----------+
                |                 +---| farewells |
  +---------+   |                     +-----------+
  | phrases |---+
  +---------+   |                     +-----------+
                |                 +---| greetings |
                |   +----------+  |   +-----------+
                +---| japanese |--+
                    +----------+  |
                                  |   +-----------+
                                  +---| farewells |
                                      +-----------+</code></pre>
  <p>В этом примере, <code>phrases</code> — это название нашего контейнера. Все остальное - модули. Вы можете видеть, что они образуют дерево, в основании которого располагается <em>корень</em> контейнера — <code>phrases</code>.</p>
  <p>Теперь, когда у нас есть схема, давайте определим модули в коде. Для начала создайте новый контейнер с помощью Cargo:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> new phrases
  $ <span class="kw">cd</span> phrases</code></pre>
  <p>Если вы помните, то эта команда создает простой проект:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">tree</span> .
  <span class="kw">.</span>
  ├── <span class="kw">Cargo.toml</span>
  └── <span class="kw">src</span>
      └── <span class="kw">lib.rs</span>
  
  <span class="kw">1</span> directory, 2 files</code></pre>
  <p><code>src/lib.rs</code> — корень нашего контейнера, соответствующий <code>phrases</code> в нашей диаграмме выше.</p>
  </section>
  <section id="объявление-модулей" class="level3">
  <h3>Объявление модулей</h3>
  <p>Для объявления каждого из наших модулей, мы используем ключевое слово <code>mod</code>. Давайте сделаем, чтобы наш <code>src/lib.rs</code> выглядел следующим образом:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">mod</span> english {
      <span class="kw">mod</span> greetings {
      }
  
      <span class="kw">mod</span> farewells {
      }
  }
  
  <span class="kw">mod</span> japanese {
      <span class="kw">mod</span> greetings {
      }
  
      <span class="kw">mod</span> farewells {
      }
  }</code></pre>
  <p>После ключевого слова <code>mod</code>, вы задаете имя модуля. Имена модулей следуют соглашениям, как и другие идентификаторы Rust: <code>lower_snake_case</code>. Содержание каждого модуля обрамляется в фигурные скобки (<code>{}</code>).</p>
  <p>Внутри <code>mod</code> вы можете объявить суб-<code>mod</code>. Мы можем обращаться к суб-модулям с помощью нотации (<code>::</code>). Так выглядят обращения к нашим четырем вложенным модулям: <code>english::greetings</code>, <code>english::farewells</code>, <code>japanese::greetings</code> и <code>japanese::farewells</code>. Так как суб-модули располагаются в пространстве имен своих родительских модулей, то суб-модули <code>english::greetings</code> и <code>japanese::greetings</code> не конфликтуют, несмотря на то, что они имеют одинаковые имена, <code>greetings</code>.</p>
  <p>Так как в этом контейнере нет функции <code>main()</code>, и называется он <code>lib.rs</code>, Cargo соберет этот контейнер в виде библиотеки:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> build
     <span class="kw">Compiling</span> phrases v0.0.1 (file:///home/you/projects/phrases)
  $ <span class="kw">ls</span> target/debug
  <span class="kw">build</span>  deps  examples  libphrases-a7448e02a0468eaa.rlib  native</code></pre>
  <p><code>libphrase-hash.rlib</code> — это скомпилированный контейнер. Прежде чем мы рассмотрим, как его можно использовать из другого контейнера, давайте разобьем его на несколько файлов.</p>
  </section>
  <section id="контейнеры-с-несколькими-файлами" class="level3">
  <h3>Контейнеры с несколькими файлами</h3>
  <p>Если бы каждый контейнер мог состоять только из одного файла, тогда этот файл был бы очень большими. Зачастую легче разделить контейнер на несколько файлов, и Rust поддерживает это двумя способами.</p>
  <p>Вместо объявления модуля наподобие:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">mod</span> english {
      <span class="co">// contents of our module go here</span>
  }</code></pre>
  <p>Мы можем объявить наш модуль в виде:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">mod</span> english;</code></pre>
  <p>Если мы это сделаем, то Rust будет ожидать, что найдет либо файл <code>english.rs</code>, либо файл <code>english/mod.rs</code> с содержимым нашего модуля.</p>
  <p>Обратите внимание, что в этих файлах вам не требуется заново объявлять модуль: это уже сделано при изначальном объявлении <code>mod</code>.</p>
  <p>С помощью этих двух приемов мы можем разбить наш контейнер на две директории и семь файлов:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">tree</span> .
  <span class="kw">.</span>
  ├── <span class="kw">Cargo.lock</span>
  ├── <span class="kw">Cargo.toml</span>
  ├── <span class="kw">src</span>
  │   ├── <span class="kw">english</span>
  │   │   ├── <span class="kw">farewells.rs</span>
  │   │   ├── <span class="kw">greetings.rs</span>
  │   │   └── <span class="kw">mod.rs</span>
  │   ├── <span class="kw">japanese</span>
  │   │   ├── <span class="kw">farewells.rs</span>
  │   │   ├── <span class="kw">greetings.rs</span>
  │   │   └── <span class="kw">mod.rs</span>
  │   └── <span class="kw">lib.rs</span>
  └── <span class="kw">target</span>
      └── <span class="kw">debug</span>
          ├── <span class="kw">build</span>
          ├── <span class="kw">deps</span>
          ├── <span class="kw">examples</span>
          ├── <span class="kw">libphrases-a7448e02a0468eaa.rlib</span>
          └── <span class="kw">native</span></code></pre>
  <p><code>src/lib.rs</code> — корень нашего контейнера, и выглядит он следующим образом:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">mod</span> english;
  <span class="kw">mod</span> japanese;</code></pre>
  <p>Эти два объявления информируют Rust, что следует искать: <code>src/english.rs</code> или <code>src/english/mod.rs</code>, <code>src/japanese.rs</code> или <code>src/japanese/mod.rs</code>, в зависимости от нашей структуры. В данном примере мы выбрали второй вариант из-за того, что наши модули содержат суб-модули. И <code>src/english/mod.rs</code> и <code>src/japanese/mod.rs</code> выглядят следующим образом:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">mod</span> greetings;
  <span class="kw">mod</span> farewells;</code></pre>
  <p>В свою очередь, эти объявления информируют Rust, что следует искать: <code>src/english/greetings.rs</code>, <code>src/japanese/greetings.rs</code>, <code>src/english/farewells.rs</code>, <code>src/japanese/farewells.rs</code> или <code>src/english/greetings/mod.rs</code>, <code>src/japanese/greetings/mod.rs</code>, <code>src/english/farewells/mod.rs</code>, <code>src/japanese/farewells/mod.rs</code>. Так как эти суб-модули не содержат свои собственные суб-модули, то мы выбрали <code>src/english/greetings.rs</code> и <code>src/japanese/farewells.rs</code>. Вот так!</p>
  <p>Содержание <code>src/english/greetings.rs</code> и <code>src/japanese/farewells.rs</code> являются пустыми на данный момент. Давайте добавим несколько функций.</p>
  <p>Поместите следующий код в <code>src/english/greetings.rs</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> hello() -&gt; String {
      <span class="st">&quot;Hello!&quot;</span>.to_string()
  }</code></pre>
  <p>Следующий код в <code>src/english/farewells.rs</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> goodbye() -&gt; String {
      <span class="st">&quot;Goodbye.&quot;</span>.to_string()
  }</code></pre>
  <p>Следующий код в <code>src/japanese/greetings.rs</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> hello() -&gt; String {
      <span class="st">&quot;こんにちは&quot;</span>.to_string()
  }</code></pre>
  <p>Конечно, вы можете скопировать и вставить этот код с этой страницы, или просто напечатать что-нибудь еще. Вам совершенно не обязательно знать, что на японском языке написано «Konnichiwa», чтобы понять как работает модульная система.</p>
  <p>Поместите следующий код в <code>src/japanese/farewells.rs</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> goodbye() -&gt; String {
      <span class="st">&quot;さようなら&quot;</span>.to_string()
  }</code></pre>
  <p>(Это «Sayonara», если вам интересно.)</p>
  <p>Теперь у нас есть некоторая функциональность в нашем контейнере, давайте попробуем использовать его из другого контейнера.</p>
  </section>
  <section id="импорт-внешних-контейнеров" class="level3">
  <h3>Импорт внешних контейнеров</h3>
  <p>У нас есть библиотечный контейнер. Давайте создадим исполняемый контейнер, который импортирует и использует нашу библиотеку.</p>
  <p>Создайте файл <code>src/main.rs</code> и положите в него следующее: (при этом он не будет компилироваться)</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> crate phrases;
  
  <span class="kw">fn</span> main() {
      <span class="ot">println!</span>(<span class="st">&quot;Hello in English: {}&quot;</span>, phrases::english::greetings::hello());
      <span class="ot">println!</span>(<span class="st">&quot;Goodbye in English: {}&quot;</span>, phrases::english::farewells::goodbye());
  
      <span class="ot">println!</span>(<span class="st">&quot;Hello in Japanese: {}&quot;</span>, phrases::japanese::greetings::hello());
      <span class="ot">println!</span>(<span class="st">&quot;Goodbye in Japanese: {}&quot;</span>, phrases::japanese::farewells::goodbye());
  }</code></pre>
  <p>Объявление <code>extern crate</code> информирует Rust о том, что для компиляции и компоновки кода нам нужен контейнер <code>phrases</code>. После этого объявление мы можем использовать модули контейнера <code>phrases</code>. Как мы уже упоминали ранее, вы можете использовать два подряд идущих символа двоеточия для обращения к суб-модулям и функциям внутри них.</p>
  <p>Кроме того, Cargo предполагает, что <code>src/main.rs</code> — это корень бинарного, а не библиотечного контейнера. Теперь наш пакет содержит два контейнера: <code>src/lib.rs</code> и <code>src/main.rs</code>. Этот шаблон является довольно распространенным для исполняемых контейнеров: основная функциональность сосредоточена в библиотечном контейнере, а исполняемый контейнер использует эту библиотеку. Таким образом, другие программы также могут использовать библиотечный контейнер, к тому же такой подход обеспечивает отделение интереса (разделение функциональности).</p>
  <p>Хотя этот код все еще не работает. Мы получаем четыре ошибки, которые выглядят примерно так:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> build
     <span class="kw">Compiling</span> phrases v0.0.1 (file:///home/you/projects/phrases)
  <span class="kw">src</span>/main.rs:<span class="kw">4</span>:38: 4:72 error: function <span class="kw">`hello`</span> is private
  <span class="kw">src</span>/main.rs:<span class="kw">4</span>     println!(<span class="st">&quot;Hello in English: {}&quot;</span>, phrases::english::greetings::hello(
  ↳ ));
                                                     ^<span class="kw">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
  <span class="kw">note</span>: in expansion of format_args!
  <span class="kw">&lt;std</span> macros<span class="kw">&gt;</span>:2:25: 2:58 note: expansion site
  <span class="kw">&lt;std</span> macros<span class="kw">&gt;</span>:1:1: 2:62 note: in expansion of print!
  <span class="kw">&lt;std</span> macros<span class="kw">&gt;</span>:3:1: 3:54 note: expansion site
  <span class="kw">&lt;std</span> macros<span class="kw">&gt;</span>:1:1: 3:58 note: in expansion of println!
  <span class="kw">phrases/src</span>/main.rs:<span class="kw">4</span>:5: 4:76 note: expansion site</code></pre>
  <p>По умолчанию все элементы в Rust являются приватными. Давайте поговорим об этом более подробно.</p>
  </section>
  <section id="экспорт-публичных-интерфейсов" class="level3">
  <h3>Экспорт публичных интерфейсов</h3>
  <p>Rust позволяет точно контролировать, какие элементы вашего интерфейса являются публичными, и поэтому по умолчанию все элементы являются приватными. Чтобы сделать элементы публичными, вы используете ключевое слово <code>pub</code>. Давайте сначала сосредоточимся на модуле <code>english</code>, для чего сократим файл <code>src/main.rs</code> до этого:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> crate phrases;
  
  <span class="kw">fn</span> main() {
      <span class="ot">println!</span>(<span class="st">&quot;Hello in English: {}&quot;</span>, phrases::english::greetings::hello());
      <span class="ot">println!</span>(<span class="st">&quot;Goodbye in English: {}&quot;</span>, phrases::english::farewells::goodbye());
  }</code></pre>
  <p>В файле <code>src/lib.rs</code> в объявлении модуля <code>english</code> давайте добавим модификатор <code>pub</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">mod</span> english;
  <span class="kw">mod</span> japanese;</code></pre>
  <p>В файле <code>src/english/mod.rs</code> давайте сделаем оба модуля с модификатором <code>pub</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">mod</span> greetings;
  <span class="kw">pub</span> <span class="kw">mod</span> farewells;</code></pre>
  <p>В файле <code>src/english/greetings.rs</code> давайте добавим модификатор <code>pub</code> к объявлению нашей функции <code>fn</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">fn</span> hello() -&gt; String {
      <span class="st">&quot;Hello!&quot;</span>.to_string()
  }</code></pre>
  <p>А также в файле <code>src/english/farewells.rs</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">fn</span> goodbye() -&gt; String {
      <span class="st">&quot;Goodbye.&quot;</span>.to_string()
  }</code></pre>
  <p>Теперь наши контейнеры компилируются, хотя и с предупреждениями о том, что функции в модуле <code>japanese</code> не используются:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> run
     <span class="kw">Compiling</span> phrases v0.0.1 (file:///home/you/projects/phrases)
  <span class="kw">src/japanese</span>/greetings.rs:<span class="kw">1</span>:1: 3:2 warning: function is never used: <span class="kw">`hello`</span>, <span class="co">#[warn(de</span>
  ↳ <span class="kw">ad_code</span>)] <span class="kw">on</span> by default
  <span class="kw">src/japanese</span>/greetings.rs:<span class="kw">1</span> fn hello() <span class="kw">-&gt;</span> String {
  src/japanese/greetings.rs:2     <span class="st">&quot;こんにちは&quot;</span><span class="kw">.to_string</span>()
  <span class="kw">src/japanese</span>/greetings.rs:<span class="kw">3</span> }
  <span class="kw">src/japanese</span>/farewells.rs:<span class="kw">1</span>:1: 3:2 warning: function is never used: <span class="kw">`goodbye`</span>, <span class="co">#[warn(</span>
  ↳ <span class="kw">dead_code</span>)] <span class="kw">on</span> by default
  <span class="kw">src/japanese</span>/farewells.rs:<span class="kw">1</span> fn goodbye() <span class="kw">-&gt;</span> String {
  src/japanese/farewells.rs:2     <span class="st">&quot;さようなら&quot;</span><span class="kw">.to_string</span>()
  <span class="kw">src/japanese</span>/farewells.rs:<span class="kw">3</span> }
       <span class="kw">Running</span> <span class="kw">`target/debug/phrases`</span>
  <span class="kw">Hello</span> in English: Hello!
  <span class="kw">Goodbye</span> in English: Goodbye.</code></pre>
  <p>Теперь, когда функции являются публичными, мы можем их использовать. Отлично! Тем не менее, написание <code>phrases::english::greetings::hello()</code> является очень длинным и неудобным. Rust предоставляет другое ключевое слово, для импорта имен в текущую область, чтобы для обращения можно было использовать короткие имена. Давайте поговорим об этом ключевом слове, <code>use</code>.</p>
  </section>
  <section id="импорт-модулей-с-помощью-use" class="level3">
  <h3>Импорт модулей с помощью <code>use</code></h3>
  <p>Rust предоставляет ключевое слово <code>use</code>, которое позволяет импортировать имена в нашу локальную область видимости. Давайте изменим файл <code>src/main.rs</code>, чтобы он выглядел следующим образом:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> crate phrases;
  
  <span class="kw">use</span> phrases::english::greetings;
  <span class="kw">use</span> phrases::english::farewells;
  
  <span class="kw">fn</span> main() {
      <span class="ot">println!</span>(<span class="st">&quot;Hello in English: {}&quot;</span>, greetings::hello());
      <span class="ot">println!</span>(<span class="st">&quot;Goodbye in English: {}&quot;</span>, farewells::goodbye());
  }</code></pre>
  <p>Две строки, начинающиеся с <code>use</code>, импортируют соответствующие модули в локальную область видимости, поэтому мы можем обратиться к функциям по гораздо более коротким именам. По соглашению, при импорте функции, лучшей практикой считается импортировать модуль, а не функцию непосредственно. Другими словами, вы <em>могли бы</em> сделать следующее:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> crate phrases;
  
  <span class="kw">use</span> phrases::english::greetings::hello;
  <span class="kw">use</span> phrases::english::farewells::goodbye;
  
  <span class="kw">fn</span> main() {
      <span class="ot">println!</span>(<span class="st">&quot;Hello in English: {}&quot;</span>, hello());
      <span class="ot">println!</span>(<span class="st">&quot;Goodbye in English: {}&quot;</span>, goodbye());
  }</code></pre>
  <p>Но такой подход не является идиоматическим. Он значительно чаще приводит к конфликту имен. Для нашей короткой программы это не так важно, но, как только программа разрастается, это становится проблемой. Если у нас возникает конфликт имен, то Rust выдает ошибку компиляции. Например, если мы сделаем функции <code>japanese</code> публичными, и пытаемся скомпилировать этот код:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> crate phrases;
  
  <span class="kw">use</span> phrases::english::greetings::hello;
  <span class="kw">use</span> phrases::japanese::greetings::hello;
  
  <span class="kw">fn</span> main() {
      <span class="ot">println!</span>(<span class="st">&quot;Hello in English: {}&quot;</span>, hello());
      <span class="ot">println!</span>(<span class="st">&quot;Hello in Japanese: {}&quot;</span>, hello());
  }</code></pre>
  <p>Rust выдаст нам сообщение об ошибке во время компиляции:</p>
  <pre class="text"><code>   Compiling phrases v0.0.1 (file:///home/you/projects/phrases)
  src/main.rs:4:5: 4:40 error: a value named `hello` has already been imported in this m
  ↳ odule [E0252]
  src/main.rs:4 use phrases::japanese::greetings::hello;
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  error: aborting due to previous error
  Could not compile `phrases`.</code></pre>
  <p>Если мы импортируем несколько имен из одного модуля, то нам совсем не обязательно писать одно и то же много раз. Вместо этого кода:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> phrases::english::greetings;
  <span class="kw">use</span> phrases::english::farewells;</code></pre>
  <p>Вы можете использовать сокращение:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> phrases::english::{greetings, farewells};</code></pre>
  <section id="реэкспорт-с-помощью-pub-use" class="level4">
  <h4>Реэкспорт с помощью <code>pub use</code></h4>
  <p>Вы можете использовать <code>use</code> не просто для сокращения идентификаторов. Вы также можете использовать его внутри вашего контейнера, чтобы реэкспортировать функцию из другого модуля. Это позволяет представить внешний интерфейс, который может не напрямую отображать внутреннюю организацию кода.</p>
  <p>Давайте посмотрим на примере. Измените файл <code>src/main.rs</code> следующим образом:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> crate phrases;
  
  <span class="kw">use</span> phrases::english::{greetings,farewells};
  <span class="kw">use</span> phrases::japanese;
  
  <span class="kw">fn</span> main() {
      <span class="ot">println!</span>(<span class="st">&quot;Hello in English: {}&quot;</span>, greetings::hello());
      <span class="ot">println!</span>(<span class="st">&quot;Goodbye in English: {}&quot;</span>, farewells::goodbye());
  
      <span class="ot">println!</span>(<span class="st">&quot;Hello in Japanese: {}&quot;</span>, japanese::hello());
      <span class="ot">println!</span>(<span class="st">&quot;Goodbye in Japanese: {}&quot;</span>, japanese::goodbye());
  }</code></pre>
  <p>Затем измените файл <code>src/lib.rs</code>, чтобы сделать модуль <code>japanese</code> с публичным:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">mod</span> english;
  <span class="kw">pub</span> <span class="kw">mod</span> japanese;</code></pre>
  <p>Далее, убедитесь, что обе функции публичные, сперва в <code>src/japanese/greetings.rs</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">fn</span> hello() -&gt; String {
      <span class="st">&quot;こんにちは&quot;</span>.to_string()
  }</code></pre>
  <p>А затем в <code>src/japanese/farewells.rs</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">fn</span> goodbye() -&gt; String {
      <span class="st">&quot;さようなら&quot;</span>.to_string()
  }</code></pre>
  <p>Наконец, измените файл <code>src/japanese/mod.rs</code> вот так:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">use</span> <span class="kw">self</span>::greetings::hello;
  <span class="kw">pub</span> <span class="kw">use</span> <span class="kw">self</span>::farewells::goodbye;
  
  <span class="kw">mod</span> greetings;
  <span class="kw">mod</span> farewells;</code></pre>
  <p>Объявление <code>pub use</code> привносит указанную функцию в эту часть области видимости нашей модулной иерархии. Так как мы использовали <code>pub use</code> внутри нашего модуля <code>japanese</code>, то теперь мы можем вызывать функцию <code>phrases::japanese::hello()</code> и функцию <code>phrases::japanese::goodbye()</code>, хотя код для них расположен в <code>phrases::japanese::greetings::hello()</code> и <code>phrases::japanese::farewells::goodbye()</code> соответственно. Наша внутренняя организация не определяет наш внешний интерфейс.</p>
  <p>В этом примере мы используем <code>pub use</code> отдельно для каждой функции, которую хотим привнести в область <code>japanese</code>. В качестве альтернативы, мы могли бы использовать шаблонный синтаксис, чтобы включать в себя все элементы из модуля <code>greetings</code> в текущую область: <code>pub use self::greetings::*</code>.</p>
  <p>Что можно сказать о <code>self</code>? По умолчанию объявления <code>use</code> используют абсолютные пути, начинающиеся с корня контейнера. <code>self</code>, напротив, формирует эти пути относительно текущего места в иерархии. У <code>use</code> есть еще одна особая форма: вы можете использовать <code>use super::</code>, чтобы подняться по дереву на один уровень вверх от вашего текущего местоположения. Некоторые предпочитают думать о <code>self</code> как о <code>.</code>, а о <code>super</code> как о <code>..</code>, что для многих командных оболочек является представлением для текущей директории и для родительской директории соответственно.</p>
  <p>Вне <code>use</code>, пути относительны: <code>foo::bar()</code> ссылаться на функцию внутри <code>foo</code> относительно того, где мы находимся. Если же используется префикс <code>::</code>, то <code>::foo::bar()</code> будет ссылаться на другой <code>foo</code>, абсолютный путь относительно корня контейнера.</p>
  <p>Кроме того, обратите внимание, что мы использовали <code>pub use</code> прежде, чем объявили наши модули с помощью <code>mod</code>. Rust требует, чтобы объявления <code>use</code> шли в первую очередь.</p>
  <p>Следующий код собирается и работает:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> run
     <span class="kw">Compiling</span> phrases v0.0.1 (file:///home/you/projects/phrases)
       <span class="kw">Running</span> <span class="kw">`target/debug/phrases`</span>
  <span class="kw">Hello</span> in English: Hello!
  <span class="kw">Goodbye</span> in English: Goodbye.
  Hello <span class="kw">in</span> Japanese: こんに<span class="kw">ちは</span>
  Goodbye <span class="kw">in</span> Japanese: さようなら</code></pre>
  </section>
  </section>
  </section>
  <section id="sec--const-and-static" class="level2">
  <h2><code>const</code> и <code>static</code></h2>
  <p>В Rust можно определить постоянную с помощью ключевого слова <code>const</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">const N: <span class="kw">i32</span> = <span class="dv">5</span>;</code></pre>
  <p>В отличие от обычных имён, объявляемых с помощью <a href="#sec--variable-bindings"><code>let</code></a>, тип постоянной надо указывать всегда.</p>
  <p>Постоянные живут в течение всего времени работы программы. А именно, у них вообще нет определённого адреса в памяти. Это потому, что они встраиваются (inline) в каждое место, где есть их использование. По этой причине ссылки на одну и ту же постоянную не обязаны указывать на один и тот же адрес в памяти.</p>
  <section id="static-1" class="level3">
  <h3><code>static</code></h3>
  <p>В Rust также можно объявить что-то вроде «глобальной переменной», используя статические значения. Они похожи на постоянные, но статические значения не встраиваются в место их использования. Это значит, что каждое значение существует в единственном экземпляре, и у него есть определённый адрес.</p>
  <p>Вот пример:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">static</span> N: <span class="kw">i32</span> = <span class="dv">5</span>;</code></pre>
  <p>Так же, как и в случае с постоянными, тип статического значения надо указывать всегда.</p>
  <p>Статические значения живут в течение всего времени работы программы, и любая ссылка на постоянную имеет <a href="#sec--lifetimes">статическое время жизни</a> (<code>static</code> lifetime):</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">static</span> NAME: &amp;<span class="ot">'static</span> <span class="kw">str</span> = <span class="st">&quot;Steve&quot;</span>;</code></pre>
  <section id="изменяемость" class="level4">
  <h4>Изменяемость</h4>
  <p>Вы можете сделать статическое значение изменяемым с помощью ключевого слова <code>mut</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">static</span> <span class="kw">mut</span> N: <span class="kw">i32</span> = <span class="dv">5</span>;</code></pre>
  <p>Поскольку <code>N</code> изменяемо, один поток может изменить его во время того, как другой читает его значение. Это ситуация «гонки» по данным, и она считается небезопасным поведением в Rust. Поэтому и чтение, и изменение статического изменяемого значения (<code>static mut</code>) является <a href="#sec--unsafe">небезопасным</a> (unsafe), и обе эти операции должны выполняться в небезопасных блоках (<code>unsafe</code> block):</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">
  <span class="kw">unsafe</span> {
      N += <span class="dv">1</span>;
  
      <span class="ot">println!</span>(<span class="st">&quot;N: {}&quot;</span>, N);
  }</code></pre>
  <p>Более того, любой тип, хранимый в статической переменной, должен быть ограничен <code>Sync</code> и не может иметь реализации <a href="#sec--drop"><code>Drop</code></a>.</p>
  </section>
  </section>
  <section id="инициализация" class="level3">
  <h3>Инициализация</h3>
  <p>И постоянные, и статические значения имеют определённые требования к тому, что можно хранить в них. Они могут быть проинициализированы только выражением, значение которого постоянно. Другими словами, вы не можете использовать вызов функции или что-то, вычисляемое во время исполнения.</p>
  </section>
  <section id="какую-конструкцию-стоит-использовать" class="level3">
  <h3>Какую конструкцию стоит использовать?</h3>
  <p>Почти всегда стоит предпочитать постоянные. Ситуация, когда вам нужно реальное место в памяти и соответствующий ему адрес довольно редка. А использование постоянных позволяет компилятору провести оптимизации вроде распространения постоянных (constant propagation) не только в вашем контейнере, но и в тех, которые зависят от него.</p>
  </section>
  </section>
  <section id="sec--attributes" class="level2">
  <h2>Атрибуты</h2>
  <p>В Rust объявления могут быть аннотированы с помощью «атрибутов». Они выглядят так:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="ot">#[</span>test<span class="ot">]</span></code></pre>
  <p>или так:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">#![test]</code></pre>
  <p>Разница между ними состоит в символе <code>!</code>, который изменяет его поведение, определяющее к какому элементу применяется атрибут:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="ot">#[</span>foo<span class="ot">]</span>
  <span class="kw">struct</span> Foo;
  
  <span class="kw">mod</span> bar {
      #![bar]
  }</code></pre>
  <p>Атрибут <code>#[foo]</code> относится к следующему за ним элементу, который является объявлением <code>struct</code>. Атрибут <code>#![bar]</code> относится к элементу охватывающему его, который является объявлением <code>mod</code>. В остальном они одинаковы. Оба каким-то образом изменяют значение элемента, к которому они прикреплены.</p>
  <p>Например, рассмотрим такую функцию:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="ot">#[</span>test<span class="ot">]</span>
  <span class="kw">fn</span> check() {
      <span class="ot">assert_eq!</span>(<span class="dv">2</span>, <span class="dv">1</span> + <span class="dv">1</span>);
  }</code></pre>
  <p>Функция помечена как <code>#[test]</code>. Это означает, что она особенная: эта функция будет выполняться при запуске <a href="#sec--testing">тестов</a>. При компиляции, как правило, она не будет включена. Теперь эта функция является функцией тестирования.</p>
  <p>Атрибуты также могут иметь дополнительные данные:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="ot">#[</span>inline<span class="ot">(</span>always<span class="ot">)]</span>
  <span class="kw">fn</span> super_fast_fn() {</code></pre>
  <p>Или даже ключи и значения:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="ot">#[</span>cfg<span class="ot">(</span>target_os <span class="ot">=</span> <span class="st">&quot;macos&quot;</span><span class="ot">)]</span>
  <span class="kw">mod</span> macos_only {</code></pre>
  <p>Атрибуты в Rust используются для ряда различных вещей. Вот <a href="https://doc.rust-lang.org/stable/reference.html#attributes">ссылка</a> на полный список атрибутов. В настоящее время вы не можете создавать свои собственные атрибуты, компилятор Rust определяет их.</p>
  </section>
  <section id="sec--type-aliases" class="level2">
  <h2>Псевдонимы типов</h2>
  <p>Ключевое слово <code>type</code> позволяет объявить псевдоним другого типа:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">type</span> Name = String;</code></pre>
  <p>Затем вы можете использовать этот псевдоним вместо реального типа:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">type</span> Name = String;
  
  <span class="kw">let</span> x: Name = <span class="st">&quot;Hello&quot;</span>.to_string();</code></pre>
  <p>Однако, обратите внимание на то что <em>псевдоним</em> не объявляет новый тип. Rust строго типизированный язык, например у вас не получится сравнить значения двух различных типов:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x: <span class="kw">i32</span> = <span class="dv">5</span>;
  <span class="kw">let</span> y: <span class="kw">i64</span> = <span class="dv">5</span>;
  
  <span class="kw">if</span> x == y {
     <span class="co">// ...</span>
  }</code></pre>
  <p>Вы получите ошибку при компиляции:</p>
  <pre class="text"><code>error: mismatched types:
   expected `i32`,
      found `i64`
  (expected i32,
      found i64) [E0308]
       if x == y {
               ^</code></pre>
  <p>Но если мы используем псевдоним:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">type</span> Num = <span class="kw">i32</span>;
  
  <span class="kw">let</span> x: <span class="kw">i32</span> = <span class="dv">5</span>;
  <span class="kw">let</span> y: <span class="kw">Num</span> = <span class="dv">5</span>;
  
  <span class="kw">if</span> x == y {
     <span class="co">// ...</span>
  }</code></pre>
  <p>То этот пример скомпилируется без ошибок. Значения типа <code>Num</code> всегда будут такие же как и у типа <code>i32</code>.</p>
  <p>Вы также можете использовать псевдонимы типов с обобщённым кодом:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::result;
  
  <span class="kw">enum</span> ConcreteError {
      Foo,
      Bar,
  }
  
  <span class="kw">type</span> Result&lt;T&gt; = result::<span class="kw">Result</span>&lt;T, ConcreteError&gt;;</code></pre>
  <p>В этом примере мы создаем свою версию типа <code>Result</code>, который всегда будет использовать перечисление <code>ConcreteError</code> в <code>Result&lt;T, E&gt;</code> вместо типа <code>E</code>. Псевдонимы типов часто используются в модулях стандартной библиотеки для создания своих псевдонимов для <code>Result&lt;T, E&gt;</code>. Например, <a href="http://doc.rust-lang.org/std/io/type.Result.html">io::Result</a>.</p>
  </section>
  <section id="sec--casting-between-types" class="level2">
  <h2>Приведение типов</h2>
  <p>Rust, со своим акцентом на безопасность, обеспечивает два различных способа преобразования различных типов между собой. Первый — <code>as</code>, для безопасного приведения. Второй — <code>transmute</code>, в отличие от первого, позволяет произвольное приведение типов и является одной из самых опасных возможностей Rust!</p>
  <section id="as" class="level3">
  <h3><code>as</code></h3>
  <p>Ключевое слово <code>as</code> выполняет обычное приведение типов:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x: <span class="kw">i32</span> = <span class="dv">5</span>;
  
  <span class="kw">let</span> y = x <span class="kw">as</span> <span class="kw">i64</span>;</code></pre>
  <p>Оно допускает только определенные виды приведения типов:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> a = [<span class="dv">0u8</span>, <span class="dv">0u8</span>, <span class="dv">0u8</span>, <span class="dv">0u8</span>];
  
  <span class="kw">let</span> b = a <span class="kw">as</span> <span class="kw">u32</span>; <span class="co">// four eights makes 32</span></code></pre>
  <p>Это приведет к ошибке:</p>
  <pre class="text"><code>error: non-scalar cast: `[u8; 4]` as `u32`
  let b = a as u32; // four eights makes 32
          ^~~~~~~~</code></pre>
  <p>Это «нескалярное преобразование», потому что у нас здесь преобразуются множественные значения: четыре элемента массива. Такие виды преобразований очень опасны, потому что они делают предположения о том, как реализованы множественные нижележащие структуры. Поэтому нам нужно что-то более опасное.</p>
  </section>
  <section id="transmute" class="level3">
  <h3><code>transmute</code></h3>
  <p>Функция <code>transmute</code> предоставляется [внутренними средствами компилятора][intrinsics], и то, что она делает, является очень простым, но в то же время очень опасным. Она сообщает Rust, чтобы он воспринимал значение одного типа, как будто это значение другого типа. Это делается независимо от системы проверки типов, и поэтому полностью на ваш страх и риск.</p>
  <p>В предыдущем примере, мы знаем, что массив из четырех <code>u8</code> отображается в массив <code>u32</code> должным образом, и поэтому мы хотим выполнить приведение. Если вместо <code>as</code> использовать <code>transmute</code>, то Rust позволит это сделать:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::mem;
  
  <span class="kw">unsafe</span> {
      <span class="kw">let</span> a = [<span class="dv">0u8</span>, <span class="dv">0u8</span>, <span class="dv">0u8</span>, <span class="dv">0u8</span>];
  
      <span class="kw">let</span> b = mem::transmute::&lt;[<span class="kw">u8</span>; <span class="dv">4</span>], <span class="kw">u32</span>&gt;(a);
  }</code></pre>
  <p>Для того чтобы компиляция прошла успешно, мы должны обернуть эту операцию в <code>unsafe</code> блок. Технически, только вызов <code>mem::transmute</code> должен быть выполнен в небезопасном блоке, но в данном случае хорошо было бы поместить в этот блок все необходимое, связаное с этим вызовом, чтобы было удобнее искать. В данном примере связаной необходимой переменной является <code>a</code>, и поэтому она находится в блоке. Код может быть в любом стиле, иногда контекст расположен слишком далеко, и тогда упаковка всего кода в <code>unsafe</code> не будет такой уж хорошей идеей.</p>
  <p>Хотя при использовании <code>transmute</code> и выполняется очень мало проверок, но как минимум будет проверяться, что типы имеют одинаковый размер. Нижеприведенный код завершится ошибкой:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::mem;
  
  <span class="kw">unsafe</span> {
      <span class="kw">let</span> a = [<span class="dv">0u8</span>, <span class="dv">0u8</span>, <span class="dv">0u8</span>, <span class="dv">0u8</span>];
  
      <span class="kw">let</span> b = mem::transmute::&lt;[<span class="kw">u8</span>; <span class="dv">4</span>], <span class="kw">u64</span>&gt;(a);
  }</code></pre>
  <p>со следующим описанием:</p>
  <pre class="text"><code>error: transmute called on types with different sizes: [u8; 4] (32 bits) to u64
  (64 bits)</code></pre>
  <p>Все, кроме этой одной проверки, на ваш страх и риск!</p>
  </section>
  </section>
  <section id="sec--associated-types" class="level2">
  <h2>Ассоциированные типы</h2>
  <p>Ассоциированные (связанные) типы — это мощная часть системы типов в Rust. Они связаны с идеей ‘семейства типа’, другими словами, группировки различных типов вместе. Это описание немного абстрактно, так что давайте разберем на примере. Если вы хотите написать типаж <code>Graph</code>, то нужны два обобщенных параметра типа: тип узел и тип ребро. Исходя из этого, вы можете написать типаж <code>Graph&lt;N, E&gt;</code>, который выглядит следующим образом:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">trait</span> Graph&lt;N, E&gt; {
      <span class="kw">fn</span> has_edge(&amp;<span class="kw">self</span>, &amp;N, &amp;N) -&gt; <span class="kw">bool</span>;
      <span class="kw">fn</span> edges(&amp;<span class="kw">self</span>, &amp;N) -&gt; Vec&lt;E&gt;;
      <span class="co">// etc</span>
  }</code></pre>
  <p>Такое решение вроде бы достигает своей цели, но, в конечном счете, является неудобным. Например, любая функция, которая принимает <code>Graph</code> в качестве параметра, <em>также</em> должна быть обобщённой с параметрами <code>N</code> и <code>E</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> distance&lt;N, E, G: Graph&lt;N, E&gt;&gt;(graph: &amp;G, start: &amp;N, end: &amp;N) -&gt; <span class="kw">u32</span> { ... }</code></pre>
  <p>Наша функция расчета расстояния работает независимо от типа <code>Edge</code>, поэтому параметр <code>E</code> в этой сигнатуре является лишним и только отвлекает.</p>
  <p>Что действительно нужно заявить, это чтобы сформировать какого-либо вида <code>Graph</code>, нужны соответствующие типы <code>E</code> и <code>N</code>, собранные вместе. Мы можем сделать это с помощью ассоциированных типов:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">trait</span> Graph {
      <span class="kw">type</span> N;
      type E;
  
      fn has_edge(&amp;self, &amp;Self::N, &amp;Self::N) -&gt; bool;
      fn edges(&amp;self, &amp;Self::N) -&gt; Vec&lt;<span class="kw">Self</span>::E&gt;;
      <span class="co">// etc</span>
  }</code></pre>
  <p>Теперь наши клиенты могут абстрагироваться от определенного <code>Graph</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> distance&lt;G: Graph&gt;(graph: &amp;G, start: &amp;G::N, end: &amp;G::N) -&gt; <span class="kw">u32</span> { ... }</code></pre>
  <p>Больше нет необходимости иметь дело с типом <code>E</code>!</p>
  <p>Давайте поговорим обо всем этом более подробно.</p>
  <section id="определение-ассоциированных-типов" class="level4">
  <h4>Определение ассоциированных типов</h4>
  <p>Давайте построим наш типаж <code>Graph</code>. Вот его определение:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">trait</span> Graph {
      <span class="kw">type</span> N;
      type E;
  
      fn has_edge(&amp;self, &amp;Self::N, &amp;Self::N) -&gt; bool;
      fn edges(&amp;self, &amp;Self::N) -&gt; Vec&lt;<span class="kw">Self</span>::E&gt;;
  }</code></pre>
  <p>Достаточно просто. Ассоциированные типы используют ключевое слово <code>type</code>, и расположены внутри тела типажа, наряду с функциями.</p>
  <p>Эти объявления <code>type</code> могут иметь все то же самое, как и при работе с функциями. Например, если бы мы хотели, чтобы тип <code>N</code> реализовывал <code>Display</code>, чтобы была возможность печатать узлы, мы могли бы сделать следующее:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::fmt;
  
  <span class="kw">trait</span> Graph {
      <span class="kw">type</span> N: fmt::Display;
      type E;
  
      fn has_edge(&amp;self, &amp;Self::N, &amp;Self::N) -&gt; bool;
      fn edges(&amp;self, &amp;Self::N) -&gt; Vec&lt;<span class="kw">Self</span>::E&gt;;
  }</code></pre>
  </section>
  <section id="реализация-ассоциированных-типов" class="level4">
  <h4>Реализация ассоциированных типов</h4>
  <p>Типаж, который включает ассоциированные типы, как и любой другой типаж, для реализации использует ключевое слово <code>impl</code>. Вот простая реализация <code>Graph</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Node;
  
  <span class="kw">struct</span> Edge;
  
  <span class="kw">struct</span> MyGraph;
  
  <span class="kw">impl</span> Graph <span class="kw">for</span> MyGraph {
      <span class="kw">type</span> N = Node;
      <span class="kw">type</span> E = Edge;
  
      <span class="kw">fn</span> has_edge(&amp;<span class="kw">self</span>, n1: &amp;Node, n2: &amp;Node) -&gt; <span class="kw">bool</span> {
          <span class="kw">true</span>
      }
  
      <span class="kw">fn</span> edges(&amp;<span class="kw">self</span>, n: &amp;Node) -&gt; Vec&lt;Edge&gt; {
          Vec::new()
      }
  }</code></pre>
  <p>Это глупая реализация, которая всегда возвращает <code>true</code> и пустой <code>Vec&lt;Edge&gt;</code>, но она дает вам общее представление о том, как реализуются такие ​​вещи. Для начала нужны три <code>struct</code>, одна для графа, одна для узла и одна для ребра. В этой реализации используются <code>struct</code> для всех трех сущностей, но вполне могли бы использоваться и другие типы, которые работали бы так же хорошо, если бы реализация была более продвинутой.</p>
  <p>Затем идет строка с <code>impl</code>, которая является такой же, как и при реализации любого другого типажа.</p>
  <p>Далее мы используем знак <code>=</code>, чтобы определить наши ассоциированные типы. Имя типажа идет слева от знака <code>=</code>, а конкретный тип, для которого мы <code>impl</code> этот типаж, идет справа. Наконец, мы используем конкретные типы при объявлении функций.</p>
  </section>
  <section id="типажи-объекты-и-ассоциированные-типы" class="level4">
  <h4>Типажи-объекты и ассоциированные типы</h4>
  <p>Вот еще немного синтаксиса, о котором следует упомянуть: типажи-объекты. Если вы попытаетесь создать типаж-объект из ассоциированного типа, как в этом примере:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> graph = MyGraph;
  <span class="kw">let</span> obj = Box::new(graph) <span class="kw">as</span> Box&lt;Graph&gt;;</code></pre>
  <p>Вы получите две ошибки:</p>
  <pre class="text"><code>error: the value of the associated type `E` (from the trait `main::Graph`) must
  be specified [E0191]
  let obj = Box::new(graph) as Box&lt;Graph&gt;;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  24:44 error: the value of the associated type `N` (from the trait
  `main::Graph`) must be specified [E0191]
  let obj = Box::new(graph) as Box&lt;Graph&gt;;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~</code></pre>
  <p>Мы не сможем создать типаж-объект, подобный этому, потому что у него нет информации об ассоциированных типах. Вместо этого, мы можем написать так:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> graph = MyGraph;
  <span class="kw">let</span> obj = Box::new(graph) <span class="kw">as</span> Box&lt;Graph&lt;N=Node, E=Edge&gt;&gt;;</code></pre>
  <p>Синтаксис <code>N=Node</code> позволяет нам предоставлять конкретный тип, <code>Node</code>, для параметра типа <code>N</code>. То же самое и для <code>E=Edge</code>. Если бы мы не предоставляли это ограничение, то не могли бы знать наверняка, какая <code>impl</code> соответствует этому типажу-объекту.</p>
  </section>
  </section>
  <section id="sec--unsized-types" class="level2">
  <h2>Безразмерные типы</h2>
  <p>Большинство типов имеют определённый размер в байтах. Этот размер обычно известен во время компиляции. Например, <code>i32</code> — это 32 бита, или 4 байта. Однако, существуют некоторые полезные типы, которые не имеют определённого размера. Они называются «безразмерными» или «типами динамического размера». Один из примеров таких типов — это <code>[T]</code>. Этот тип представляет собой последовательность из определённого числа элементов <code>T</code>. Но мы не знаем, как много этих элементов, поэтому размер неизвестен.</p>
  <p>Rust понимает несколько таких типов, но их использование несколько ограничено. Есть три ограничения:</p>
  <ol type="1">
  <li>Мы можем работать с экземпляром безразмерного типа только с помощью указателя. <code>&amp;[T]</code> будет работать, а <code>[T]</code> — нет.</li>
  <li>Переменные и аргументы не могут иметь тип динамического размера.</li>
  <li>Только последнее поле структуры может быть безразмерного типа; другие — нет. Варианты перечислений не могут содержать типы динамического размера в качестве данных.</li>
  </ol>
  <p>А зачем это всё? Поскольку мы можем использовать <code>[T]</code> только через указатель, если бы язык не поддерживал безразмерные типы, мы бы не смогли написать такой код:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">impl</span> Foo <span class="kw">for</span> <span class="kw">str</span> {</code></pre>
  <p>или</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">impl</span>&lt;T&gt; Foo <span class="kw">for</span> [T] {</code></pre>
  <p>Вместо этого, вам бы пришлось написать:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">impl</span> Foo <span class="kw">for</span> &amp;<span class="kw">str</span> {</code></pre>
  <p>Таким образом, данная реализация работала бы только для <a href="#sec--references-and-borrowing">ссылок</a>, и не поддерживала бы другие типы указателей. А реализацию для безразмерного типа смогут использовать любые указатели, включая определённые пользователем умные указатели (позже, когда будут исправлены некоторые ошибки).</p>
  <section id="sized" class="level3">
  <h3>?Sized</h3>
  <p>Если вы пишете функцию, принимающую тип динамического размера, вы можете использовать специальное ограничение <code>?Sized</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Foo&lt;T: ?<span class="kw">Sized</span>&gt; {
      f: T,
  }</code></pre>
  <p>Этот <code>?</code> читается как «Т может быть размерным (<code>Sized</code>)». Он означает, что это ограничение особенное: оно разрешает использование некоторых типов, которые не могли бы быть использованы в его отсутствие. Таким образом, оно <em>расширяет</em> множество подходящих типов, а не сужает его. Это можно представить себе как если бы все типы <code>T</code> неявно были размерными (<code>T: Sized</code>), а <code>?</code> отменял это ограничение по-умолчанию.</p>
  </section>
  </section>
  <section id="sec--operators-and-overloading" class="level2">
  <h2>Перегрузка операций</h2>
  <p>Rust позволяет ограниченную форму перегрузки операций. Есть определенные операции, которые могут быть перегружены. Есть специальные типажи, которые вы можете реализовать для поддержки конкретной операции между типами. В результате чего перегружается операция.</p>
  <p>Например, операция <code>+</code> может быть перегружена с помощью типажа <code>Add</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::ops::<span class="kw">Add</span>;
  
  <span class="ot">#[</span>derive<span class="ot">(</span>Debug<span class="ot">)]</span>
  <span class="kw">struct</span> Point {
      x: <span class="kw">i32</span>,
      y: <span class="kw">i32</span>,
  }
  
  <span class="kw">impl</span> <span class="kw">Add</span> <span class="kw">for</span> Point {
      <span class="kw">type</span> Output = Point;
  
      <span class="kw">fn</span> add(<span class="kw">self</span>, other: Point) -&gt; Point {
          Point { x: <span class="kw">self</span>.x + other.x, y: <span class="kw">self</span>.y + other.y }
      }
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> p1 = Point { x: <span class="dv">1</span>, y: <span class="dv">0</span> };
      <span class="kw">let</span> p2 = Point { x: <span class="dv">2</span>, y: <span class="dv">3</span> };
  
      <span class="kw">let</span> p3 = p1 + p2;
  
      <span class="ot">println!</span>(<span class="st">&quot;{:?}&quot;</span>, p3);
  }</code></pre>
  <p>В <code>main</code> мы можем использовать операцию <code>+</code> для двух <code>Point</code>, так как мы реализовали типаж <code>Add&lt;Output=Point&gt;</code> для <code>Point</code>.</p>
  <p>Есть целый ряд операций, которые могут быть перегружены таким образом, и все связанные с этим типажи расположены в модуле <a href="http://doc.rust-lang.org/std/ops/index.html"><code>std::ops</code></a>. Проверьте эту часть документации для получения полного списка.</p>
  <p>Реализация этих типажей следует паттерну. Давайте посмотрим на типаж <a href="http://doc.rust-lang.org/std/ops/trait.Add.html"><code>Add</code></a> более детально:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">trait</span> <span class="kw">Add</span>&lt;RHS = <span class="kw">Self</span>&gt; {
      <span class="kw">type</span> Output;
  
      fn add(self, rhs: RHS) -&gt; Self::Output;
  }</code></pre>
  <p>В общей сложности здесь присутствуют три типа: тип <code>impl Add</code>, который мы реализуем, тип <code>RHS</code>, который по умолчанию равен <code>Self</code> и тип <code>Output</code>. Для выражения <code>let z = x + y</code>: <code>x</code> — это тип <code>Self</code>, <code>y</code> — это тип <code>RHS</code>, а <code>z</code> - это тип <code>Self::Output</code>.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">impl</span> <span class="kw">Add</span>&lt;<span class="kw">i32</span>&gt; <span class="kw">for</span> Point {
      <span class="kw">type</span> Output = <span class="kw">f64</span>;
  
      <span class="kw">fn</span> add(<span class="kw">self</span>, rhs: <span class="kw">i32</span>) -&gt; <span class="kw">f64</span> {
          <span class="co">// add an i32 to a Point and get an f64</span>
      }
  }</code></pre>
  <p>позволит вам сделать следующее:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> p: Point = <span class="co">// ...</span>
  <span class="kw">let</span> x: <span class="kw">f64</span> = p + <span class="dv">2i32</span>;</code></pre>
  <section id="использование-типажей-операций-в-обобщённых-структурах" class="level3">
  <h3>Использование типажей операций в обобщённых структурах</h3>
  <p>Теперь, когда мы знаем, как реализованы типажи операций, мы можем реализовать наш типаж <code>HasArea</code> и структуру <code>Square</code> из <a href="#sec--traits">главы о типажах</a> более общим образом:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::ops::<span class="kw">Mul</span>;
  
  <span class="kw">trait</span> HasArea&lt;T&gt; {
      <span class="kw">fn</span> area(&amp;<span class="kw">self</span>) -&gt; T;
  }
  
  <span class="kw">struct</span> Square&lt;T&gt; {
      x: T,
      y: T,
      side: T,
  }
  
  <span class="kw">impl</span>&lt;T&gt; HasArea&lt;T&gt; <span class="kw">for</span> Square&lt;T&gt;
          where T: <span class="kw">Mul</span>&lt;Output=T&gt; + <span class="kw">Copy</span> {
      <span class="kw">fn</span> area(&amp;<span class="kw">self</span>) -&gt; T {
          <span class="kw">self</span>.side * <span class="kw">self</span>.side
      }
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> s = Square {
          x: <span class="dv">0.0f64</span>,
          y: <span class="dv">0.0f64</span>,
          side: <span class="dv">12.0f64</span>,
      };
  
      <span class="ot">println!</span>(<span class="st">&quot;Площадь s: {}&quot;</span>, s.area());
  }</code></pre>
  <p>Мы просто объявляем тип-параметр <code>T</code> и используем его вместо <code>f64</code> в определении <code>HasArea</code> и <code>Square</code>. В реализации нужно сделать более хитрые изменения:</p>
  <pre class="ignore"><code>impl&lt;T&gt; HasArea&lt;T&gt; for Square&lt;T&gt;
          where T: Mul&lt;Output=T&gt; + Copy { ... }</code></pre>
  <p>Чтобы реализовать <code>area</code>, мы должны мочь умножить операнды друг на друга, поэтому мы объявляем <code>T</code> как реализующий <code>std::ops::Mul</code>. Как и <code>Add</code>, <code>Mul</code> принимает параметр <code>Output</code>: т.к. мы знаем, что числа не меняют своего типа, когда их умножают, <code>Output</code> также объявлен как <code>T</code>. <code>T</code> также должен поддерживать копирование, чтобы Rust не пытался переместить <code>self.side</code> в возвращаемое значение.</p>
  </section>
  </section>
  <section id="sec--deref-coercions" class="level2">
  <h2>Преобразования при разыменовании (deref coercions)</h2>
  <p>Стандартная библиотека Rust реализует особый типаж, <a href="http://doc.rust-lang.org/std/ops/trait.Deref.html"><code>Deref</code></a>. Обычно его используют, чтобы перегрузить <code>*</code>, операцию разыменования:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::ops::Deref;
  
  <span class="kw">struct</span> DerefExample&lt;T&gt; {
      value: T,
  }
  
  <span class="kw">impl</span>&lt;T&gt; Deref <span class="kw">for</span> DerefExample&lt;T&gt; {
      <span class="kw">type</span> Target = T;
  
      <span class="kw">fn</span> deref(&amp;<span class="kw">self</span>) -&gt; &amp;T {
          &amp;<span class="kw">self</span>.value
      }
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> x = DerefExample { value: <span class="ch">'a'</span> };
      <span class="ot">assert_eq!</span>(<span class="ch">'a'</span>, *x);
  }</code></pre>
  <p>Это полезно при написании своих указательных типов. Однако, в языке есть возможность, связанная с <code>Deref</code>: преобразования при разыменовании. Вот правило: если есть тип <code>U</code>, и он реализует <code>Deref&lt;Target=T&gt;</code>, значения <code>&amp;U</code> будут автоматически преобразованы в <code>&amp;T</code>, когда это необходимо. Вот пример:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo(s: &amp;<span class="kw">str</span>) {
      <span class="co">// позаимствуем строку на секунду</span>
  }
  
  <span class="co">// String реализует Deref&lt;Target=str&gt;</span>
  <span class="kw">let</span> owned = <span class="st">&quot;Hello&quot;</span>.to_string();
  
  <span class="co">// Поэтому, такой код работает:</span>
  foo(&amp;owned);</code></pre>
  <p>Амперсанд перед значением означает, что мы берём ссылку на него. Поэтому <code>owned</code> - это <code>String</code>, а <code>&amp;owned</code> — <code>&amp;String</code>. Поскольку у нас есть реализация типажа <code>impl Deref&lt;Target=str&gt; for String</code>, <code>&amp;String</code> разыменуется в <code>&amp;str</code>, что устраивает <code>foo()</code>.</p>
  <p>Вот и всё. Это правило — одно из немногих мест в Rust, где типы преобразуются автоматически. Оно позволяет писать гораздо более гибкий код. Например, тип <code>Rc&lt;T&gt;</code> реализует <code>Deref&lt;Target=T&gt;</code>, поэтому такой код работает:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::rc::Rc;
  
  <span class="kw">fn</span> foo(s: &amp;<span class="kw">str</span>) {
      <span class="co">// позаимствуем строку на секунду</span>
  }
  
  <span class="co">// String реализует Deref&lt;Target=str&gt;</span>
  <span class="kw">let</span> owned = <span class="st">&quot;Hello&quot;</span>.to_string();
  <span class="kw">let</span> counted = Rc::new(owned);
  
  <span class="co">// Поэтому, такой код работает:</span>
  foo(&amp;counted);</code></pre>
  <p>Мы всего лишь обернули наш <code>String</code> в <code>Rc&lt;T&gt;</code>. Но теперь мы можем передать <code>Rc&lt;String&gt;</code> везде, куда мы могли передать <code>String</code>. Сигнатура <code>foo</code> не поменялась, и работает как с одним, так и с другим типом. Этот пример делает два преобразования: сначала <code>Rc&lt;String</code> преобразуется в <code>String</code>, а потом <code>String</code> в <code>&amp;str</code>. Rust сделает столько преобразований, сколько возможно, пока типы не совпадут.</p>
  <p>Другая известная реализация, предоставляемая стандартной библиотекой, это <code>impl Deref&lt;Target=[T]&gt; for Vec&lt;T&gt;</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> foo(s: &amp;[<span class="kw">i32</span>]) {
      <span class="co">// позаимствуем срез на секунду</span>
  }
  
  <span class="co">// Vec&lt;T&gt; реализует Deref&lt;Target=[T]&gt;</span>
  <span class="kw">let</span> owned = <span class="ot">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
  
  foo(&amp;owned);</code></pre>
  <p>Вектора могут разыменовываться в срезы.</p>
  <section id="разыменование-и-вызов-методов" class="level4">
  <h4>Разыменование и вызов методов</h4>
  <p><code>Deref</code> также будет работать при вызове метода. Другими словами, возможен такой код:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> Foo;
  
  <span class="kw">impl</span> Foo {
      <span class="kw">fn</span> foo(&amp;<span class="kw">self</span>) { <span class="ot">println!</span>(<span class="st">&quot;Foo&quot;</span>); }
  }
  
  <span class="kw">let</span> f = Foo;
  
  f.foo();</code></pre>
  <p>Несмотря на то, что <code>f</code> — это не ссылка, а <code>foo</code> принимает <code>&amp;self</code>, это будет работать. Более того, все примеры ниже делают одно и то же:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">f.foo();
  (&amp;f).foo();
  (&amp;&amp;f).foo();
  (&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;f).foo();</code></pre>
  <p>Методы <code>Foo</code> можно вызывать и на значении типа <code>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;Foo</code>, потому что компилятор сделает столько разыменований, сколько нужно для совпадения типов. А разыменование использует <code>Deref</code>.</p>
  </section>
  </section>
  <section id="sec--macros" class="level2">
  <h2>Макросы</h2>
  <p>К этому моменту вы узнали о многих инструментах Rust, которые нацелены на абстрагирование и повторное использование кода. Эти единицы повторно использованного кода имеют богатую смысловую структуру. Например, функции имеют сигнатуры типа, типы параметров могут имеют ограничения по типажам, перегруженные функции также могут принадлежать к определенному типажу.</p>
  <p>Эта структура означает, что ключевые абстракции Rust имеют мощный механизм проверки времени компиляции. Но это достигается за счет снижения гибкости. Если вы визуально определите структуру повторно используемого кода, то вы можете найти трудным или громоздким выражение этой схемы в виде обобщённой функции, типажа, или чего-то еще в семантике Rust.</p>
  <p>Макросы позволяют абстрагироваться на <em>синтаксическом</em> уровне. Вызов макроса является сокращением для «расширенной» синтаксической формы. Это расширение происходит в начале компиляции, до начала статической проверки. В результате, макросы могут охватить много шаблонов повторного использования кода, которые невозможны при использовании лишь ключевых абстракций Rust.</p>
  <p>Недостатком является то, что код, основанный на макросах, может быть трудным для понимания, потому что к нему применяется меньше встроенных правил. Подобно обычной функции, качественный макрос может быть использован без понимания его реализации. Тем не менее, может быть трудно разработать качественный макрос! Кроме того, ошибки компилятора в макро коде сложнее интерпретировать, потому что они описывают проблемы в расширенной форме кода, а не в исходной сокращенной форме кода, которую используют разработчики.</p>
  <p>Эти недостатки делают макросы чем-то вроде «возможности последней инстанции». Это не означает, что макросы это плохо; они являются частью Rust, потому что иногда они все же нужны для по-настоящему краткой записи хорошо абстрагированной части кода. Просто имейте этот компромисс в виду.</p>
  <section id="определение-макросов-макроопределения" class="level3">
  <h3>Определение макросов (Макроопределения)</h3>
  <p>Вы, возможно, видели макрос <code>vec!</code>, который используется для инициализации <a href="#sec--vectors">вектора</a> с произвольным количеством элементов.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x: Vec&lt;<span class="kw">u32</span>&gt; = <span class="ot">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];</code></pre>
  <p>Его нельзя реализовать в виде обычной функции, так как он принимает любое количество аргументов. Но мы можем представить его в виде синтаксического сокращения для следующего кода</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x: Vec&lt;<span class="kw">u32</span>&gt; = {
      <span class="kw">let</span> <span class="kw">mut</span> temp_vec = Vec::new();
      temp_vec.push(<span class="dv">1</span>);
      temp_vec.push(<span class="dv">2</span>);
      temp_vec.push(<span class="dv">3</span>);
      temp_vec
  };</code></pre>
  <p>Мы можем реализовать это сокращение, используя макрос: <a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a></p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="ot">macro_rules!</span> vec {
      ( $( $x:expr ),* ) =&gt; {
          {
              <span class="kw">let</span> <span class="kw">mut</span> temp_vec = Vec::new();
              $(
                  temp_vec.push($x);
              )*
              temp_vec
          }
      };
  }</code></pre>
  <p>Ого, тут много нового синтаксиса! Давайте разберем его.</p>
  <pre class="ignore"><code>macro_rules! vec { ... }</code></pre>
  <p>Тут мы определяем макрос с именем <code>vec</code>, аналогично тому, как <code>fn vec</code> определяло бы функцию с именем <code>vec</code>. При вызове мы неформально пишем имя макроса с восклицательным знаком, например, <code>vec!</code>. Восклицательный знак является частью синтаксиса вызова и служит для того, чтобы отличать макрос от обычной функции.</p>
  <section id="сопоставление-matching-синтаксис-вызова-макрокоманды" class="level4">
  <h4>Сопоставление (Matching) (Синтаксис вызова макрокоманды)</h4>
  <p>Макрос определяется с помощью ряда <em>правил</em>, которые представляют собой варианты сопоставления с образцом. Выше у нас было</p>
  <pre class="ignore"><code>( $( $x:expr ),* ) =&gt; { ... };</code></pre>
  <p>Это очень похоже на конструкцию <code>match</code>, но сопоставление происходит на уровне синтаксических деревьев Rust, на этапе компиляции. Точка с запятой не является обязательной для последнего (только здесь) варианта. «Образец» слева от <code>=&gt;</code> известен как <em>шаблон совпадений</em> (<em>образец</em>) (<em>обнаружитель совпадений</em>) (<em>matcher</em>). Он имеет <a href="https://doc.rust-lang.org/stable/reference.html#macros">свою собственную грамматику</a> в рамках языка.</p>
  <p>Образец <code>$x:expr</code> будет соответствовать любому выражению Rust, связывая его дерево синтаксиса с <em>метапеременной</em> <code>$x</code>. Идентификатор <code>expr</code> является <em>спецификатором фрагмента</em>; полные возможности перечислены далее в этой главе. Образец, окруженный <code>$(...),*</code>, будет соответствовать нулю или более выражениям, разделенным запятыми.</p>
  <p>За исключением специального синтаксиса сопоставления с образцом, любые другие элементы Rust, которые появляются в образце, должны в точности совпадать. Например,</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="ot">macro_rules!</span> foo {
      (x =&gt; $e:expr) =&gt; (<span class="ot">println!</span>(<span class="st">&quot;mode X: {}&quot;</span>, $e));
      (y =&gt; $e:expr) =&gt; (<span class="ot">println!</span>(<span class="st">&quot;mode Y: {}&quot;</span>, $e));
  }
  
  <span class="kw">fn</span> main() {
      <span class="ot">foo!</span>(y =&gt; <span class="dv">3</span>);
  }</code></pre>
  <p>выведет</p>
  <pre class="text"><code>mode Y: 3</code></pre>
  <p>А с</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="ot">foo!</span>(z =&gt; <span class="dv">3</span>);</code></pre>
  <p>мы получим ошибку компиляции</p>
  <pre class="text"><code>error: no rules expected the token `z`</code></pre>
  </section>
  <section id="развертывание-expansion-синтаксис-преобразования-макрокоманды" class="level4">
  <h4>Развертывание (Expansion) (Синтаксис преобразования макрокоманды)</h4>
  <p>С правой стороны макро правил используется, по большей части, обычный синтаксис Rust. Но мы можем соединить кусочки раздробленного синтаксиса, захваченные при сопоставлении с соответствующим образцом. Из предыдущего примера:</p>
  <pre class="ignore"><code>$(
      temp_vec.push($x);
  )*</code></pre>
  <p>Каждое соответствующее выражение <code>$x</code> будет генерировать одиночный оператор <code>push</code> в развернутой форме макроса. Повторение в развернутой форме происходит синхронно с повторением в форме образца (более подробно об этом чуть позже).</p>
  <p>Поскольку <code>$x</code> уже объявлен в образце как выражение, мы не повторяем <code>:expr</code> с правой стороны. Кроме того, мы не включаем разделителяющую запятую в качестве части оператора повторения. Вместо этого, у нас есть точка с запятой в пределах повторяемого блока.</p>
  <p>Еще одна деталь: макрос <code>vec!</code> имеет <em>две</em> пары фигурных скобках правой части. Они часто сочетаются таким образом:</p>
  <pre class="ignore"><code>macro_rules! foo {
      () =&gt; {{
          ...
      }}
  }</code></pre>
  <p>Внешние скобки являются частью синтаксиса <code>macro_rules!</code>. На самом деле, вы можете использовать <code>()</code> или <code>[]</code> вместо них. Они просто разграничивают правую часть в целом.</p>
  <p>Внутренние скобки являются частью расширенного синтаксиса. Помните, что макрос <code>vec!</code> используется в контексте выражения. Мы используем блок, для записи выражения с множественными операторами, в том числе включающее <code>let</code> привязки. Если ваш макрос раскрывается в одно единственное выражение, то дополнительной слой скобок не нужен.</p>
  <p>Обратите внимание, что мы никогда не <em>говорили</em>, что макрос создает выражения. На самом деле, это не определяется, пока мы не используем макрос в качестве выражения. Если соблюдать осторожность, то можно написать макрос, развернутая форма которого будет валидна сразу в нескольких контекстах. Например, сокращенная форма для типа данных может быть валидной и как выражение, и как шаблон.</p>
  </section>
  <section id="повторение-repetition-многовариантность" class="level4">
  <h4>Повторение (Repetition) (Многовариантность)</h4>
  <p>Операции повтора всегда сопутствуют два основных правила:</p>
  <ol type="1">
  <li><code>$(...)*</code> проходит через один «слой» повторений, для всех <code>$name</code>, которые он содержит, в ногу, и</li>
  <li>каждое <code>$name</code> должно быть под, по крайней мере, стольким количеством <code>$(...)*</code>, сколько было использовано при сопоставлении. Если оно под большим числом <code>$(...)*</code>, <code>$name</code> будет дублироваться, при необходимости.</li>
  </ol>
  <p>Этот причудливый макрос иллюстрирует дублирования переменных из внешних уровней повторения.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="ot">macro_rules!</span> o_O {
      (
          $(
              $x:expr; [ $( $y:expr ),* ]
          );*
      ) =&gt; {
          &amp;[ $($( $x + $y ),*),* ]
      }
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> a: &amp;[<span class="kw">i32</span>]
          = <span class="ot">o_O!</span>(<span class="dv">10</span>; [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>];
                 <span class="dv">20</span>; [<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>]);
  
      <span class="ot">assert_eq!</span>(a, [<span class="dv">11</span>, <span class="dv">12</span>, <span class="dv">13</span>, <span class="dv">24</span>, <span class="dv">25</span>, <span class="dv">26</span>]);
  }</code></pre>
  <p>Это наибольшая синтаксиса совпадений. Эти примеры используют конструкцию <code>$(...)*</code>, которая означает «ноль или более» совпадений. Также вы можете написать <code>$(...)+</code>, что будет означать «одно или более» совпадений. Обе формы записи включают необязательный разделитель, располагающийся сразу за закрывающей скобкой, который может быть любым символом, за исключением <code>+</code> или <code>*</code>.</p>
  <p>Эта система повторений основана на «<a href="http://www.cs.indiana.edu/ftp/techreports/TR206.pdf">Macro-by-Example</a>» (PDF ссылка).</p>
  </section>
  </section>
  <section id="гигиена-hygiene" class="level3">
  <h3>Гигиена (Hygiene)</h3>
  <p>Некоторые языки реализуют макросы с помощью простой текстовой замены, что приводит к различным проблемам. Например, нижеприведенная C программа напечатает <code>13</code> вместо ожидаемого <code>25</code>.</p>
  <pre class="text"><code>#define FIVE_TIMES(x) 5 * x
  
  int main() {
      printf(&quot;%d\n&quot;, FIVE_TIMES(2 + 3));
      return 0;
  }</code></pre>
  <p>После развертывания мы получаем <code>5 * 2 + 3</code>, но умножение имеет больший приоритет чем сложение. Если вы часто использовали C макросы, вы, наверное, знаете стандартные идиомы для устранения этой проблемы, а также пять или шесть других проблем. В Rust мы можем не беспокоиться об этом.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="ot">macro_rules!</span> five_times {
      ($x:expr) =&gt; (<span class="dv">5</span> * $x);
  }
  
  <span class="kw">fn</span> main() {
      <span class="ot">assert_eq!</span>(<span class="dv">25</span>, <span class="ot">five_times!</span>(<span class="dv">2</span> + <span class="dv">3</span>));
  }</code></pre>
  <p>Метапеременная <code>$x</code> обрабатывается как единый узел выражения, и сохраняет свое место в дереве синтаксиса даже после замены.</p>
  <p>Другой распространенной проблемой в системе макросов является <em>захват переменной</em> (<em>variable capture</em>). Вот C макрос, использующий <a href="https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html">GNU C расширение</a>, который эмулирует блоки выражениий в Rust.</p>
  <pre class="text"><code>#define LOG(msg) ({ \
      int state = get_log_state(); \
      if (state &gt; 0) { \
          printf(&quot;log(%d): %s\n&quot;, state, msg); \
      } \
  })</code></pre>
  <p>Вот простой случай использования, применение которого может плохо кончиться:</p>
  <pre class="text"><code>const char *state = &quot;reticulating splines&quot;;
  LOG(state)</code></pre>
  <p>Он раскрывается в</p>
  <pre class="text"><code>const char *state = &quot;reticulating splines&quot;;
  int state = get_log_state();
  if (state &gt; 0) {
      printf(&quot;log(%d): %s\n&quot;, state, state);
  }</code></pre>
  <p>Вторая переменная с именем <code>state</code> затеняет первую. Это проблема, потому что команде печати требуется обращаться к ним обоим.</p>
  <p>Эквивалентный макрос в Rust обладает требуемым поведением.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="ot">macro_rules!</span> log {
      ($msg:expr) =&gt; {{
          <span class="kw">let</span> state: <span class="kw">i32</span> = get_log_state();
          <span class="kw">if</span> state &gt; <span class="dv">0</span> {
              <span class="ot">println!</span>(<span class="st">&quot;log({}): {}&quot;</span>, state, $msg);
          }
      }};
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> state: &amp;<span class="kw">str</span> = <span class="st">&quot;reticulating splines&quot;</span>;
      <span class="ot">log!</span>(state);
  }</code></pre>
  <p>Это работает, потому что Rust имеет <a href="http://en.wikipedia.org/wiki/Hygienic_macro">систему макросов с соблюдением гигиены</a>. Раскрытие каждого макроса происходит в отдельном <em>контексте синтаксиса</em>, и каждая переменная обладает меткой контекста синтаксиса, где она была введена. Это как если бы переменная <code>state</code> внутри <code>main</code> была бы окрашена в другой «цвет» в отличае от переменной <code>state</code> внутри макроса, из-за чего они бы не конфликтовали.</p>
  <p>Это также ограничивает возможности макросов для внедрения новых связываний переменных на месте вызова. Код, приведенный ниже, не будет работать:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="ot">macro_rules!</span> foo {
      () =&gt; (<span class="kw">let</span> x = <span class="dv">3</span>);
  }
  
  <span class="kw">fn</span> main() {
      <span class="ot">foo!</span>();
      <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, x);
  }</code></pre>
  <p>Вместо этого вы должны передавать имя переменной при вызове, тогда она будет обладать меткой правильного контекста синтаксиса.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="ot">macro_rules!</span> foo {
      ($v:ident) =&gt; (<span class="kw">let</span> $v = <span class="dv">3</span>);
  }
  
  <span class="kw">fn</span> main() {
      <span class="ot">foo!</span>(x);
      <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, x);
  }</code></pre>
  <p>Это справедливо для <code>let</code> привязок и меток loop, но не для <a href="https://doc.rust-lang.org/stable/reference.html#items">элементов</a>. Код, приведенный ниже, компилируется:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="ot">macro_rules!</span> foo {
      () =&gt; (<span class="kw">fn</span> x() { });
  }
  
  <span class="kw">fn</span> main() {
      <span class="ot">foo!</span>();
      x();
  }</code></pre>
  </section>
  <section id="рекурсия-макросов" class="level3">
  <h3>Рекурсия макросов</h3>
  <p>Раскрытие макроса также может включать в себя вызовы макросов, в том числе вызовы того макроса, который раскрывается. Эти рекурсивные макросы могут быть использованы для обработки древовидного ввода, как показано на этом (упрощенном) HTML сокращение:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="ot">macro_rules!</span> write_html {
      ($w:expr, ) =&gt; (());
  
      ($w:expr, $e:tt) =&gt; (<span class="ot">write!</span>($w, <span class="st">&quot;{}&quot;</span>, $e));
  
      ($w:expr, $tag:ident [ $($inner:tt)* ] $($rest:tt)*) =&gt; {{
          <span class="ot">write!</span>($w, <span class="st">&quot;&lt;{}&gt;&quot;</span>, <span class="ot">stringify!</span>($tag));
          <span class="ot">write_html!</span>($w, $($inner)*);
          <span class="ot">write!</span>($w, <span class="st">&quot;&lt;/{}&gt;&quot;</span>, <span class="ot">stringify!</span>($tag));
          <span class="ot">write_html!</span>($w, $($rest)*);
      }};
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">use</span> std::fmt::Write;
      <span class="kw">let</span> <span class="kw">mut</span> out = String::new();
  
      <span class="ot">write_html!</span>(&amp;<span class="kw">mut</span> out,
          html[
              head[title[<span class="st">&quot;Macros guide&quot;</span>]]
              body[h1[<span class="st">&quot;Macros are the best!&quot;</span>]]
          ]);
  
      <span class="ot">assert_eq!</span>(out,
          <span class="st">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Macros guide&lt;/title&gt;&lt;/head&gt;\</span>
  <span class="st">         &lt;body&gt;&lt;h1&gt;Macros are the best!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>);
  }</code></pre>
  <p><a name="debugging-macro-code"></a> ### Отладка макросов</p>
  <p>Чтобы увидеть результаты расширения макросов, выполните команду <code>rustc --pretty expanded</code>. Вывод представляет собой целый контейнер, так что вы можете подать его обратно в <code>rustc</code>, что иногда выдает лучшие сообщения об ошибках, чем при обычной компиляции. Обратите внимание, что вывод <code>--pretty expanded</code> может иметь разное значение, если несколько переменных, имеющих одно и то же имя (но разные контексты синтаксиса), находятся в той же области видимости. В этом случае <code>--pretty expanded,hygiene</code> расскажет вам о контекстах синтаксиса.</p>
  <p><code>rustc</code>, поддерживает два синтаксических расширения, которые помогают с отладкой макросов. В настоящее время, они неустойчивы и требуют feature gates.</p>
  <ul>
  <li><p><code>log_syntax!(...)</code> будет печатать свои аргументы в стандартный вывод во время компиляции, и «развертываться» в ничто.</p></li>
  <li><p><code>trace_macros!(true)</code> будет выдавать сообщение компилятора каждый раз, когда макрос развертывается. Используйте <code>trace_macros!(false)</code> в конце развертывания, чтобы выключить его.</p></li>
  </ul>
  </section>
  <section id="требования-синтаксиса" class="level3">
  <h3>Требования синтаксиса</h3>
  <p>Код на Rust может быть разобран в <a href="#abstract-syntax-tree">синтаксическое дерево</a>, даже когда он содержит неразвёрнутые макросы. Это свойство очень полезно для редакторов и других инструментов, обрабатывающих исходный код. Оно также влияет на вид системы макросов Rust.</p>
  <p>Как следствие, когда компилятор разбирает вызов макроса, ему необходимо знать, во что развернётся данный макрос. Макрос может разворачиваться в следующее:</p>
  <ul>
  <li>ноль или больше элементов;</li>
  <li>ноль или больше методов;</li>
  <li>выражение;</li>
  <li>оператор;</li>
  <li>образец.</li>
  </ul>
  <p>Вызов макроса в блоке может представлять собой элементы, выражение, или оператор. Rust использует простое правило для разрешения этой неоднозначности. Вызов макроса, производящего элементы, должен либо</p>
  <ul>
  <li>ограничиваться фигурными скобками, т.е. <code>foo! { ... }</code>;</li>
  <li>завершаться точкой с запятой, т.е. <code>foo!(...);</code>.</li>
  </ul>
  <p>Другое следствие разбора перед раскрытием макросов — это то, что вызов макроса должен состоять из допустимых лексем. Более того, скобки всех видов должны быть сбалансированы в месте вызова. Например, <code>foo!([)</code> не является разрешённым кодом. Такое поведение позволяет компилятору понимать где заканчивается вызов макроса.</p>
  <p>Говоря более формально, тело вызова макроса должно представлять собой последовательность <em>деревьев лексем</em>. Дерево лексем определяется рекурсивно и представляет собой либо:</p>
  <ul>
  <li>последовательность деревьев лексем, окружённую согласованными круглыми, квадратными или фигурными скобками (<code>()</code>, <code>[]</code>, <code>{}</code>);</li>
  <li>любую другую одиночную лексему.</li>
  </ul>
  <p>Внутри сопоставления каждая метапеременная имеет <em>указатель фрагмента</em>, определяющий синтаксическую форму, с которой она совпадает. Вот список этих указателей:</p>
  <ul>
  <li><code>ident</code>: идентификатор. Например: <code>x</code>; <code>foo</code>.</li>
  <li><code>path</code>: квалифицированное имя. Например: <code>T::SpecialA</code>.</li>
  <li><code>expr</code>: выражение. Например: <code>2 + 2</code>; <code>if true then { 1 } else { 2 }</code>; <code>f(42)</code>.</li>
  <li><code>ty</code>: тип. Например: <code>i32</code>; <code>Vec&lt;(char, String)&gt;</code>; <code>&amp;T</code>.</li>
  <li><code>pat</code>: образец. Например: <code>Some(t)</code>; <code>(17, 'a')</code>; <code>_</code>.</li>
  <li><code>stmt</code>: единственный оператор. Например: <code>let x = 3</code>.</li>
  <li><code>block</code>: последовательность операторов, ограниченная фигурными скобками. Например: <code>{ log(error, &quot;hi&quot;); return 12; }</code>.</li>
  <li><code>item</code>: <a href="http://doc.rust-lang.org/reference.html#items">элемент</a>. Например: <code>fn foo() { }</code>; <code>struct Bar;</code>.</li>
  <li><code>meta</code>: «мета-элемент», как в атрибутах. Например: <code>cfg(target_os =   &quot;windows&quot;)</code>.</li>
  <li><code>tt</code>: единственное дерево лексем.</li>
  </ul>
  <p>Есть дополнительные правила относительно лексем, следующих за метапеременной:</p>
  <ul>
  <li>за <code>expr</code> должно быть что-то из этого: <code>=&gt; , ;</code>;</li>
  <li>за <code>ty</code> и <code>path</code> должно быть что-то из этого: <code>=&gt; , : = &gt; as</code>;</li>
  <li>за <code>pat</code> должно быть что-то из этого : <code>=&gt; , =</code>;</li>
  <li>за другими лексемами могут следовать любые символы.</li>
  </ul>
  <p>Приведённые правила обеспечивают развитие синтаксиса Rust без необходимости менять существующие макросы.</p>
  <p>И ещё: система макросов никак не обрабатывет неоднозначность разбора. Например, грамматика <code>$($t:ty)* $e:expr</code> всегда будет выдавать ошибку, потому что синтаксическому анализатору пришлось бы выбирать между разбором <code>$t</code> и разбором <code>$e</code>. Можно изменить синтаксис вызова так, чтобы грамматика отличалась в начале. В данном случае можно написать <code>$(T $t:ty)* E $e:exp</code>.</p>
  </section>
  <section id="области-видимости-импорт-и-экспорт-макросов" class="level3">
  <h3>Области видимости, импорт и экспорт макросов</h3>
  <p>Макросы разворачиваются на ранней стадии компиляции, перед разрешением имён. Один из недостатков такого подхода в том, что правила видимости для макросов отличны от правил для других конструкций языка.</p>
  <p>Компилятор определяет и разворачивает макросы при обходе графа исходного кода контейнера в глубину. При этом определения макросов включаются в граф в порядке их встречи компилятором. Поэтому макрос, определённый на уровне модуля, виден во всём последующем коде модуля, включая тела всех вложенных модулей (<code>mod</code>).</p>
  <p>Макрос, определённый в теле функции, или где-то ещё не на уровне модуля, виден только внутри этого элемента (например, внутри одной функции).</p>
  <p>Если модуль имеет атрибут <code>macro_use</code>, то его макросы также видны в его родительском модуле после элемента <code>mod</code> данного модуля. Если родитель тоже имеет атрибут <code>macro_use</code>, макросы также будут видны в модуле-родителе родителя, после элемента <code>mod</code> родителя. Это распространяется на любое число уровней.</p>
  <p>Атрибут <code>macro_use</code> также можно поставить на подключение контейнера <code>extern crate</code>. В этом контексте оно управляет тем, какие макросы будут загружены из внешнего контейнера, т.е.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="ot">#[</span>macro_use<span class="ot">(</span>foo<span class="ot">,</span> bar<span class="ot">)]</span>
  <span class="kw">extern</span> crate baz;</code></pre>
  <p>Если атрибут записан просто как <code>#[macro_use]</code>, будут загружены все макросы. Если атрибута нет, никакие макросы не будут загружены. Загружены могут быть только макросы, объявленные с атрибутом <code>#[macro_export]</code>.</p>
  <p>Чтобы загрузить макросы из контейнера <em>без</em> компоновки контейнера в выходной артефакт, можно использовать атрибут <code>#[no_link]</code>.</p>
  <p>Например:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="ot">macro_rules!</span> m1 { () =&gt; (()) }
  
  <span class="co">// здесь видны: m1</span>
  
  <span class="kw">mod</span> foo {
      <span class="co">// здесь видны: m1</span>
  
      <span class="ot">#[</span>macro_export<span class="ot">]</span>
      <span class="ot">macro_rules!</span> m2 { () =&gt; (()) }
  
      <span class="co">// здесь видны: m1, m2</span>
  }
  
  <span class="co">// здесь видны: m1</span>
  
  <span class="ot">macro_rules!</span> m3 { () =&gt; (()) }
  
  <span class="co">// здесь видны: m1, m3</span>
  
  <span class="ot">#[</span>macro_use<span class="ot">]</span>
  <span class="kw">mod</span> bar {
      <span class="co">// здесь видны: m1, m3</span>
  
      <span class="ot">macro_rules!</span> m4 { () =&gt; (()) }
  
      <span class="co">// здесь видны: m1, m3, m4</span>
  }
  
  <span class="co">// здесь видны: m1, m3, m4</span></code></pre>
  <p>Когда эта библиотека загружается с помощью <code>#[macro_use] extern crate</code>, виден только макрос <code>m2</code>.</p>
  <p>Атрибуты, относящиеся к макросам, <a href="https://doc.rust-lang.org/stable/reference.html#macro--and-plugin-related-attributes">перечислены в справочнике Rust</a>.</p>
  </section>
  <section id="переменная-crate" class="level3">
  <h3>Переменная <code>$crate</code></h3>
  <p>Если макрос используется в нескольких контейнерах, всё становится ещё сложнее. Допустим, <code>mylib</code> определяет</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">fn</span> increment(x: <span class="kw">u32</span>) -&gt; <span class="kw">u32</span> {
      x + <span class="dv">1</span>
  }
  
  <span class="ot">#[</span>macro_export<span class="ot">]</span>
  <span class="ot">macro_rules!</span> inc_a {
      ($x:expr) =&gt; ( ::increment($x) )
  }
  
  <span class="ot">#[</span>macro_export<span class="ot">]</span>
  <span class="ot">macro_rules!</span> inc_b {
      ($x:expr) =&gt; ( ::mylib::increment($x) )
  }</code></pre>
  <p><code>inc_a</code> работает только внутри <code>mylib</code>, а <code>inc_b</code> — только снаружи. Более того, <code>inc_b</code> сломается, если пользователь импортирует <code>mylib</code> под другим именем.</p>
  <p>В Rust пока нет гигиеничных ссылок на контейнеры, но есть простой способ обойти эту проблему. Особая макро-переменная <code>$crate</code> раскроется в <code>::foo</code> внутри макроса, импортированного из контейнера <code>foo</code>. А когда макрос определён и используется в одном и том же контейнере, <code>$crate</code> станет пустой. Это означает, что мы можем написать</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="ot">#[</span>macro_export<span class="ot">]</span>
  <span class="ot">macro_rules!</span> inc {
      ($x:expr) =&gt; ( $crate::increment($x) )
  }</code></pre>
  <p>чтобы определить один макрос, который будет работать и внутри, и снаружи библиотеки. Имя функции раскроется или в <code>::increment</code>, или в <code>::mylib::increment</code>.</p>
  <p>Чтобы эта система работала просто и правильно, <code>#[macro_use] extern crate ...</code> может быть написано только в корне вашего контейнера, но не внутри <code>mod</code>. Это обеспечивает, что <code>$crate</code> раскроется в единственный идентификатор.</p>
  </section>
  <section id="во-тьме-глубин" class="level3">
  <h3>Во тьме глубин</h3>
  <p>Вводная глава упоминала рекурсивные макросы, но она не рассказывала всей истории. Рекурсивные макросы полезны ещё по одной причине: каждый рекурсивный вызов даёт нам ещё одну возможность сопоставить с образцом аргументы макроса.</p>
  <p>Приведём такой радикальный пример использования данной возможности. С помощью рекурсивных макросов можно реализовать конечный автомат типа <a href="http://esolangs.org/wiki/Bitwise_Cyclic_Tag">Bitwise Cyclic Tag</a>. Стоит заметить, что мы не рекомендуем такой подход, а просто иллюстрируем возможности макросов.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="ot">macro_rules!</span> bct {
      <span class="co">// cmd 0:  d ... =&gt; ...</span>
      (<span class="dv">0</span>, $($ps:tt),* ; $_d:tt)
          =&gt; (<span class="ot">bct!</span>($($ps),*, <span class="dv">0</span> ; ));
      (<span class="dv">0</span>, $($ps:tt),* ; $_d:tt, $($ds:tt),*)
          =&gt; (<span class="ot">bct!</span>($($ps),*, <span class="dv">0</span> ; $($ds),*));
  
      <span class="co">// cmd 1p:  1 ... =&gt; 1 ... p</span>
      (<span class="dv">1</span>, $p:tt, $($ps:tt),* ; <span class="dv">1</span>)
          =&gt; (<span class="ot">bct!</span>($($ps),*, <span class="dv">1</span>, $p ; <span class="dv">1</span>, $p));
      (<span class="dv">1</span>, $p:tt, $($ps:tt),* ; <span class="dv">1</span>, $($ds:tt),*)
          =&gt; (<span class="ot">bct!</span>($($ps),*, <span class="dv">1</span>, $p ; <span class="dv">1</span>, $($ds),*, $p));
  
      <span class="co">// cmd 1p:  0 ... =&gt; 0 ...</span>
      (<span class="dv">1</span>, $p:tt, $($ps:tt),* ; $($ds:tt),*)
          =&gt; (<span class="ot">bct!</span>($($ps),*, <span class="dv">1</span>, $p ; $($ds),*));
  
      <span class="co">// halt on empty data string</span>
      ( $($ps:tt),* ; )
          =&gt; (());
  }</code></pre>
  <p>В качестве упражнения предлагаем читателю определить ещё один макрос, чтобы уменьшить степень дублирования кода в определении выше.</p>
  </section>
  <section id="распространённые-макросы" class="level3">
  <h3>Распространённые макросы</h3>
  <p>Вот некоторые распространённые макросы, которые вы увидите в коде на Rust.</p>
  <section id="panic" class="level4">
  <h4>panic!</h4>
  <p>Этот макрос вызывает панику текущего потока. Вы можете указать сообщение, с которым поток завершится:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="ot">panic!</span>(<span class="st">&quot;о нет!&quot;</span>);</code></pre>
  </section>
  <section id="vec" class="level4">
  <h4>vec!</h4>
  <p>Макрос <code>vec!</code> используется по всей книге, поэтому вы наверняка уже видели его. Он упрощает создание <code>Vec&lt;T&gt;</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> v = <span class="ot">vec!</span>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>];</code></pre>
  <p>Он также позволяет вам создавать векторы с повторяющимися значениями. Например, вот сто нолей:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> v = <span class="ot">vec!</span>[<span class="dv">0</span>; <span class="dv">100</span>];</code></pre>
  </section>
  <section id="assert-and-assert_eq" class="level4">
  <h4>assert! and assert_eq!</h4>
  <p>Эти два макроса используются в тестах. <code>assert!</code> принимает логическое значение. <code>assert_eq!</code> принимает два значения и проверяет, что они равны. <code>true</code> засчитывается как успех, а <code>false</code> вызывает панику и проваливает тест. Вот так:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">// Работает!</span>
  
  <span class="ot">assert!</span>(<span class="kw">true</span>);
  <span class="ot">assert_eq!</span>(<span class="dv">5</span>, <span class="dv">3</span> + <span class="dv">2</span>);
  
  <span class="co">// а это нет :(</span>
  
  <span class="ot">assert!</span>(<span class="dv">5</span> &lt; <span class="dv">3</span>);
  <span class="ot">assert_eq!</span>(<span class="dv">5</span>, <span class="dv">3</span>);</code></pre>
  </section>
  <section id="try" class="level4">
  <h4>try!</h4>
  <p><code>try!</code> используется для обработки ошибок. Он принимает нечто возвращающее <code>Result&lt;T, E&gt;</code> и возвращает <code>T</code> если было возвращено <code>Ok&lt;T&gt;</code>; иначе он делает возврат из функции со значением <code>Err(E)</code>. Вроде такого:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::fs::File;
  
  <span class="kw">fn</span> foo() -&gt; std::io::<span class="kw">Result</span>&lt;()&gt; {
      <span class="kw">let</span> f = <span class="ot">try!</span>(File::create(<span class="st">&quot;foo.txt&quot;</span>));
  
      <span class="kw">Ok</span>(())
  }</code></pre>
  <p>Такой код читается легче, чем этот:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">use</span> std::fs::File;
  
  <span class="kw">fn</span> foo() -&gt; std::io::<span class="kw">Result</span>&lt;()&gt; {
      <span class="kw">let</span> f = File::create(<span class="st">&quot;foo.txt&quot;</span>);
  
      <span class="kw">let</span> f = <span class="kw">match</span> f {
          <span class="kw">Ok</span>(t) =&gt; t,
          <span class="kw">Err</span>(e) =&gt; <span class="kw">return</span> <span class="kw">Err</span>(e),
      };
  
      <span class="kw">Ok</span>(())
  }</code></pre>
  </section>
  <section id="unreachable" class="level4">
  <h4>unreachable!</h4>
  <p>Этот макрос применяется, когда вы хотите пометить какой-то код, который никогда не должен исполняться:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">if</span> <span class="kw">false</span> {
      <span class="ot">unreachable!</span>();
  }</code></pre>
  <p>Иногда вам придётся определять ветви условных конструкций, которые точно никогда не исполнятся. В таком случае, используйте этот макрос, чтобы в случае ошибки программа запаниковала:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x: <span class="kw">Option</span>&lt;<span class="kw">i32</span>&gt; = <span class="kw">None</span>;
  
  <span class="kw">match</span> x {
      <span class="kw">Some</span>(_) =&gt; <span class="ot">unreachable!</span>(),
      <span class="kw">None</span> =&gt; <span class="ot">println!</span>(<span class="st">&quot;Я знаю, что x — это None!&quot;</span>),
  }</code></pre>
  </section>
  <section id="unimplemented" class="level4">
  <h4>unimplemented!</h4>
  <p>Макрос <code>unimplemented!</code> можно использовать, когда вы хотите, чтобы ваш код прошёл проверку типов, но пока не хотите реализовывать его настоящую логику. Один из примеров — это реализация типажа с несколькими требуемыми методами. Возможно, вы хотите разбираться с типажом постепенно — по одному методу за раз. В таком случае, определите остальные методы как <code>unimplemented!</code>, пока не захотите наконец реализовать их.</p>
  </section>
  </section>
  <section id="процедурные-макросы" class="level3">
  <h3>Процедурные макросы</h3>
  <p>Если система макросов не может сделать того, что вам нужно, вы можете написать <a href="#sec--compiler-plugins">плагин к компилятору</a>. По сравнению с макросами, это гораздо труднее, там ещё более нестабильные интерфейсы, и ещё сложнее найти ошибки. Зато вы получаете гибкость — внутри плагина может исполняться произвольный код на Rust. Иногда плагины расширения синтаксиса называются <em>процедурными макросами</em>.</p>
  </section>
  </section>
  <section id="sec--raw-pointers" class="level2">
  <h2>Сырые указатели</h2>
  <p>Стандартная библиотека Rust содержит ряд различных типов умных указателей, но среди них есть два типа, которые экстра-специальные. Большая часть безопасности в Rust является следствием проверок во время компиляции, но сырье указатели не имеют конкретных гарантий и являются <a href="#sec--unsafe">небезопасными</a> для использования.</p>
  <p><code>*const T</code> и <code>*mut T</code> в Rust называются «сырыми указателями» (raw pointers). Иногда, при написании определенных видов библиотек, вам по какой-то причине нужно обойти гарантии безопасности Rust. В этом случае, вы можете использовать сырые указатели в реализации вашей библиотеки, вместе с тем предоставляя безопасный интерфейс для пользователей. Например, <code>*</code> указатели допускают псевдонимы, позволяя им быть использованными для записи типов с разделяемой собственности, и даже поточно-безопасные типы памяти (<code>Rc&lt;T&gt;</code> и <code>Arc&lt;T&gt;</code> типы и реализован полностью в Rust).</p>
  <p>Вот некоторые факты о сырых указателях, которые следует помнить и которые отличают их от других типов указателей. Они:</p>
  <ul>
  <li>не гарантируют, что они указывают на действительную область памяти, и не гарантируют, что они является ненулевыми указателями (в отличие от <code>Box</code> и <code>&amp;</code>);</li>
  <li>не имеют никакой автоматической очистки, в отличие от <code>Box</code>, и поэтому требуют ручного управления ресурсами;</li>
  <li>это простые структуры данных (plain-old-data), то есть они не перемещают право собственности, опять же в отличие от <code>Box</code>, следовательно, компилятор Rust не может защитить от ошибок, таких как использование освобождённой памяти (use- after-free);</li>
  <li>лишены сроков жизни в какой-либо форме, в отличие от <code>&amp;</code>, и поэтому компилятор не может делать выводы о висячих указателях; и</li>
  <li>не имеют никаких гарантий относительно псевдонимизации или изменяемости, за исключением изменений, недопустимых непосредственно для <code>*const T</code>.</li>
  </ul>
  <section id="основы-1" class="level3">
  <h3>Основы</h3>
  <p>Создание сырого указателя совершенно безопасно:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">5</span>;
  <span class="kw">let</span> raw = &amp;x <span class="kw">as</span> *const <span class="kw">i32</span>;
  
  <span class="kw">let</span> <span class="kw">mut</span> y = <span class="dv">10</span>;
  <span class="kw">let</span> raw_mut = &amp;<span class="kw">mut</span> y <span class="kw">as</span> *<span class="kw">mut</span> <span class="kw">i32</span>;</code></pre>
  <p>А вот его разыменование не является. Следующий код не будет работать:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">5</span>;
  <span class="kw">let</span> raw = &amp;x <span class="kw">as</span> *const <span class="kw">i32</span>;
  
  <span class="ot">println!</span>(<span class="st">&quot;raw points at {}&quot;</span>, *raw);</code></pre>
  <p>Он выдает такую ошибку:</p>
  <pre class="text"><code>error: dereference of unsafe pointer requires unsafe function or block [E0133]
       println!(&quot;raw points at{}&quot;, *raw);
                                   ^~~~</code></pre>
  <p>Когда вы разыменовываете сырой указатель, вы принимаете на себя ответственность, что он не указывает на что-то, что может быть некорректным. Таким образом, вы должны использовать <code>unsafe</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = <span class="dv">5</span>;
  <span class="kw">let</span> raw = &amp;x <span class="kw">as</span> *const <span class="kw">i32</span>;
  
  <span class="kw">let</span> points_at = <span class="kw">unsafe</span> { *raw };
  
  <span class="ot">println!</span>(<span class="st">&quot;raw points at {}&quot;</span>, points_at);</code></pre>
  <p>Для более подробной информации по операциям с сырыми указателями, обратитесь к <a href="http://doc.rust-lang.org/std/primitive.pointer.html">API документации</a> о них.</p>
  </section>
  <section id="ffi" class="level3">
  <h3>FFI</h3>
  <p>Сырые указатели полезны для FFI: <code>*const T</code> и <code>*mut T</code> в Rust приблизительно соответствуют <code>const T*</code> и <code>T*</code> в C. Для более подробной информации об этом обратитесь к главе <a href="#sec--ffi">FFI</a>.</p>
  </section>
  <section id="ссылки-и-сырые-указатели" class="level3">
  <h3>Ссылки и сырые указатели</h3>
  <p>Во время выполнения и сырой указатель, <code>*</code>, и ссылка, указывающая на тот же кусок данных, имеют одинаковое представление. По факту, ссылка <code>&amp;T</code> будет неявно приведена к сырому указателю <code>*const T</code> в безопасном коде, аналогично и для вариантов <code>mut</code> (оба приведения могут быть выполнены явно, с помощью, соответственно, <code>value as *const T</code> и <code>value as *mut T</code>).</p>
  <p>Переход в обратном направлении, от <code>*const</code> к ссылке <code>&amp;</code>, не является безопасным. Ссылка <code>&amp;T</code> всегда валидна, и поэтому, как минимум, сырой указатель <code>*const T</code> должен указывать на правильный экземпляр типа <code>T</code>. Кроме того, в результате указатель должен удовлетворять правилам псевдонимизации и изменяемости ссылок. Компилятор предполагает, что эти свойства верны для любых ссылок, независимо от того, как они были созданы, и поэтому любое преобразование из сырых указателей равносильно утверждению, что они соответствуют этим правилам. Программист <em>должен</em> гарантировать это.</p>
  <p>Рекомендуемым методом преобразования является</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> i: <span class="kw">u32</span> = <span class="dv">1</span>;
  
  <span class="co">// explicit cast</span>
  <span class="kw">let</span> p_imm: *const <span class="kw">u32</span> = &amp;i <span class="kw">as</span> *const <span class="kw">u32</span>;
  <span class="kw">let</span> <span class="kw">mut</span> m: <span class="kw">u32</span> = <span class="dv">2</span>;
  
  <span class="co">// implicit coercion</span>
  <span class="kw">let</span> p_mut: *<span class="kw">mut</span> <span class="kw">u32</span> = &amp;<span class="kw">mut</span> m;
  
  <span class="kw">unsafe</span> {
      <span class="kw">let</span> ref_imm: &amp;<span class="kw">u32</span> = &amp;*p_imm;
      <span class="kw">let</span> ref_mut: &amp;<span class="kw">mut</span> <span class="kw">u32</span> = &amp;<span class="kw">mut</span> *p_mut;
  }</code></pre>
  <p>Разыменование с помощью конструкции <code>&amp;*x</code> является более предпочтительным, чем с использованием <code>transmute</code>. Последнее является гораздо более мощным инструментом, чем необходимо, а более ограниченное поведение сложнее использовать неправильно. Например, она требует, чтобы <code>x</code> представляет собой указатель (в отличие от <code>transmute</code>).</p>
  </section>
  </section>
  <section id="sec--unsafe" class="level2">
  <h2>Небезопасный код</h2>
  <p>Главная сила Rust — в мощных статических гарантиях правильности поведения программы во время исполнения. Но проверки безопасности очень осторожны: на самом деле, существуют безопасные программы, правильность которых компилятор доказать не в силах. Чтобы писать такие программы, нужен способ немного ослабить ограничения. Для этого в Rust есть ключевое слово <code>unsafe</code>. Код, использующий <code>unsafe</code>, ограничен меньше, чем обычный код.</p>
  <p>Давайте рассмотрим синтаксис, а затем поговорим о семантике. <code>unsafe</code> используется в четырёх контекстах. Первый — это объявление того, что функция небезопасна:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">unsafe</span> <span class="kw">fn</span> beregis_avtomobilya() {
      <span class="co">// страшные вещи</span>
  }</code></pre>
  <p>Например, все функции, вызываемые через <a href="#sec--ffi">FFI</a>, должны быть помечены как небезопасные. Другое использование <code>unsafe</code> — это отметка небезопасного блока:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">unsafe</span> {
      <span class="co">// страшные вещи</span>
  }</code></pre>
  <p>Третье — небезопасные типажи:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">unsafe</span> <span class="kw">trait</span> Scary { }</code></pre>
  <p>И четвёртое — реализация (<code>impl</code>) таких типажей:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">unsafe</span> <span class="kw">impl</span> Scary <span class="kw">for</span> <span class="kw">i32</span> {}</code></pre>
  <p>Важно явно выделить код, ошибки в котором могут вызвать большие проблемы. Если программа на Rust падает с “segmentation fault”, можете быть уверены — проблема в участке, помеченном как небезопасный.</p>
  <section id="что-значит-безопасный" class="level3">
  <h3>Что значит “безопасный”?</h3>
  <p>В контексте Rust “безопасный” значит “не делает ничего небезопасного”. Также важно знать, что некоторое поведение скорее всего нежелательно, но явно <em>не</em> считается небезопасным:</p>
  <ul>
  <li>Deadlock’и</li>
  <li>Утечка памяти или других ресурсов</li>
  <li>Выход без вызова деструкторов</li>
  <li>Целочисленное переполнение</li>
  </ul>
  <p>Rust не может предотвратить все виды проблем в программах. Код с ошибками может и будет написан на Rust. Вышеперечисленные вещи неприятны, но они не считаются именно что небезопасными.</p>
  <p>В дополнение к этому, ниже представлен список неопределённого поведения (undefined behavior) в Rust. Избегайте этих вещей, даже когда пишете небезопасный код:</p>
  <ul>
  <li>Гонка данных</li>
  <li>Разыменование нулевого или висячего указателя</li>
  <li>Чтение <a href="http://llvm.org/docs/LangRef.html#undefined-values">неинициализированной</a> памяти</li>
  <li>Нарушение <a href="http://llvm.org/docs/LangRef.html#pointer-aliasing-rules">правил о совпадении указателей</a> с помощью сырых указателей</li>
  <li><code>&amp;mut T</code> и <code>&amp;T</code> следуют модели LLVM <a href="http://llvm.org/docs/LangRef.html#noalias">noalias</a>, кроме случаев, когда <code>&amp;T</code> содержит <code>UnsafeCell&lt;U&gt;</code>. Небезопасный код не должен нарушать эти гарантии совпадения указателей.</li>
  <li>Изменение неизменяемого значения или ссылки без использования <code>UnsafeCell&lt;U&gt;</code></li>
  <li>Получение неопределённого поведения с помощью intrinsic-операций компилятора:
  <ul>
  <li>Индексация вне границ объекта с помощью <code>std::ptr::offset</code> (<code>offset</code> intrinsic), кроме разрешённого случая “один байт за концом объекта”.</li>
  <li>Использование <code>std::ptr::copy_nonoverlapping_memory</code> (intrinsic-операции <code>memcpy32</code>/<code>memcpy64</code>) с пересекающимися буферами</li>
  </ul></li>
  <li>Неправильные значения примитивных типов, даже в скрытых полях:
  <ul>
  <li>Нулевые или висячие ссылки или упаковки (boxes)</li>
  <li>Любое значение логического типа, кроме <code>false</code> (0) или <code>true</code> (1)</li>
  <li>Вариант перечисления, не включённый в его определение</li>
  <li>Суррогатное значение <code>char</code> или значение <code>char</code>, превыщающее <code>char::MAX</code></li>
  <li>Последовательности байт, не являющиеся UTF-8, в <code>str</code></li>
  </ul></li>
  <li>Размотка стека в код на Rust из чужого кода (через границы FFI), или размотка из кода на Rust в чужой код</li>
  </ul>
  </section>
  <section id="сверхспособности-небезопасного-кода" class="level3">
  <h3>Сверхспособности небезопасного кода</h3>
  <p>В небезопасном блоке или функции, Rust разрешает три ситуации, которые обычно запрещены. Всего три. Вот они:</p>
  <ol type="1">
  <li>Доступ к или изменение <a href="#static">статической изменяемой переменной</a>.</li>
  <li>Разыменование сырого указателя.</li>
  <li>Вызов небезопасных функций. Это самая мощная возможность.</li>
  </ol>
  <p>Это всё. Важно отметить, что <code>unsafe</code>, например, не “выключает проверку заимствования”. Объявление какого-то кода небезопасным не изменяет его семантику; небезопасность не означает принятие компилятором любого кода. Но она позволяет писать вещи, которые <em>нарушают</em> некоторые из правил.</p>
  <p>Вы также встретите ключевое слово <code>unsafe</code>, когда будете реализовывать интерфейс к чужому коду не на Rust. Идиоматичным считается написание безопасных обёрток вокруг небезопасных библиотек.</p>
  <p>Давайте поговорим о трёх упомянутых возможностях, доступных в небезопасном коде.</p>
  <section id="доступ-или-изменение-static-mut" class="level4">
  <h4>Доступ или изменение <code>static mut</code></h4>
  <p>Rust позволяет пользоваться глобальным изменяемым состоянием с помощью <code>static mut</code>. Это может вызвать гонку по данным, и в сущности небезопасно. Подробнее смотрите раздел о <a href="#static">static</a>.</p>
  </section>
  <section id="разыменование-сырого-указателя" class="level4">
  <h4>Разыменование сырого указателя</h4>
  <p>Сырые указатели поддерживают произвольную арифметику указетелей, и могут вызвать целый ряд проблем безопасности памяти и безопасности в целом. В каком-то смысле, возможность разыменовать произвольный указатель — одна из самых опасных вещей, которые вы можете сделать. Подробнее смотрите раздел о <a href="#sec--raw-pointers">сырых указателях</a>.</p>
  </section>
  <section id="вызов-небезопасных-функций" class="level4">
  <h4>Вызов небезопасных функций</h4>
  <p>Эта возможность затрагивает то, откуда можно делать вызов небезопасного кода: небезопасные функции могут вызываться только из небезопасных блоков.</p>
  <p>Мощь и полезность этой возможности сложно переоценить. Rust предоставляет некоторые <a href="#sec--intrinsics">intrinsic-операции</a> компилятора в виде небезопасных функций, а некоторые небезопасные функции обходят проверки безопасности для достижения большей скорости исполнения.</p>
  <p>В заключение, повторимся: хотя вы и <em>можете</em> делать в небезопасных участках почти что угодно, это не значит, что стоит это делать. Компилятор будет предполагать выполнение оговоренных инвариантов, так что будьте осторожны!</p>
  </section>
  </section>
  </section>
  </section>
  <section id="sec--nightly-rust" class="level1">
  <h1>Нестабильные возможности Rust</h1>
  <p>Rust обеспечивает три канала распространения для Rust: nightly, beta и stable. Нестабильные функции доступны только в nightly Rust. Для более подробной информации об этом процессе смотрите «<a href="http://blog.rust-lang.org/2014/10/30/Stability.html">Стабильность как результат</a>».</p>
  <p>Чтобы установить nightly Rust, вы можете использовать <code>rustup.sh</code>:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">curl</span> -s https://static.rust-lang.org/rustup.sh <span class="kw">|</span> <span class="kw">sh</span> -s -- --channel=nightly</code></pre>
  <p>Если вы беспокоитесь о <a href="http://curlpipesh.tumblr.com">потенциальной безопасности</a> использования данной команды <code>curl | sh</code>, то продолжайте читать далее. Вы также можете использовать двухступенчатый вариант установки и изучить наш установочный скрипт:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">curl</span> -f -L https://static.rust-lang.org/rustup.sh -O
  $ <span class="kw">sh</span> rustup.sh --channel=nightly</code></pre>
  <p>Если же вы используете Windows, то, пожалуйста, скачайте один из установочных пакетов: <a href="https://static.rust-lang.org/dist/rust-1.0.0-beta-i686-pc-windows-gnu.msi">32-битный</a> или <a href="https://static.rust-lang.org/dist/rust-1.0.0-beta-x86_64-pc-windows-gnu.msi">64-битный</a> и запустите его.</p>
  <section id="удаление-1" class="level4">
  <h4>Удаление</h4>
  <p>Если вы решили, что Rust вам больше не нужен, то мы будем чуть-чуть огорчены, но это нормально. Не каждый язык программирования отлично подходит для всех. Просто запустите скрипт деинсталляции:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">sudo</span> /usr/local/lib/rustlib/uninstall.sh</code></pre>
  <p>Если вы использовали установщик Windows, то просто повторно запустите <code>.msi</code>, который предложит вам возможность удаления.</p>
  <p>Некоторые люди, причём не безосновательно, насторожились, когда мы сказали использовать <code>curl | sh</code>. Когда вы делаете так, вы должны доверять тем хорошим людям, которые поддерживают Rust, и не бояться, что они попытаются взломать ваш компьютер и сделать какие-либо плохие вещи. Озабоченность своей безопасностью - это очень хорошо. Если вы один из таких людей, пожалуйста посмотрите в документации как <a href="https://github.com/rust-lang/rust#building-from-source">собрать Rust из исходных кодов</a> или скачайте уже <a href="http://www.rust-lang.org/install.html">скомпилированный Rust</a>. Мы обещаем, что данный способ не будет использоваться для установки Rust всегда: скрипт был сделан для быстрого обновления пока Rust находится в стадии alpha.</p>
  <p>Мы так же должны упомянуть официально поддерживаемые платформы:</p>
  <ul>
  <li>Windows (7, 8, Server 2008 R2)</li>
  <li>Linux (2.6.18 и более новые, разные дистрибутивы), x86 и x86-64</li>
  <li>OSX 10.7 (Lion) и более новые, x86 и x86-64</li>
  </ul>
  <p>Rust активно тестируется на всех этих платформах, а также на некоторых других, например на Android. Но мы указали те, на которых Rust точно должен работать, ибо для этих платформ он тестируется больше всего.</p>
  <p>Напоследок, замечание о Windows. Rust считает, что Windows — это первоклассная платформа для релиза, но если быть честными, то опыт разработки для Windows не на столько хорош, как для Linux/OS X. Мы работаем над этим! Если что-то не работает, то это ошибка. Пожалуйста, дайте нам знать, если такое произойдёт. Каждый коммит тестируется на Windows, впрочем так же, как и на любой другой платформе.</p>
  <p>Если вы уже установили Rust, то откройте терминал и введите это:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">rustc</span> --version</code></pre>
  <p>Вы должны увидеть версию, хэш коммита, дату коммита и дату сборки:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">rustc</span> 1.0.0-nightly (f11f3e7ba 2015-01-04) <span class="kw">(built</span> 2015-01-06<span class="kw">)</span></code></pre>
  <p>Итак, теперь у вас есть установленный Rust! Поздравляем!</p>
  <p>Установщик также устанавливает документацию, которая доступна без подключения к сети. На UNIX системах она располагается в каталоге <code>/usr/local/share/doc/rust</code>. В Windows — в директории <code>share/doc</code>, относительно того куда вы установили Rust.</p>
  <p>Также есть ещё ряд мест, где можно получить помощь. <a href="irc://irc.mozilla.org/#rust">Канал #rust на irc.mozilla.org</a>, к которому вы можете подключиться через <a href="http://chat.mibbit.com/?server=irc.mozilla.org&amp;channel=%23rust">Mibbit</a>. Нажмите на эту ссылку, и вы будете общаться в чате с другими Rustaceans (это дурашливое прозвище, которым мы себя называем), и мы поможем вам. Другие полезные ресурсы, посвящённые Rust: <a href="http://users.rust-lang.org/">форум пользователей</a>, <a href="http://www.reddit.com/r/rust">/r/rust subreddit</a>, <a href="http://stackoverflow.com/questions/tagged/rust">stack overflow</a>. Русскоязычные ресурсы: <a href="irc://irc.mozilla.org/#rust-ru">канал #rust-ru на irc.mozilla.org</a>, <a href="https://groups.google.com/forum/#!forum/rust-russian">google groups</a>.</p>
  </section>
  <section id="sec--compiler-plugins" class="level2">
  <h2>Плагины к компилятору</h2>
  <section id="введение-1" class="level3">
  <h3>Введение</h3>
  <p><code>rustc</code>, компилятор Rust, поддерживает плагины. Плагины — это разработанные пользователями библиотеки, которые добавляют новые возможности в компилятор: это могут быть расширения синтаксиса, дополнительные статические проверки (lints), и другое.</p>
  <p>Плагин — это контейнер, собираемый в динамическую библиотеку, и имеющий отдельную функцию для регистрации расширения в <code>rustc</code>. Другие контейнеры могут загружать эти расширения с помощью атрибута <code>#![plugin(...)]</code>. Также смотрите раздел <a href="http://doc.rust-lang.org/rustc/plugin/index.html"><code>rustc::plugin</code></a> с подробным описанием механизма определения и загрузки плагина.</p>
  <p>Передаваемые в <code>#![plugin(foo(... args ...))]</code> аргументы не обрабатываются самим <code>rustc</code>. Они передаются плагину с помощью <a href="http://doc.rust-lang.org/rustc/plugin/registry/struct.Registry.html#method.args">метода <code>args</code></a> структуры <code>Registry</code>.</p>
  <p>В подавляющем большинстве случаев плагин должен использоваться <em>только</em> через конструкцию <code>#![plugin]</code>, а не через <code>extern crate</code>. Компоновка потянула бы внутренние библиотеки <code>libsyntax</code> и <code>librustc</code> как зависимости для вашего контейнера. Обычно это нежелательно, и может потребоваться только если вы собираете ещё один, другой, плагин. Статический анализ <code>plugin_as_library</code> проверяет выполнение этой рекомендации.</p>
  <p>Обычная практика — помещать плагины в отдельный контейнер, не содержащий определений макросов (<code>macro_rules!</code>) и обычного кода на Rust, предназначенного для непосредственно конечных пользователей библиотеки.</p>
  </section>
  <section id="расширения-синтаксиса" class="level3">
  <h3>Расширения синтаксиса</h3>
  <p>Плагины могут по-разному расширять синтаксис Rust. Один из видов расширения синтаксиса — это процедурные макросы. Они вызываются так же, как и <a href="#sec--macros">обычные макросы</a>, но их раскрытие производится произвольным кодом на Rust, который оперирует <a href="http://doc.rust-lang.org/syntax/ast/index.html">синтаксическими деревьями</a> во время компиляции.</p>
  <p>Давайте напишем плагин <a href="https://github.com/rust-lang/rust/tree/master/src/test/auxiliary/roman_numerals.rs"><code>roman_numerals.rs</code></a>, который реализует целочисленные литералы с римскими цифрами.</p>
  <pre class="ignore"><code>#![crate_type=&quot;dylib&quot;]
  #![feature(plugin_registrar, rustc_private)]
  
  extern crate syntax;
  extern crate rustc;
  
  use syntax::codemap::Span;
  use syntax::parse::token;
  use syntax::ast::{TokenTree, TtToken};
  use syntax::ext::base::{ExtCtxt, MacResult, DummyResult, MacEager};
  use syntax::ext::build::AstBuilder;  // типаж для expr_usize
  use rustc::plugin::Registry;
  
  fn expand_rn(cx: &amp;mut ExtCtxt, sp: Span, args: &amp;[TokenTree])
          -&gt; Box&lt;MacResult + 'static&gt; {
  
      static NUMERALS: &amp;'static [(&amp;'static str, u32)] = &amp;[
          (&quot;M&quot;, 1000), (&quot;CM&quot;, 900), (&quot;D&quot;, 500), (&quot;CD&quot;, 400),
          (&quot;C&quot;,  100), (&quot;XC&quot;,  90), (&quot;L&quot;,  50), (&quot;XL&quot;,  40),
          (&quot;X&quot;,   10), (&quot;IX&quot;,   9), (&quot;V&quot;,   5), (&quot;IV&quot;,   4),
          (&quot;I&quot;,    1)];
  
      let text = match args {
          [TtToken(_, token::Ident(s, _))] =&gt; token::get_ident(s).to_string(),
          _ =&gt; {
              cx.span_err(sp, &quot;аргумент должен быть единственным идентификатором&quot;);
              return DummyResult::any(sp);
          }
      };
  
      let mut text = &amp;*text;
      let mut total = 0;
      while !text.is_empty() {
          match NUMERALS.iter().find(|&amp;&amp;(rn, _)| text.starts_with(rn)) {
              Some(&amp;(rn, val)) =&gt; {
                  total += val;
                  text = &amp;text[rn.len()..];
              }
              None =&gt; {
                  cx.span_err(sp, &quot;неправильное римское число&quot;);
                  return DummyResult::any(sp);
              }
          }
      }
  
      MacEager::expr(cx.expr_u32(sp, total))
  }
  
  #[plugin_registrar]
  pub fn plugin_registrar(reg: &amp;mut Registry) {
      reg.register_macro(&quot;rn&quot;, expand_rn);
  }</code></pre>
  <p>Теперь мы можем использовать <code>rn!()</code> как любой другой макрос:</p>
  <pre class="ignore"><code>#![feature(plugin)]
  #![plugin(roman_numerals)]
  
  fn main() {
      assert_eq!(rn!(MMXV), 2015);
  }</code></pre>
  <p>У этого подхода есть преимущества относительно простой функции <code>fn(&amp;str) -&gt; u32</code>:</p>
  <ul>
  <li>Преобразование (в общем случае, произвольной сложности) выполняется во время компиляции;</li>
  <li>Проверка правильности записи литерала также производится во время компиляции;</li>
  <li>Можно добавить возможность использования литерала в образцах (patterns), что по сути позволяет создавать литералы для любого типа данных.</li>
  </ul>
  <p>В дополнение к процедурным макросам, вы можете определять новые атрибуты <a href="http://doc.rust-lang.org/reference.html#derive"><code>derive</code></a> и другие виды расширений. Смотрите раздел <a href="http://doc.rust-lang.org/rustc/plugin/registry/struct.Registry.html#method.register_syntax_extension"><code>Registry::register_syntax_extension</code></a> и документацию <a href="http://doc.rust-lang.org/syntax/ext/base/enum.SyntaxExtension.html">перечисления <code>SyntaxExtension</code></a>. В качестве более продвинутого примера с макросами, можно ознакомиться с макросами регулярных выражений <a href="https://github.com/rust-lang/regex/blob/master/regex_macros/src/lib.rs"><code>regex_macros</code></a>.</p>
  <section id="советы-и-хитрости" class="level4">
  <h4>Советы и хитрости</h4>
  <p>Некоторые <a href="#debugging-macro-code">советы по отладке макросов</a> применимы и в случае плагинов.</p>
  <p>Можно использовать <a href="http://doc.rust-lang.org/syntax/parse/index.html"><code>syntax::parse</code></a>, чтобы преобразовать деревья токенов в высокоуровневые элементы синтаксиса, вроде выражений:</p>
  <pre class="ignore"><code>fn expand_foo(cx: &amp;mut ExtCtxt, sp: Span, args: &amp;[TokenTree])
          -&gt; Box&lt;MacResult+'static&gt; {
  
      let mut parser = cx.new_parser_from_tts(args);
  
      let expr: P&lt;Expr&gt; = parser.parse_expr();</code></pre>
  <p>Можно просмотреть код <a href="https://github.com/rust-lang/rust/blob/master/src/libsyntax/parse/parser.rs">парсера <code>libsyntax</code></a>, чтобы получить представление о работе инфраструктуры разбора.</p>
  <p>Сохраняйте <a href="http://doc.rust-lang.org/syntax/codemap/struct.Span.html"><code>Span</code>ы</a> всего, что вы разбираете, чтобы лучше сообщать об ошибках. Вы можете обернуть ваши структуры данных в <a href="http://doc.rust-lang.org/syntax/codemap/struct.Spanned.html"><code>Spanned</code></a>.</p>
  <p>Вызов <a href="http://doc.rust-lang.org/syntax/ext/base/struct.ExtCtxt.html#method.span_fatal"><code>ExtCtxt::span_fatal</code></a> сразу прервёт компиляцию. Вместо этого, лучше вызвать <a href="http://doc.rust-lang.org/syntax/ext/base/struct.ExtCtxt.html#method.span_err"><code>ExtCtxt::span_err</code></a> и вернуть <a href="http://doc.rust-lang.org/syntax/ext/base/struct.DummyResult.html"><code>DummyResult</code></a>, чтобы компилятор мог продолжить работу и обнаружить дальнейшие ошибки.</p>
  <p>Вы можете использовать <a href="http://doc.rust-lang.org/syntax/ext/base/struct.ExtCtxt.html#method.span_note"><code>span_note</code></a> и <a href="http://doc.rust-lang.org/syntax/print/pprust/index.html#functions"><code>syntax::print::pprust::*_to_string</code></a> чтобы напечатать синтаксический фрагмент для отладки.</p>
  <p>Пример выше создавал целочисленный литерал с помощью <a href="http://doc.rust-lang.org/syntax/ext/build/trait.AstBuilder.html#tymethod.expr_usize"><code>AstBuilder::expr_usize</code></a>. В качестве альтернативы типажу <code>AstBuilder</code>, <code>libsyntax</code> предоставляет набор <a href="http://doc.rust-lang.org/syntax/ext/quote/index.html">макросов квазицитирования</a>. Они не документированы и совсем не отполированы. Однако, эта реализация может стать неплохой основой для улучшенной библиотеки квазицитирования, которая работала бы как обычный плагин.</p>
  </section>
  </section>
  <section id="плагины-статических-проверок" class="level3">
  <h3>Плагины статических проверок</h3>
  <p>Плагины могут расширять <a href="http://doc.rust-lang.org/reference.html#lint-check-attributes">инфраструктуру статических проверок Rust</a>, предоставляя новые проверки стиля кодирования, безопасности, и т.д. Полный пример можно найти в <a href="https://github.com/rust-lang/rust/blob/master/src/test/auxiliary/lint_plugin_test.rs"><code>src/test/auxiliary/lint_plugin_test.rs</code></a>. Здесь мы приводим его суть:</p>
  <pre class="ignore"><code>declare_lint!(TEST_LINT, Warn,
                &quot;Предупреждать об элементах, названных 'lintme'&quot;);
  
  struct Pass;
  
  impl LintPass for Pass {
      fn get_lints(&amp;self) -&gt; LintArray {
          lint_array!(TEST_LINT)
      }
  
      fn check_item(&amp;mut self, cx: &amp;Context, it: &amp;ast::Item) {
          let name = token::get_ident(it.ident);
          if name.get() == &quot;lintme&quot; {
              cx.span_lint(TEST_LINT, it.span, &quot;элемент называется 'lintme'&quot;);
          }
      }
  }
  
  #[plugin_registrar]
  pub fn plugin_registrar(reg: &amp;mut Registry) {
      reg.register_lint_pass(box Pass as LintPassObject);
  }</code></pre>
  <p>Тогда код вроде</p>
  <pre class="ignore"><code>#![plugin(lint_plugin_test)]
  
  fn lintme() { }</code></pre>
  <p>выдаст предупреждение компилятора:</p>
  <pre class="txt"><code>foo.rs:4:1: 4:16 warning: item is named 'lintme', #[warn(test_lint)] on by default
  foo.rs:4 fn lintme() { }
           ^~~~~~~~~~~~~~~</code></pre>
  <p>Плагин статического анализа состоит из следующих частей:</p>
  <ul>
  <li><p>один или больше вызовов <code>declare_lint!</code>, которые определяют статические структуры <a href="http://doc.rust-lang.org/rustc/lint/struct.Lint.html"><code>Lint</code></a>;</p></li>
  <li><p>структура, содержащая состояние, необходимое анализатору (в данном случае, его нет);</p></li>
  <li><p>реализация типажа <a href="http://doc.rust-lang.org/rustc/lint/trait.LintPass.html"><code>LintPass</code></a>, определяющая, как проверять каждый элемент синтаксиса. Один <code>LintPass</code> может вызывать <code>span_lint</code> для нескольких различных <code>Lint</code>, но он должен зарегистрировать их все через метод <code>get_lints</code>.</p></li>
  </ul>
  <p>Проходы статического анализатора — это обходы синтаксического дерева, но они выполняются на поздних стадиях компиляции, когда уже доступа информация о типах. Встроенные в <code>rustc</code> <a href="https://github.com/rust-lang/rust/blob/master/src/librustc/lint/builtin.rs">анализы</a> в основном используют ту же инфрастуктуру, что и плагины статического анализа. Смотрите их исходный код, чтобы понять, как получать информацию о типах.</p>
  <p>Статические проверки, определяемые плагинами, управляются обычными <a href="http://doc.rust-lang.org/reference.html#lint-check-attributes">атрибутами и флагами компилятора</a>, т.е. <code>#[allow(test_lint)]</code> или <code>-A test-lint</code>. Эти идентификаторы выводятся из первого аргумента <code>declare_lint!</code>, с учётом соответствующих преобразований регистра букв и пунктуации.</p>
  <p>Вы можете выполнить команду <code>rustc -W help foo.rs</code>, чтобы увидеть весь список статических проверок, известных <code>rustc</code>, включая те, что загружаются из<code>foo.rs</code>.</p>
  </section>
  </section>
  <section id="sec--inline-assembly" class="level2">
  <h2>Встроенный ассемблерный код</h2>
  <p>Если вам нужно работать на самом низком уровне или повысить производительность программы, то у вас может возникнуть необходимость управлять процессором напрямую. Rust поддерживает использование встроенного ассемблера и делает это с помощью с помощью макроса <code>asm!</code>. Синтаксис примерно соответствует синтаксису GCC и Clang:</p>
  <pre class="ignore"><code>asm!(assembly template
     : output operands
     : input operands
     : clobbers
     : options
     );</code></pre>
  <p>Использование <code>asm</code> является закрытой возможностью (требуется указать <code>#![feature(asm)]</code> для контейнера, чтобы разрешить ее использование) и, конечно же, требует <code>unsafe</code> блока.</p>
  <blockquote>
  <p><strong>Примечание</strong>: здесь примеры приведены для x86/x86-64 ассемблера, но поддерживаются все платформы.</p>
  </blockquote>
  <section id="шаблон-инструкции-ассемблера" class="level4">
  <h4>Шаблон инструкции ассемблера</h4>
  <p>Шаблон инструкции ассемблера (assembly template) является единственным обязательным параметром, и он должен быть представлен строкой символов (т.е. <code>&quot;&quot;</code>)</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">#![feature(asm)]
  
  <span class="ot">#[</span>cfg<span class="ot">(</span>any<span class="ot">(</span>target_arch <span class="ot">=</span> <span class="st">&quot;x86&quot;</span><span class="ot">,</span> target_arch <span class="ot">=</span> <span class="st">&quot;x86_64&quot;</span><span class="ot">))]</span>
  <span class="kw">fn</span> foo() {
      <span class="kw">unsafe</span> {
          <span class="ot">asm!</span>(<span class="st">&quot;NOP&quot;</span>);
      }
  }
  
  <span class="co">// other platforms</span>
  <span class="ot">#[</span>cfg<span class="ot">(</span>not<span class="ot">(</span>any<span class="ot">(</span>target_arch <span class="ot">=</span> <span class="st">&quot;x86&quot;</span><span class="ot">,</span> target_arch <span class="ot">=</span> <span class="st">&quot;x86_64&quot;</span><span class="ot">)))]</span>
  <span class="kw">fn</span> foo() { <span class="co">/* ... */</span> }
  
  <span class="kw">fn</span> main() {
      <span class="co">// ...</span>
      foo();
      <span class="co">// ...</span>
  }</code></pre>
  <p>(Далее атрибуты <code>feature(asm)</code> и <code>#[cfg]</code> будут опущены.)</p>
  <p>Выходные операнды (output operands), входные операнды (input operands), затираемое (clobbers) и опции (options) не являются обязательными, но вы должны будете добавить соответствующее количество <code>:</code> если хотите пропустить их:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="ot">asm!</span>(<span class="st">&quot;xor %eax, %eax&quot;</span>
      :
      :
      : <span class="st">&quot;{eax}&quot;</span>
     );</code></pre>
  <p>Пробелы и отступы также не имеют значения:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="ot">asm!</span>(<span class="st">&quot;xor %eax, %eax&quot;</span> ::: <span class="st">&quot;{eax}&quot;</span>);</code></pre>
  </section>
  <section id="операнды" class="level4">
  <h4>Операнды</h4>
  <p>Входные и выходные операнды имеют одинаковый формат: <code>:&quot;ограничение1&quot;(выражение1), &quot;ограничение2&quot;(выражение2), ...&quot;</code>. Выражения для выходных операндов должны быть либо изменяемыми, либо неизменяемыми, но еще не иницилиализированными, L-значениями:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> add(a: <span class="kw">i32</span>, b: <span class="kw">i32</span>) -&gt; <span class="kw">i32</span> {
      <span class="kw">let</span> c: <span class="kw">i32</span>;
      <span class="kw">unsafe</span> {
          <span class="ot">asm!</span>(<span class="st">&quot;add $2, $0&quot;</span>
               : <span class="st">&quot;=r&quot;</span>(c)
               : <span class="st">&quot;0&quot;</span>(a), <span class="st">&quot;r&quot;</span>(b)
               );
      }
      c
  }
  
  <span class="kw">fn</span> main() {
      <span class="ot">assert_eq!</span>(add(<span class="dv">3</span>, <span class="dv">14159</span>), <span class="dv">14162</span>)
  }</code></pre>
  <p>Однако, если вы захотите использовать реальные операнды (регистры) в этой позиции, то вам потребуется заключить используемый регистр в фигурные скобки <code>{}</code>, и вы должны будете указать конкретный размер операнда. Это полезно для очень низкоуровневого программирования, когда важны регистры, которые вы используете:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> result: <span class="kw">u8</span>;
  <span class="ot">asm!</span>(<span class="st">&quot;in %dx, %al&quot;</span> : <span class="st">&quot;={al}&quot;</span>(result) : <span class="st">&quot;{dx}&quot;</span>(port));
  result</code></pre>
  </section>
  <section id="затираемое-clobbers" class="level4">
  <h4>Затираемое (Clobbers)</h4>
  <p>Некоторые инструкции могут изменять значения регистров, поэтому мы используем список затираемого. Он указывает компилятору, что тот не должен допускать какого-либо изменение значений этих регистров, чтобы они оставались корректными.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">// Put the value 0x200 in eax</span>
  <span class="ot">asm!</span>(<span class="st">&quot;mov $$0x200, %eax&quot;</span> : <span class="co">/* no outputs */</span> : <span class="co">/* no inputs */</span> : <span class="st">&quot;{eax}&quot;</span>);</code></pre>
  <p>Если входные и выходные регистры уже заданы в ограничениях, то их не нужно перечислять здесь. В противном случае, любые другие регистры, используемые явно или неявно, должны быть перечислены.</p>
  <p>Если ассемблер изменяет регистр кода условия <code>cc</code>, то он должен быть указан в качестве одного из затираемых. Точно так же, если ассемблер модифицирует память, то должно быть указано <code>memory</code>.</p>
  </section>
  <section id="опции" class="level4">
  <h4>Опции</h4>
  <p>Последний раздел, <code>options</code>, специфичен для Rust. Формат представляет собой разделенные запятыми текстовые строки (т.е. <code>:&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;</code>). Он используется для того, чтобы задать некоторые дополнительные данные для встроенного ассемблера:</p>
  <p>На текущий момент разрешены следующие опции:</p>
  <ol type="1">
  <li><p><em>volatile</em> — эта опция аналогична <code>__asm__ __volatile__ (...)</code> в gcc/clang;</p></li>
  <li><p><em>alignstack</em> — некоторые инструкции ожидают, что стек был выровнен определенным образом (т.е. SSE), и эта опция указывает компилятору вставить свой обычный код выравнивания стека;</p></li>
  <li><p><em>intel</em> — эта опция указывает использовать синтаксис Intel вместо используемого по умолчанию синтаксиса AT&amp;T.</p></li>
  </ol>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> result: <span class="kw">i32</span>;
  <span class="kw">unsafe</span> {
     <span class="ot">asm!</span>(<span class="st">&quot;mov eax, 2&quot;</span> : <span class="st">&quot;={eax}&quot;</span>(result) : : : <span class="st">&quot;intel&quot;</span>)
  }
  <span class="ot">println!</span>(<span class="st">&quot;eax is currently {}&quot;</span>, result);</code></pre>
  </section>
  <section id="больше-информации" class="level4">
  <h4>Больше информации</h4>
  <p>Текущая реализация макроса <code>asm!</code> — это прямое связывание с <a href="http://llvm.org/docs/LangRef.html#inline-assembler-expressions">встроенным ассемблером LLVM</a>, поэтому изучите и их <a href="http://llvm.org/docs/LangRef.html#inline-assembler-expressions">документацию</a>, чтобы лучше понять список затираемого, ограничения и др.</p>
  </section>
  </section>
  <section id="sec--no-stdlib" class="level2">
  <h2>Без stdlib</h2>
  <p>По умолчанию, <code>std</code> компонуется с каждым контейнером Rust. В некоторых случаях это нежелательно, и этого можно избежать с помощью атрибута <code>#![no_std]</code>, примененного (привязанного) к контейнеру.</p>
  <pre class="ignore"><code>// a minimal library
  #![crate_type=&quot;lib&quot;]
  #![feature(no_std)]
  #![no_std]
  # // fn main() {} tricked you, rustdoc!</code></pre>
  <p>Очевидно, должно быть нечто большее, чем просто библиотеки: <code>#[no_std]</code> можно использовать с исполняемыми контейнерами, а управлять точкой входа можно двумя способами: с помощью атрибута <code>#[start]</code>, или с помощью переопределения прокладки (shim) для C функции <code>main</code> по умолчанию на вашу собственную.</p>
  <p>В функцию, помеченную атрибутом <code>#[start]</code>, передаются параметры командной строки в том же формате, что и в C:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">#![feature(lang_items, start, no_std, libc)]
  #![no_std]
  
  <span class="co">// Pull in the system libc library for what crt0.o likely requires</span>
  <span class="kw">extern</span> crate libc;
  
  <span class="co">// Entry point for this program</span>
  <span class="ot">#[</span>start<span class="ot">]</span>
  <span class="kw">fn</span> start(_argc: isize, _argv: *const *const <span class="kw">u8</span>) -&gt; isize {
      <span class="dv">0</span>
  }
  
  <span class="co">// These functions and traits are used by the compiler, but not</span>
  <span class="co">// for a bare-bones hello world. These are normally</span>
  <span class="co">// provided by libstd.</span>
  <span class="ot">#[</span>lang <span class="ot">=</span> <span class="st">&quot;stack_exhausted&quot;</span><span class="ot">]</span> <span class="kw">extern</span> <span class="kw">fn</span> stack_exhausted() {}
  <span class="ot">#[</span>lang <span class="ot">=</span> <span class="st">&quot;eh_personality&quot;</span><span class="ot">]</span> <span class="kw">extern</span> <span class="kw">fn</span> eh_personality() {}
  <span class="ot">#[</span>lang <span class="ot">=</span> <span class="st">&quot;panic_fmt&quot;</span><span class="ot">]</span> <span class="kw">fn</span> panic_fmt() -&gt; ! { <span class="kw">loop</span> {} }</code></pre>
  <p>Чтобы переопределить вставленную компилятором прокладку <code>main</code>, нужно сначала отключить ее с помощью <code>#![no_main]</code>, а затем создать соответствующий символ с правильным ABI и правильным именем, что также потребует переопределение искажения (коверкания) имен компилятором (<code>#[no_mangle]</code>):</p>
  <pre class="ignore"><code>#![feature(no_std)]
  #![no_std]
  #![no_main]
  #![feature(lang_items, start)]
  
  extern crate libc;
  
  #[no_mangle] // для уверенности в том, что этот символ будет называться `main` на выхо
  ↳ де
  pub extern fn main(argc: i32, argv: *const *const u8) -&gt; i32 {
      0
  }
  
  #[lang = &quot;stack_exhausted&quot;] extern fn stack_exhausted() {}
  #[lang = &quot;eh_personality&quot;] extern fn eh_personality() {}
  #[lang = &quot;panic_fmt&quot;] fn panic_fmt() -&gt; ! { loop {} }
  # // fn main() {} tricked you, rustdoc!</code></pre>
  <p>В настоящее время компилятор делает определенные предположения о символах, которые доступны для вызова в исполняемом контейнере. Как правило, эти функции предоставляются стандартной библиотекой, но если она не используется, то вы должны определить их самостоятельно.</p>
  <p>Первая из этих трех функций, <code>stack_exhausted</code>, вызывается тогда, когда обнаруживается (происходит) переполнение стека. Эта функция имеет ряд ограничений, касающихся того, как она может быть вызвана и того, что она должна делать, но если регистр предела стека не поддерживается, то поток всегда имеет «бесконечный стек» и эта функция не должна быть вызвана (получить управление, срабатывать).</p>
  <p>Вторая из этих трех функций, <code>eh_personality</code>, используется в механизме обработки ошибок компилятора. Она часто отображается на функцию personality (специализации) GCC (для получения дополнительной информации смотри <a href="http://doc.rust-lang.org/std/rt/unwind/index.html">реализацию libstd</a>), но можно с уверенностью сказать, что для контейнеров, которые не вызывают панику, эта функция никогда не будет вызвана. Последняя функция, <code>panic_fmt</code>, также используются в механизме обработки ошибок компилятора.</p>
  <section id="использование-основной-библиотеки-libcore" class="level4">
  <h4>Использование основной библиотеки (libcore)</h4>
  <blockquote>
  <p><strong>Примечание</strong>: структура основной библиотеки (core) является нестабильной, и поэтому рекомендуется использовать стандартную библиотеку (std) там, где это возможно.</p>
  </blockquote>
  <p>С учетом указанных выше методов, у нас есть чисто-металлический исполняемый код работает Rust. Стандартная библиотека предоставляет немало функциональных возможностей, однако, для Rust также важна производительность. Если стандартная библиотека не соответствует этим требованиям, то вместо нее может быть использована <a href="http://doc.rust-lang.org/core/index.html">libcore</a>.</p>
  <p>Основная библиотека имеет очень мало зависимостей и гораздо более компактна, чем стандартная библиотека. Кроме того, основная библиотека имеет большую часть необходимой функциональности для написания идиоматического и эффективного кода на Rust.</p>
  <p>В качестве примера приведем программу, которая вычисляет скалярное произведение двух векторов, предоставленных из кода C, и использует идиоматические практики Rust.</p>
  <pre class="ignore"><code>#![feature(lang_items, start, no_std, core, libc)]
  #![no_std]
  
  # extern crate libc;
  extern crate core;
  
  use core::prelude::*;
  
  use core::mem;
  
  #[no_mangle]
  pub extern fn dot_product(a: *const u32, a_len: u32,
                            b: *const u32, b_len: u32) -&gt; u32 {
      use core::raw::Slice;
  
      // Convert the provided arrays into Rust slices.
      // The core::raw module guarantees that the Slice
      // structure has the same memory layout as a &amp;[T]
      // slice.
      //
      // This is an unsafe operation because the compiler
      // cannot tell the pointers are valid.
      let (a_slice, b_slice): (&amp;[u32], &amp;[u32]) = unsafe {
          mem::transmute((
              Slice { data: a, len: a_len as usize },
              Slice { data: b, len: b_len as usize },
          ))
      };
  
      // Iterate over the slices, collecting the result
      let mut ret = 0;
      for (i, j) in a_slice.iter().zip(b_slice.iter()) {
          ret += (*i) * (*j);
      }
      return ret;
  }
  
  #[lang = &quot;panic_fmt&quot;]
  extern fn panic_fmt(args: &amp;core::fmt::Arguments,
                      file: &amp;str,
                      line: u32) -&gt; ! {
      loop {}
  }
  
  #[lang = &quot;stack_exhausted&quot;] extern fn stack_exhausted() {}
  #[lang = &quot;eh_personality&quot;] extern fn eh_personality() {}
  # #[start] fn start(argc: isize, argv: *const *const u8) -&gt; isize { 0 }
  # fn main() {}</code></pre>
  <p>Обратите внимание, что здесь, в отличае от примеров, рассмотренных выше, есть один дополнительный lang элемент <code>panic_fmt</code>. Он должен быть определён потребителями libcore, потому что основная библиотека объявляет панику, но не определяет её. lang элемент <code>panic_fmt</code> определяет панику для этого контейнера, и необходимо гарантировать, что он никогда не возвращает значение.</p>
  <p>Как видно в этом примере, основная библиотека предназначена для предоставления всей мощи Rust при любых обстоятельствах, независимо от требований платформы. Дополнительные библиотеки, такие как liballoc, добавляют функциональность для libcore, для работы которой нужно сделать некоторые платформо-зависимые предположения; но эти библиотеки всё равно более переносимы, чем стандартная библиотека в целом.</p>
  </section>
  </section>
  <section id="sec--intrinsics" class="level2">
  <h2>Внутренние средства (intrinsics)</h2>
  <blockquote>
  <p><strong>Примечание</strong>: внутренние средства всегда будут иметь нестабильный интерфейс, рекомендуется использовать стабильные интерфейсы libcore, а не внутренние напрямую.</p>
  </blockquote>
  <p>Они импортируются как если бы они были FFI функциями, со специальным <code>rust- intrinsic</code> ABI. Например, если, находясь в отдельном (автономном) контексте, хочется иметь возможность <code>transmute</code> между типами, а также использовать эффективную арифметику указателей, то можно импортировать эти функции через объявление, такое как</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">
  <span class="kw">extern</span> <span class="st">&quot;rust-intrinsic&quot;</span> {
      <span class="kw">fn</span> transmute&lt;T, U&gt;(x: T) -&gt; U;
  
      <span class="kw">fn</span> offset&lt;T&gt;(dst: *const T, offset: isize) -&gt; *const T;
  }</code></pre>
  <p>Как и с любыми другими FFI функциями, их вызов всегда небезопасен и помечен как <code>unsafe</code>.</p>
  </section>
  <section id="sec--lang-items" class="level2">
  <h2>Элементы языка (lang items)</h2>
  <blockquote>
  <p><strong>Замечание</strong>: многие элементы языка предоставляются контейнерами в стандартной поставке Rust, а у самих элементов языка нестабильный интерфейс. Рекомендуется использовать официально распространяемые контейнеры, вместо того, чтобы определять свои собственные элементы языка.</p>
  </blockquote>
  <p>У компилятора <code>rustc</code> есть некоторые подключаемые операции, т.е. функционал, не встроенный жёстко в язык, а реализованный в библиотеках и специально помеченный как элемент языка. Метка — это атрибут <code>#[lang=&quot;...&quot;]</code>. Есть различные значения <code>...</code>, т.е. разные «элементы языка».</p>
  <p>Например, для указателей <code>Box</code> нужны два элемента языка — для выделения памяти и для освобождения. Вот программа, не использующая стандартную библиотеку, и реализующая <code>Box</code> через <code>malloc</code> и <code>free</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">#![feature(lang_items, box_syntax, start, no_std, libc)]
  #![no_std]
  
  <span class="kw">extern</span> crate libc;
  
  <span class="kw">extern</span> {
      <span class="kw">fn</span> abort() -&gt; !;
  }
  
  <span class="ot">#[</span>lang <span class="ot">=</span> <span class="st">&quot;owned_box&quot;</span><span class="ot">]</span>
  <span class="kw">pub</span> <span class="kw">struct</span> Box&lt;T&gt;(*<span class="kw">mut</span> T);
  
  <span class="ot">#[</span>lang<span class="ot">=</span><span class="st">&quot;exchange_malloc&quot;</span><span class="ot">]</span>
  <span class="kw">unsafe</span> <span class="kw">fn</span> allocate(size: usize, _align: usize) -&gt; *<span class="kw">mut</span> <span class="kw">u8</span> {
      <span class="kw">let</span> p = libc::malloc(size <span class="kw">as</span> libc::size_t) <span class="kw">as</span> *<span class="kw">mut</span> <span class="kw">u8</span>;
  
      <span class="co">// malloc завершился ошибкой</span>
      <span class="kw">if</span> p <span class="kw">as</span> usize == <span class="dv">0</span> {
          abort();
      }
  
      p
  }
  <span class="ot">#[</span>lang<span class="ot">=</span><span class="st">&quot;exchange_free&quot;</span><span class="ot">]</span>
  <span class="kw">unsafe</span> <span class="kw">fn</span> deallocate(ptr: *<span class="kw">mut</span> <span class="kw">u8</span>, _size: usize, _align: usize) {
      libc::free(ptr <span class="kw">as</span> *<span class="kw">mut</span> libc::c_void)
  }
  
  <span class="ot">#[</span>start<span class="ot">]</span>
  <span class="kw">fn</span> main(argc: isize, argv: *const *const <span class="kw">u8</span>) -&gt; isize {
      <span class="kw">let</span> x = box <span class="dv">1</span>;
  
      <span class="dv">0</span>
  }
  
  <span class="ot">#[</span>lang <span class="ot">=</span> <span class="st">&quot;stack_exhausted&quot;</span><span class="ot">]</span> <span class="kw">extern</span> <span class="kw">fn</span> stack_exhausted() {}
  <span class="ot">#[</span>lang <span class="ot">=</span> <span class="st">&quot;eh_personality&quot;</span><span class="ot">]</span> <span class="kw">extern</span> <span class="kw">fn</span> eh_personality() {}
  <span class="ot">#[</span>lang <span class="ot">=</span> <span class="st">&quot;panic_fmt&quot;</span><span class="ot">]</span> <span class="kw">fn</span> panic_fmt() -&gt; ! { <span class="kw">loop</span> {} }</code></pre>
  <p>Заметьте, что <code>exchange_malloc</code> должен возвращать допустимый указатель, поэтому он производит проверку внутри и делает <code>abort</code>, если она не прошла.</p>
  <p>Ниже перечислены другие возможности, предоставляемые элементами языка:</p>
  <ul>
  <li>перегружаемые операторы через типажи: типажи, соответствующие <code>==</code>, <code>&lt;</code>, разыменованию (<code>*</code>), <code>+</code> и другим операторам, помечены как элементы языка; конкретно эти типажи помечены как <code>eq</code>, <code>ord</code>, <code>deref</code> и <code>add</code>;</li>
  <li>раскрутка стека и общая ошибка; это элементы <code>eh_personality</code>, <code>fail</code> и <code>fail_bounds_check</code>;</li>
  <li>типажи в модуле <code>std::marker</code>, используемые чтобы помечать различные типы; элементы <code>send</code>, <code>sync</code> и <code>copy</code>;</li>
  <li>типы-метки и индикаторы вариантности из <code>std::marker</code>; это элементы <code>covariant_type</code>, <code>contravariant_lifetime</code> и другие.</li>
  </ul>
  <p>Элементы языка загружаются компилятором лениво, т.е. если программа не использует <code>Box</code>, вам не нужно определять элементы <code>exchange_malloc</code> и <code>exchange_free</code>. <code>rustc</code> выдаст ошибку, если элемент языка необходим, но не найден ни в текущем контейнере, ни в его зависимостях.</p>
  </section>
  <section id="sec--advanced-linking" class="level2">
  <h2>Продвинутое руководство по компоновке (advanced linking)</h2>
  <p>Распространённые ситуации, в которых требовалась компоновка с кодом на Rust, уже были рассмотрены в предыдущих главах книги. Однако для поддержки прозрачного взаимодействия с нативными библиотеками требуется более широкая поддержка разных вариантов компоновки.</p>
  <section id="аргументы-компоновки-link-args" class="level3">
  <h3>Аргументы компоновки (link args)</h3>
  <p>Есть только один способ тонкой настройки компоновки — атрибут <code>link_args</code>. Этот атрибут применяется к блокам <code>extern</code>, и указывает сырые аргументы, которые должны быть переданы компоновщику при создании артефакта. Например:</p>
  <pre class="no_run"><code>#![feature(link_args)]
  
  #[link_args = &quot;-foo -bar -baz&quot;]
  extern {}
  # fn main() {}</code></pre>
  <p>Обратите внимание, что эта возможность скрыта за <code>feature(link_args)</code>, так как это нештатный способ компоновки. В данный момент <code>rustc</code> вызывает системный компоновщик (на большинстве систем это <code>gcc</code>, на Windows — <code>link.exe</code>), поэтому передача аргументов командной строки имеет смысл. Но реализация не всегда будет такой — в будущем <code>rustc</code> может напрямую использовать LLVM для связывания с нативными библиотеками, и тогда <code>link_args</code> станет бессмысленным. Того же эффекта можно достигнуть с пощощью передачи <code>rustc</code> аргумента <code>-C link-args</code>.</p>
  <p>Крайне рекомендуется <em>не</em> использовать этот атрибут, и пользоваться вместо него более точно определённым атрибутом <code>#link(...)</code> для блоков <code>extern</code>.</p>
  </section>
  <section id="статическое-связывание" class="level3">
  <h3>Статическое связывание</h3>
  <p>Статическое связывание — это процесс создания артефакта, который содержит все нужные библиотеки, и потому не потребует установленных библиотек на целевой системе. Библиотеки на Rust по умолчанию связываются статически, поэтому приложения и библиотеки на Rust можно использовать без установки Rust повсюду. Напротив, нативные библиотеки (например, <code>libc</code> и <code>libm</code>) обычно связываются динамически, но это можно изменить, и сделать чтобы они также связывались статически.</p>
  <p>Компоновка — это процесс, который реализуется по-разному на разных платформах. На некоторых из них статическое связывание вообще не возможно! Этот раздел предполагает знакомство с процессом компоновки на вашей платформе.</p>
  <section id="linux" class="level4">
  <h4>Linux</h4>
  <p>По умолчанию, программы на Rust для Linux компонуются с системной <code>libc</code> и ещё некоторыми библиотеками. Давайте посмотрим на пример на 64-битной машине с Linux, GCC и <code>glibc</code> (самой популярной <code>libc</code> на Linux):</p>
  <pre class="text"><code>$ cat example.rs
  fn main() {}
  $ rustc example.rs
  $ ldd example
          linux-vdso.so.1 =&gt;  (0x00007ffd565fd000)
          libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007fa81889c000)
          libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007fa81867e000)
          librt.so.1 =&gt; /lib/x86_64-linux-gnu/librt.so.1 (0x00007fa818475000)
          libgcc_s.so.1 =&gt; /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007fa81825f000)
          libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fa817e9a000)
          /lib64/ld-linux-x86-64.so.2 (0x00007fa818cf9000)
          libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007fa817b93000)</code></pre>
  <p>Иногда динамическое связывание на Linux нежелательно: например, если вы хотите использовать возможности из новых библиотек на старых системах или на целевых системах нет таких библиотек.</p>
  <p>Статическое связывание возможно с альтернативной <code>libc</code>, <code>musl</code>. Вы можете скомпилировать свою версию Rust, которая будет использовать <code>musl</code>, и установить её в отдельную директорию, с помощью инструкции, приведённой ниже:</p>
  <pre class="text"><code>$ mkdir musldist
  $ PREFIX=$(pwd)/musldist
  $
  $ # Build musl
  $ wget http://www.musl-libc.org/releases/musl-1.1.10.tar.gz
  [...]
  $ tar xf musl-1.1.10.tar.gz
  $ cd musl-1.1.10/
  musl-1.1.10 $ ./configure --disable-shared --prefix=$PREFIX
  [...]
  musl-1.1.10 $ make
  [...]
  musl-1.1.10 $ make install
  [...]
  musl-1.1.10 $ cd ..
  $ du -h musldist/lib/libc.a
  2.2M    musldist/lib/libc.a
  $
  $ # Build libunwind.a
  $ wget http://llvm.org/releases/3.6.1/llvm-3.6.1.src.tar.xz
  $ tar xf llvm-3.6.1.src.tar.xz
  $ cd llvm-3.6.1.src/projects/
  llvm-3.6.1.src/projects $ svn co http://llvm.org/svn/llvm-project/libcxxabi/trunk/ lib
  ↳ cxxabi
  llvm-3.6.1.src/projects $ svn co http://llvm.org/svn/llvm-project/libunwind/trunk/ lib
  ↳ unwind
  llvm-3.6.1.src/projects $ sed -i 's#^\(include_directories\).*$#\0\n\1(../libcxxabi/in
  ↳ clude)#' libunwind/CMakeLists.txt
  llvm-3.6.1.src/projects $ mkdir libunwind/build
  llvm-3.6.1.src/projects $ cd libunwind/build
  llvm-3.6.1.src/projects/libunwind/build $ cmake -DLLVM_PATH=../../.. -DLIBUNWIND_ENABL
  ↳ E_SHARED=0 ..
  llvm-3.6.1.src/projects/libunwind/build $ make
  llvm-3.6.1.src/projects/libunwind/build $ cp lib/libunwind.a $PREFIX/lib/
  llvm-3.6.1.src/projects/libunwind/build $ cd cd ../../../../
  $ du -h musldist/lib/libunwind.a
  164K    musldist/lib/libunwind.a
  $
  $ # Build musl-enabled rust
  $ git clone https://github.com/rust-lang/rust.git muslrust
  $ cd muslrust
  muslrust $ ./configure --target=x86_64-unknown-linux-musl --musl-root=$PREFIX --prefix
  ↳ =$PREFIX
  muslrust $ make
  muslrust $ make install
  muslrust $ cd ..
  $ du -h musldist/bin/rustc
  12K     musldist/bin/rustc</code></pre>
  <p>Теперь у вас есть сборка Rust с <code>musl</code>! Поскольку мы установили её в отдельную корневую директорию, надо удостовериться в том, что система может найти исполняемые файлы и библиотеки:</p>
  <pre class="text"><code>$ export PATH=$PREFIX/bin:$PATH
  $ export LD_LIBRARY_PATH=$PREFIX/lib:$LD_LIBRARY_PATH</code></pre>
  <p>Давайте попробуем!</p>
  <pre class="text"><code>$ echo 'fn main() { println!(&quot;hi!&quot;); panic!(&quot;failed&quot;); }' &gt; example.rs
  $ rustc --target=x86_64-unknown-linux-musl example.rs
  $ ldd example
          not a dynamic executable
  $ ./example
  hi!
  thread '&lt;main&gt;' panicked at 'failed', example.rs:1</code></pre>
  <p>Успех! Эта программа может быть скопирована на почти любую машину с Linux с той же архитектурой процессора и будет работать без проблем.</p>
  <p><code>cargo build</code> также принимает опцию <code>--target</code>, так что вы можете собирать контейнеры как обычно. Однако, возможно вам придётся пересобрать нативные библиотеки с <code>musl</code>, чтобы иметь возможность скомпоноваться с ними.</p>
  </section>
  </section>
  </section>
  <section id="sec--benchmark-tests" class="level2">
  <h2>Тесты производительности</h2>
  <p>Rust поддерживает тесты производительности, которые помогают измерить производительность вашего кода. Давайте изменим наш <code>src/lib.rs</code>, чтобы он выглядел следующим образом (комментарии опущены):</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">#![feature(test)]
  
  <span class="kw">extern</span> crate test;
  
  <span class="kw">pub</span> <span class="kw">fn</span> add_two(a: <span class="kw">i32</span>) -&gt; <span class="kw">i32</span> {
      a + <span class="dv">2</span>
  }
  
  <span class="ot">#[</span>cfg<span class="ot">(</span>test<span class="ot">)]</span>
  <span class="kw">mod</span> tests {
      <span class="kw">use</span> <span class="kw">super</span>::*;
      <span class="kw">use</span> test::Bencher;
  
      <span class="ot">#[</span>test<span class="ot">]</span>
      <span class="kw">fn</span> it_works() {
          <span class="ot">assert_eq!</span>(<span class="dv">4</span>, add_two(<span class="dv">2</span>));
      }
  
      <span class="ot">#[</span>bench<span class="ot">]</span>
      <span class="kw">fn</span> bench_add_two(b: &amp;<span class="kw">mut</span> Bencher) {
          b.iter(|| add_two(<span class="dv">2</span>));
      }
  }</code></pre>
  <p>Обратите внимание на включение возможности (feature gate) <code>test</code>, что включает эту нестабильную возможность.</p>
  <p>Мы импортировали контейнер <code>test</code>, который включает поддержку измерения производительности. У нас есть новая функция, аннотированная с помощью атрибута <code>bench</code>. В отличие от обычных тестов, которые не принимают никаких аргументов, тесты производительности в качестве аргумента принимают <code>&amp;mut Bencher</code>. <code>Bencher</code> предоставляет метод <code>iter</code>, который в качестве аргумента принимает замыкание. Это замыкание содержит код, производительность которого мы хотели бы протестировать.</p>
  <p>Запуск тестов производительности осуществляется командой <code>cargo bench</code>:</p>
  <pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">cargo</span> bench
     <span class="kw">Compiling</span> adder v0.0.1 (file:///home/steve/tmp/adder)
       <span class="kw">Running</span> target/release/adder-91b3e234d4ed382a
  
  <span class="kw">running</span> 2 tests
  <span class="kw">test</span> tests::it_works ... ignored
  <span class="kw">test</span> tests::bench_add_two ... bench:         1 ns/iter (+/- 0)
  
  <span class="kw">test</span> result: ok. 0 passed<span class="kw">;</span> <span class="kw">0</span> failed<span class="kw">;</span> <span class="kw">1</span> ignored<span class="kw">;</span> <span class="kw">1</span> measured</code></pre>
  <p>Все тесты, не относящиеся к тестам производительности, были проигнорированы. Вы, наверное, заметили, что выполнение <code>cargo bench</code> занимает немного больше времени чем <code>cargo test</code>. Это происходит потому, что Rust запускает наш тест несколько раз, а затем выдает среднее значение. Так как мы выполняем слишком мало полезной работы в этом примере, у нас получается <code>1 ns/iter (+/- 0)</code>, но была бы выведена дисперсия, если бы был один.</p>
  <p>Советы по написанию тестов производительности:</p>
  <ul>
  <li>Внутри <code>iter</code> цикла пишите только тот код, производительность которого вы хотите измерить; инициализацию выполняйте за пределами <code>iter</code> цикла</li>
  <li>Внутри <code>iter</code> цикла пишите код, который будет идемпотентным (будет делать «то же самое» на каждой итерации); не накапливайте и не изменяйте состояние</li>
  <li>Вне <code>iter</code> цикла пишите код который также будет идемпотентным; скорее всего, он будет запущен много раз во время теста</li>
  <li>Внутри <code>iter</code> цикла пишите код, который будет коротким и быстрым, так чтобы запуски тестов происходили быстро и калибратор мог настроить длину пробега с точным разрешением</li>
  <li>Внутри <code>iter</code> цикла пишите код, делающий что-то простое, чтобы помочь в выявлении улучшения (или уменьшения) производительности</li>
  </ul>
  <section id="особенности-оптимизации" class="level4">
  <h4>Особенности оптимизации</h4>
  <p>А вот другой сложный момент, относящийся к написанию тестов производительности: тесты, скомпилированные с оптимизацией, могут быть значительно изменены оптимизатором, после чего тест будет мерить производительность не так, как мы этого ожидаем. Например, компилятор может определить, что некоторые выражения не оказывают каких-либо внешних эффектов и просто удалит их полностью.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">#![feature(test)]
  
  <span class="kw">extern</span> crate test;
  <span class="kw">use</span> test::Bencher;
  
  <span class="ot">#[</span>bench<span class="ot">]</span>
  <span class="kw">fn</span> bench_xor_1000_ints(b: &amp;<span class="kw">mut</span> Bencher) {
      b.iter(|| {
          (<span class="dv">0.</span>.<span class="dv">1000</span>).fold(<span class="dv">0</span>, |old, new| old ^ new);
      });
  }</code></pre>
  <p>выведет следующие результаты</p>
  <pre class="text"><code>running 1 test
  test bench_xor_1000_ints ... bench:         0 ns/iter (+/- 0)
  
  test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured</code></pre>
  <p>Движок для запуска тестов производительности оставляет две возможности, позволяющие этого избежать. Либо использовать замыкание, передаваемое в метод <code>iter</code>, которое возвращает какое-либо значение; тогда это заставит оптимизатор думать, что возвращаемое значение будет использовано, из-за чего удалить вычисления полностью будет не возможно. Для примера выше этого можно достигнуть, изменив вызова <code>b.iter</code></p>
  <pre class="sourceCode rust"><code class="sourceCode rust">b.iter(|| {
      <span class="co">// note lack of `;` (could also use an explicit `return`).</span>
      (<span class="dv">0.</span>.<span class="dv">1000</span>).fold(<span class="dv">0</span>, |old, new| old ^ new)
  });</code></pre>
  <p>Либо использовать вызов функции <code>test::black_box</code>, которая представляет собой «черный ящик», непрозрачный для оптимизатора, тем самым заставляя его рассматривать любой аргумент как используемый.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">#![feature(test)]
  
  <span class="kw">extern</span> crate test;
  
  b.iter(|| {
      <span class="kw">let</span> n = test::black_box(<span class="dv">1000</span>);
  
      (<span class="dv">0.</span>.n).fold(<span class="dv">0</span>, |a, b| a ^ b)
  })</code></pre>
  <p>В этом примере не происходит ни чтения, ни изменения значения, что очень дешево для малых значений. Большие значения могут быть переданы косвенно для уменьшения издержек (например, <code>black_box(&amp;huge_struct)</code>).</p>
  <p>Выполнение одного из вышеперечисленных изменений дает следующие результаты измерения производительности</p>
  <pre class="text"><code>running 1 test
  test bench_xor_1000_ints ... bench:       131 ns/iter (+/- 3)
  
  test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured</code></pre>
  <p>Тем не менее, оптимизатор все еще может вносить нежелательные изменения в определенных случаях, даже при использовании любого из вышеописанных приемов.</p>
  </section>
  </section>
  <section id="sec--box-syntax-and-patterns" class="level2">
  <h2>Синтаксис упаковки и шаблоны <code>match</code></h2>
  <p>В настоящее время единственный стабильный способ создания <code>Box</code> — это создание с помощью метода <code>Box::new</code>. В стабильной сборке Rust также невозможно деструктурировать <code>Box</code> при использовании сопоставления с шаблоном. В нестабильной сборке может быть использовано ключевое слово <code>box</code>, как для создания, так и для деструктуризации <code>Box</code>. Ниже представлен пример использования:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">#![feature(box_syntax, box_patterns)]
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> b = <span class="kw">Some</span>(box <span class="dv">5</span>);
      <span class="kw">match</span> b {
          <span class="kw">Some</span>(box n) <span class="kw">if</span> n &lt; <span class="dv">0</span> =&gt; {
              <span class="ot">println!</span>(<span class="st">&quot;Box contains negative number {}&quot;</span>, n);
          },
          <span class="kw">Some</span>(box n) <span class="kw">if</span> n &gt;= <span class="dv">0</span> =&gt; {
              <span class="ot">println!</span>(<span class="st">&quot;Box contains non-negative number {}&quot;</span>, n);
          },
          <span class="kw">None</span> =&gt; {
              <span class="ot">println!</span>(<span class="st">&quot;No box&quot;</span>);
          },
          _ =&gt; <span class="ot">unreachable!</span>()
      }
  }</code></pre>
  <p>Обратите внимание, что эти возможности в настоящее время являются скрытыми: <code>box_syntax</code> (создание упаковки) и <code>box_patterns</code> (деструктурирование и сопоставление с образцом), потому что синтаксис все еще может измениться в будущем.</p>
  <section id="возврат-указателей" class="level3">
  <h3>Возврат указателей</h3>
  <p>Во многих языках с указателями, вы можете вернуть указатель из функции, чтобы таким образом избежать копирования большой структуры данных. Например:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">struct</span> BigStruct {
      one: <span class="kw">i32</span>,
      two: <span class="kw">i32</span>,
      <span class="co">// etc</span>
      one_hundred: <span class="kw">i32</span>,
  }
  
  <span class="kw">fn</span> foo(x: Box&lt;BigStruct&gt;) -&gt; Box&lt;BigStruct&gt; {
      Box::new(*x)
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> x = Box::new(BigStruct {
          one: <span class="dv">1</span>,
          two: <span class="dv">2</span>,
          one_hundred: <span class="dv">100</span>,
      });
  
      <span class="kw">let</span> y = foo(x);
  }</code></pre>
  <p>Идея состоит в том, что, при передаче упаковки, происходит копирование только указателя, а не всех <code>int</code>, из которых состоит <code>BigStruct</code>.</p>
  <p>Это антипаттерн в Rust. Вместо этого следует написать так:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">#![feature(box_syntax)]
  
  <span class="kw">struct</span> BigStruct {
      one: <span class="kw">i32</span>,
      two: <span class="kw">i32</span>,
      <span class="co">// etc</span>
      one_hundred: <span class="kw">i32</span>,
  }
  
  <span class="kw">fn</span> foo(x: Box&lt;BigStruct&gt;) -&gt; BigStruct {
      *x
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> x = Box::new(BigStruct {
          one: <span class="dv">1</span>,
          two: <span class="dv">2</span>,
          one_hundred: <span class="dv">100</span>,
      });
  
      <span class="kw">let</span> y: Box&lt;BigStruct&gt; = box foo(x);
  }</code></pre>
  <p>Это дает вам гибкость без ущерба для производительности.</p>
  <p>Вы можете подумать, что такое использование даст нам ужасную производительность: возвращается значение, а затем оно сразу упаковывается?! Разве это не паттерн худшего из двух миров? Rust намного умнее. В этом коде не происходит копирование. <code>main</code> выделяет достаточно места для <code>box</code>, передает указатель на эту память в <code>foo</code> в виде <code>x</code>, а затем <code>foo</code> записывает значение прямо в <code>Box&lt;T&gt;</code>.</p>
  <p>Это достаточно важно, поэтому стоит повторить: указатели не для оптимизации возвращаемых значений в коде. Позвольте вызывающей стороне самой выбрать, как она хочет использовать выход.</p>
  </section>
  </section>
  <section id="sec--slice-patterns" class="level2">
  <h2>Шаблоны <code>match</code> для срезов</h2>
  <p>Если вы хотите в качестве шаблона для сопоставления использовать срез или массив, то вы можете использовать <code>&amp;</code> и активировать возможность <code>slice_patterns</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">#![feature(slice_patterns)]
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> v = <span class="ot">vec!</span>[<span class="st">&quot;match_this&quot;</span>, <span class="st">&quot;1&quot;</span>];
  
      <span class="kw">match</span> &amp;v[..] {
          [<span class="st">&quot;match_this&quot;</span>, second] =&gt; <span class="ot">println!</span>(<span class="st">&quot;The second element is {}&quot;</span>, second),
          _ =&gt; {},
      }
  }</code></pre>
  <p>Отключаемая возможность <code>advanced_slice_patterns</code> позволяет использовать <code>..</code>, чтобы обозначить любое число элементов в шаблоне. Этот символ подстановки можно использовать в массиве один раз. Если перед <code>..</code> есть идентификатор, результат среза будет связан с этим именем. Например:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">#![feature(advanced_slice_patterns, slice_patterns)]
  
  <span class="kw">fn</span> is_symmetric(list: &amp;[<span class="kw">u32</span>]) -&gt; <span class="kw">bool</span> {
      <span class="kw">match</span> list {
          [] | [_] =&gt; <span class="kw">true</span>,
          [x, inside.., y] <span class="kw">if</span> x == y =&gt; is_symmetric(inside),
          _ =&gt; <span class="kw">false</span>
      }
  }
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> sym = &amp;[<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">0</span>];
      <span class="ot">assert!</span>(is_symmetric(sym));
  
      <span class="kw">let</span> not_sym = &amp;[<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">7</span>, <span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">0</span>];
      <span class="ot">assert!</span>(!is_symmetric(not_sym));
  }</code></pre>
  </section>
  <section id="sec--associated-constants" class="level2">
  <h2>Ассоциированные константы</h2>
  <p>С включенной возможностью <code>associated_consts</code> вы можете определить константы вроде этой:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">#![feature(associated_consts)]
  
  <span class="kw">trait</span> Foo {
      const ID: <span class="kw">i32</span>;
  }
  
  <span class="kw">impl</span> Foo <span class="kw">for</span> <span class="kw">i32</span> {
      const ID: <span class="kw">i32</span> = <span class="dv">1</span>;
  }
  
  <span class="kw">fn</span> main() {
      <span class="ot">assert_eq!</span>(<span class="dv">1</span>, <span class="kw">i32</span>::ID);
  }</code></pre>
  <p>Любая реализация <code>Foo</code> должна будет определить <code>ID</code>. Без этого определения:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">#![feature(associated_consts)]
  
  <span class="kw">trait</span> Foo {
      const ID: <span class="kw">i32</span>;
  }
  
  <span class="kw">impl</span> Foo <span class="kw">for</span> <span class="kw">i32</span> {
  }</code></pre>
  <p>выдаст ошибку</p>
  <pre class="text"><code>error: not all trait items implemented, missing: `ID` [E0046]
       impl Foo for i32 {
       }</code></pre>
  <p>Также может быть реализовано значение по умолчанию:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">#![feature(associated_consts)]
  
  <span class="kw">trait</span> Foo {
      const ID: <span class="kw">i32</span> = <span class="dv">1</span>;
  }
  
  <span class="kw">impl</span> Foo <span class="kw">for</span> <span class="kw">i32</span> {
  }
  
  <span class="kw">impl</span> Foo <span class="kw">for</span> <span class="kw">i64</span> {
      const ID: <span class="kw">i32</span> = <span class="dv">5</span>;
  }
  
  <span class="kw">fn</span> main() {
      <span class="ot">assert_eq!</span>(<span class="dv">1</span>, <span class="kw">i32</span>::ID);
      <span class="ot">assert_eq!</span>(<span class="dv">5</span>, <span class="kw">i64</span>::ID);
  }</code></pre>
  <p>Как вы можете видеть, при реализации <code>Foo</code>, можно оставить константу неопределенной, как в случае для <code>i32</code>. Тогда будет использовано значение по умолчанию. Но также можно и добавить собственное определение, как в случае для <code>i64</code>.</p>
  <p>Ассоциированные константы могут быть ассоциированы не только с типажом. Это также прекрасно работает и с блоком <code>impl</code> для <code>struct</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">#![feature(associated_consts)]
  
  <span class="kw">struct</span> Foo;
  
  <span class="kw">impl</span> Foo {
      <span class="kw">pub</span> const FOO: <span class="kw">u32</span> = <span class="dv">3</span>;
  }</code></pre>
  </section>
  <section id="sec--custom-allocators" class="level2">
  <h2>Пользовательские менеджеры памяти</h2>
  <p>Выделение памяти — это не самая простая задача, и Rust обычно заботится об этом сам, но часто нужно тонко управлять выделением памяти. Компилятор и стандартная библиотека в настоящее время позволяют глобально переключить используемый менеджер во время компиляции. Описание сейчас находится в <a href="https://github.com/rust-lang/rfcs/blob/master/text/1183-swap-out-jemalloc.md">RFC 1183</a>, но здесь мы рассмотрим как сделать ваш собственный менеджер.</p>
  <section id="стандартный-менеджер-памяти" class="level3">
  <h3>Стандартный менеджер памяти</h3>
  <p>В настоящее время компилятор содержит два стандартных менеджера: <code>alloc_system</code> и <code>alloc_jemalloc</code> (однако у некоторых платформ отсутствует jemalloc). Эти менеджеры стандартны для контейнеров Rust и содержат реализацию подпрограмм для выделения и освобождения памяти. Стандартная библиотека не компилируется специально для использования только одного из них. Компилятор будет решать какой менеджер использовать во время компиляции в зависимости от типа производимых выходных артефактов.</p>
  <p>По умолчанию исполняемые файлы сгенерированные компилятором будут использовать <code>alloc_jemalloc</code> (там где возможно). В таком случае компилятор “контролирует весь мир”, в том смысле что у него есть власть над окончательной компоновкой.</p>
  <p>Однако динамические и статические библиотеки по умолчанию будут использовать <code>alloc_system</code>. Здесь Rust обычно в роли гостя в другом приложении или вообще в другом мире, где он не может авторитетно решать какой менеджер использовать. В результате он возвращается назад к стандартным API (таких как <code>malloc</code> и <code>free</code>), для получения и освобождения памяти.</p>
  </section>
  <section id="переключение-менеджеров-памяти" class="level3">
  <h3>Переключение менеджеров памяти</h3>
  <p>Несмотря на то что в большинстве случаев нам подойдёт то, что компилятор выбирает по умолчанию, часто бывает необходимо настроить определенные аспекты. Для того, чтобы переопределить решение компилятора о том, какой именно менеджер использовать, достаточно просто скомпоновать с желаемым менеджером:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">#![feature(alloc_system)]
  
  <span class="kw">extern</span> crate alloc_system;
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> a = Box::new(<span class="dv">4</span>); <span class="co">// выделение памяти с помощью системного менеджера</span>
      <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, a);
  }</code></pre>
  <p>В этом примере сгенерированный исполняемый файл будет скомпонован с системным менеджером, вместо менеджера по умолчанию — jemalloc. И наоборот, чтобы сгенерировать динамическую библиотеку, которая использует jemalloc по умолчанию нужно написать:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust">#![feature(alloc_jemalloc)]
  #![crate_type = <span class="st">&quot;dylib&quot;</span>]
  
  <span class="kw">extern</span> crate alloc_jemalloc;
  
  <span class="kw">pub</span> <span class="kw">fn</span> foo() {
      <span class="kw">let</span> a = Box::new(<span class="dv">4</span>); <span class="co">// выделение памяти с помощью jemalloc</span>
      <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, a);
  }</code></pre>
  </section>
  <section id="написание-своего-менеджера-памяти" class="level3">
  <h3>Написание своего менеджера памяти</h3>
  <p>Иногда даже выбора между jemalloc и системным менеджером недостаточно и необходим совершенно новый менеджер памяти. В этом случае мы напишем наш собственный контейнер, который будет предоставлять API менеджера памяти (также как и <code>alloc_system</code> или <code>alloc_jemalloc</code>). Для примера давайте рассмотрим упрощенную и аннотированную версию <code>alloc_system</code>:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">// Компилятору нужно указать, что этот контейнер является менеджером памяти, для</span>
  <span class="co">// того что бы при компоновке он не использовал другой менеджер.</span>
  #![feature(allocator)]
  #![allocator]
  
  <span class="co">// Менеджерам памяти не позволяют зависеть от стандартной библиотеки, которая в</span>
  <span class="co">// свою очередь зависит от менеджера, чтобы избежать циклической зависимости.</span>
  <span class="co">// Однако этот контейнер может использовать все из libcore.</span>
  #![no_std]
  
  <span class="co">// Давайте дадим какое-нибудь уникальное имя нашему менеджеру.</span>
  #![crate_name = <span class="st">&quot;my_allocator&quot;</span>]
  #![crate_type = <span class="st">&quot;rlib&quot;</span>]
  
  <span class="co">// Наш системный менеджер будет использовать поставляемый вместе с компилятором</span>
  <span class="co">// контейнер libc для связи с FFI. Имейте ввиду, что на данный момент внешний</span>
  <span class="co">// (crates.io) libc не может быть использован, поскольку он компонуется со</span>
  <span class="co">// стандартной библиотекой (`#![no_std]` все еще нестабилен).</span>
  #![feature(libc)]
  <span class="kw">extern</span> crate libc;
  
  <span class="co">// Ниже перечислены пять функций, необходимые пользовательскому менеджеру памяти.</span>
  <span class="co">// Их сигнатуры и имена на данный момент не проверяются компилятором, но это</span>
  <span class="co">// вскоре будет реализовано, так что они должны соответствовать тому, что</span>
  <span class="co">// находится ниже.</span>
  <span class="co">//</span>
  <span class="co">// Имейте ввиду, что стандартные `malloc` и `realloc` не предоставляют опций для</span>
  <span class="co">// выравнивания, так что эта реализация должна быть улучшена и поддерживать</span>
  <span class="co">// выравнивание.</span>
  <span class="ot">#[</span>no_mangle<span class="ot">]</span>
  <span class="kw">pub</span> <span class="kw">extern</span> <span class="kw">fn</span> __rust_allocate(size: usize, _align: usize) -&gt; *<span class="kw">mut</span> <span class="kw">u8</span> {
      <span class="kw">unsafe</span> { libc::malloc(size <span class="kw">as</span> libc::size_t) <span class="kw">as</span> *<span class="kw">mut</span> <span class="kw">u8</span> }
  }
  
  <span class="ot">#[</span>no_mangle<span class="ot">]</span>
  <span class="kw">pub</span> <span class="kw">extern</span> <span class="kw">fn</span> __rust_deallocate(ptr: *<span class="kw">mut</span> <span class="kw">u8</span>, _old_size: usize, _align: usize) {
      <span class="kw">unsafe</span> { libc::free(ptr <span class="kw">as</span> *<span class="kw">mut</span> libc::c_void) }
  }
  
  <span class="ot">#[</span>no_mangle<span class="ot">]</span>
  <span class="kw">pub</span> <span class="kw">extern</span> <span class="kw">fn</span> __rust_reallocate(ptr: *<span class="kw">mut</span> <span class="kw">u8</span>, _old_size: usize, size: usize,
                                  _align: usize) -&gt; *<span class="kw">mut</span> <span class="kw">u8</span> {
      <span class="kw">unsafe</span> {
          libc::realloc(ptr <span class="kw">as</span> *<span class="kw">mut</span> libc::c_void, size <span class="kw">as</span> libc::size_t) <span class="kw">as</span> *<span class="kw">mut</span> <span class="kw">u8</span>
      }
  }
  
  <span class="ot">#[</span>no_mangle<span class="ot">]</span>
  <span class="kw">pub</span> <span class="kw">extern</span> <span class="kw">fn</span> __rust_reallocate_inplace(_ptr: *<span class="kw">mut</span> <span class="kw">u8</span>, old_size: usize,
                                          _size: usize, _align: usize) -&gt; usize {
      old_size <span class="co">// libc не поддерживает этот API</span>
  }
  
  <span class="ot">#[</span>no_mangle<span class="ot">]</span>
  <span class="kw">pub</span> <span class="kw">extern</span> <span class="kw">fn</span> __rust_usable_size(size: usize, _align: usize) -&gt; usize {
      size
  }</code></pre>
  <p>После того как мы скомпилировали этот контейнер, мы можем использовать его следующим образом:</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> crate my_allocator;
  
  <span class="kw">fn</span> main() {
      <span class="kw">let</span> a = Box::new(<span class="dv">8</span>); <span class="co">// выделение памяти с помощью нашего контейнера</span>
      <span class="ot">println!</span>(<span class="st">&quot;{}&quot;</span>, a);
  }</code></pre>
  </section>
  <section id="ограничения-пользовательских-менеджеров-памяти" class="level3">
  <h3>Ограничения пользовательских менеджеров памяти</h3>
  <p>Несколько ограничений при работе с пользовательским менеджером памяти, которые могут быть причиной ошибок компиляции:</p>
  <ul>
  <li><p>Любой артефакт может быть скомпонован только с одним менеджером. Исполняемые файлы, динамические библиотеки и статические библиотеки должны быть скомпонованы с одним менеджером, и если не один не был указан, то компилятор сам выберет один. В то же время Rust библиотеки (rlibs) не нуждаются в компоновке с менеджером (но это возможно).</p></li>
  <li><p>Потребитель какого-либо менеджера памяти имеет пометку <code>#![needs_allocator]</code> (в данном случае контейнер <code>liballoc</code>) и какой-либо контейнер <code>#[allocator]</code> не может транзитивно зависеть от контейнера, которому нужен менеджер (т.е. циклическая зависимость не допускается). Это означает, что менеджеры памяти в данный момент должны ограничить себя только libcore.</p></li>
  </ul>
  </section>
  </section>
  </section>
  <section id="sec--glossary" class="level1">
  <h1>Глоссарий</h1>
  <p>Не каждый пользователь Rust имеет опыт работы с системами программирования, или необходимые знания в области компьютерной науки, поэтому мы добавили разъяснения терминов, которые могут быть незнакомы.</p>
  <p><a name="abstract-syntax-tree"></a> ##### Абстрактное синтаксическое дерево</p>
  <p>Когда компилятор компилирует программу, он делает целый ряд различных вещей. Одна из вещей, которые он делает, это преобразует текст вашей программы в ‘Абстрактное синтаксическое дерево,’ или ‘AST.’ Это дерево является представлением структуры вашей программы. Например, <code>2 + 3</code> может быть преобразовано в дерево:</p>
  <pre class="text"><code>  +
   / \
  2   3</code></pre>
  <p>А <code>2 + (3 * 4)</code> будет выглядеть следующим образом:</p>
  <pre class="text"><code>  +
   / \
  2   *
     / \
    3   4</code></pre>
  <p><a name="arity"></a> ##### Арность</p>
  <p>Арность означает число аргументов, которые принимает функция или операция.</p>
  <pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> x = (<span class="dv">2</span>, <span class="dv">3</span>);
  <span class="kw">let</span> y = (<span class="dv">4</span>, <span class="dv">6</span>);
  <span class="kw">let</span> z = (<span class="dv">8</span>, <span class="dv">2</span>, <span class="dv">6</span>);</code></pre>
  <p>В приведенном выше примере <code>x</code> и <code>y</code> имеют арность 2. <code>z</code> имеет арность 3.</p>
  <p><a name="expression"></a> ##### Выражение</p>
  <p>В программировании, выражение — это комбинация значений, постоянных, переменных и функций, которая вычисляется в одно значение. Например, <code>2 + (3 * 4)</code> — выражение, вычисляющееся в значение <code>14</code>. Стоит заметить, что у выражений могут быть побочные эффекты. Например, функция, участвующая в выражении, может делать что-то ещё помимо непосредственно возврата значения.</p>
  <section id="язык-ориентированный-на-выражения" class="level5">
  <h5>Язык, ориентированный на выражения</h5>
  <p>В ранних языках программирования <a href="#expression">выражения</a> и <a href="#statement">операторы</a> были двумя отдельными видами синтаксиса: выражения вычислялись в выражение, а операторы производили действия с побочными эффектами. Однако поздние языки уже не имели такого чёткого разделения по этому критерию. В языке, ориентированном на выражения, почти любой оператор — это выражение, а значит, оно возвращает значение. Следовательно, эти выражения могут сами являться частью ещё больших выражений.</p>
  <p><a name="statement"></a> ##### Оператор</p>
  <p>В программировании, оператор — это наименьший отдельный элемент языка, который обозначает выполнение компьютером законченного действия. Например, в языке C <code>printf(&quot;42&quot;);</code> — это оператор.</p>
  </section>
  </section>
  <section id="sec--bibliography" class="level1">
  <h1>Библиография</h1>
  <p>Это — список материалов, имеющих отношние к Rust. Он включает в себя предварительные исследования, которые в тот или иной момент оказали влияние на структуру Rust’а, а также публикации о Rust.</p>
  <section id="система-типов" class="level5">
  <h5>Система типов</h5>
  <ul>
  <li><a href="http://209.68.42.137/ucsd-pages/Courses/cse227.w03/handouts/cyclone-regions.pdf">Region based memory management in Cyclone</a></li>
  <li><a href="http://www.cs.umd.edu/projects/PL/cyclone/scp.pdf">Safe manual memory management in Cyclone</a></li>
  <li><a href="http://www.ps.uni-sb.de/courses/typen-ws99/class.ps.gz">Typeclasses: making ad-hoc polymorphism less ad hoc</a></li>
  <li><a href="https://www.cs.utah.edu/plt/publications/jfp12-draft-fcdf.pdf">Macros that work together</a></li>
  <li><a href="http://scg.unibe.ch/archive/papers/Scha03aTraits.pdf">Traits: composable units of behavior</a></li>
  <li><a href="http://www.cs.uwm.edu/faculty/boyland/papers/unique-preprint.ps">Alias burying</a> - We tried something similar and abandoned it.</li>
  <li><a href="http://www.cs.uu.nl/research/techreps/UU-CS-2002-048.html">External uniqueness is unique enough</a></li>
  <li><a href="https://research.microsoft.com/pubs/170528/msr-tr-2012-79.pdf">Uniqueness and Reference Immutability for Safe Parallelism</a></li>
  <li><a href="http://www.cs.ucla.edu/~palsberg/tba/papers/tofte-talpin-iandc97.pdf">Region Based Memory Management</a></li>
  </ul>
  </section>
  <section id="многозадачность" class="level5">
  <h5>Многозадачность</h5>
  <ul>
  <li><a href="https://research.microsoft.com/pubs/69431/osr2007_rethinkingsoftwarestack.pdf">Singularity: rethinking the software stack</a></li>
  <li><a href="https://research.microsoft.com/pubs/67482/singsharp.pdf">Language support for fast and reliable message passing in singularity OS</a></li>
  <li><a href="http://supertech.csail.mit.edu/papers/steal.pdf">Scheduling multithreaded computations by work stealing</a></li>
  <li><a href="http://www.eecis.udel.edu/%7Ecavazos/cisc879-spring2008/papers/arora98thread.pdf">Thread scheduling for multiprogramming multiprocessors</a></li>
  <li><a href="http://www.aladdin.cs.cmu.edu/papers/pdfs/y2000/locality_spaa00.pdf">The data locality of work stealing</a></li>
  <li><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.170.1097&amp;rep=rep1&amp;type=pdf">Dynamic circular work stealing deque</a> - The Chase/Lev deque</li>
  <li><a href="http://www.cs.rice.edu/%7Eyguo/pubs/PID824943.pdf">Work-first and help-first scheduling policies for async-finish task parallelism</a> - More general than fully-strict work stealing</li>
  <li><a href="http://www.coopsoft.com/ar/CalamityArticle.html">A Java fork/join calamity</a> - critique of Java’s fork/join library, particularly its application of work stealing to non-strict computation</li>
  <li><a href="http://www.stanford.edu/~ouster/cgi-bin/papers/coscheduling.pdf">Scheduling techniques for concurrent systems</a></li>
  <li><a href="http://www.blagodurov.net/files/a8-blagodurov.pdf">Contention aware scheduling</a></li>
  <li><a href="http://www.cse.ohio-state.edu/hpcs/WWW/HTML/publications/papers/TR-12-1.pdf">Balanced work stealing for time-sharing multicores</a></li>
  <li><a href="http://dl.acm.org/citation.cfm?id=1953616&amp;dl=ACM&amp;coll=DL&amp;CFID=524387192&amp;CFTOKEN=44362705">Three layer cake for shared-memory programming</a></li>
  <li><a href="http://www.cs.bgu.ac.il/%7Ehendlerd/papers/p280-hendler.pdf">Non-blocking steal-half work queues</a></li>
  <li><a href="http://www.mpi-sws.org/~turon/reagents.pdf">Reagents: expressing and composing fine-grained concurrency</a></li>
  <li><a href="https://www.cs.rochester.edu/u/scott/papers/1991_TOCS_synch.pdf">Algorithms for scalable synchronization of shared-memory multiprocessors</a></li>
  <li><a href="https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-579.pdf">Epoch-based reclamation</a>.</li>
  </ul>
  </section>
  <section id="другое" class="level5">
  <h5>Другое</h5>
  <ul>
  <li><a href="https://www.usenix.org/legacy/events/hotos03/tech/full_papers/candea/candea.pdf">Crash-only software</a></li>
  <li><a href="http://people.cs.umass.edu/~emery/pubs/berger-pldi2001.pdf">Composing High-Performance Memory Allocators</a></li>
  <li><a href="http://people.cs.umass.edu/~emery/pubs/berger-oopsla2002.pdf">Reconsidering Custom Memory Allocation</a></li>
  </ul>
  </section>
  <section id="статьи-о-rust" class="level5">
  <h5>Статьи <em>о</em> Rust</h5>
  <ul>
  <li><a href="http://www.cs.indiana.edu/~eholk/papers/hips2013.pdf">GPU Programming in Rust: Implementing High Level Abstractions in a Systems Level Language</a>. Early GPU work by Eric Holk.</li>
  <li><a href="https://www.usenix.org/conference/hotpar12/parallel-closures-new-twist-old-idea">Parallel closures: a new twist on an old idea</a></li>
  <li>not exactly about Rust, but by nmatsakis</li>
  <li><a href="ftp://ftp.cs.washington.edu/tr/2015/03/UW-CSE-15-03-02.pdf">Patina: A Formalization of the Rust Programming Language</a>. Early formalization of a subset of the type system, by Eric Reed.</li>
  <li><a href="http://arxiv.org/abs/1505.07383">Experience Report: Developing the Servo Web Browser Engine using Rust</a>. By Lars Bergstrom.</li>
  <li><a href="https://michaelsproul.github.io/rust_radix_paper/rust-radix-sproul.pdf">Implementing a Generic Radix Trie in Rust</a>. Undergrad paper by Michael Sproul.</li>
  <li><a href="http://scialex.github.io/reenix.pdf">Reenix: Implementing a Unix-Like Operating System in Rust</a>. Undergrad paper by Alex Light.</li>
  <li>[Evaluation of performance and productivity metrics of potential programming languages in the HPC environment] (http://octarineparrot.com/assets/mrfloya-thesis-ba.pdf). Bachelor’s thesis by Florian Wilkens. Compares C, Go and Rust.</li>
  <li><a href="http://spw15.langsec.org/papers/couprie-nom.pdf">Nom, a byte oriented, streaming, zero copy, parser combinators library in Rust</a>. By Geoffroy Couprie, research for VLC.</li>
  <li><a href="http://compilers.cs.uni-saarland.de/papers/lkh15_cgo.pdf">Graph-Based Higher-Order Intermediate Representation</a>. An experimental IR implemented in Impala, a Rust-like language.</li>
  <li><a href="http://compilers.cs.uni-saarland.de/papers/ppl14_web.pdf">Code Refinement of Stencil Codes</a>. Another paper using Impala.</li>
  <li><a href="http://publications.lib.chalmers.se/records/fulltext/219016/219016.pdf">Parallelization in Rust with fork-join and friends</a>. Linus Farnstrand’s master’s thesis.</li>
  <li><a href="http://munksgaard.me/papers/laumann-munksgaard-larsen.pdf">Session Types for Rust</a>. Philip Munksgaard’s master’s thesis. Research for Servo.</li>
  <li><a href="http://amitlevy.com/papers/tock-plos2015.pdf">Ownership is Theft: Experiences Building an Embedded OS in Rust - Amit Levy, et. al.</a></li>
  </ul>
  </section>
  </section>
  <section class="footnotes">
  <hr />
  <ol>
  <li id="fn1"><p>На самом деле, <code>Arc&lt;UnsafeCell&lt;T&gt;&gt;</code> не скомпилируется, поскольку <code>UnsafeCell&lt;T&gt;</code> не реализует <code>Send</code> или <code>Sync</code>, но мы можем обернуть его в тип и реализовать для него <code>Send</code>/<code>Sync</code> вручную, чтобы получить <code>Arc&lt;Wrapper&lt;T&gt;&gt;</code>, где <code>Wrapper</code> — это <code>struct Wrapper&lt;T&gt;(UnsafeCell&lt;T&gt;)</code>.<a href="#fnref1">↩</a></p></li>
  <li id="fn2"><p><code>&amp;[T]</code> и <code>&amp;mut [T]</code> — это <em>срезы</em>; они состоят из указателя и длины, и могут ссылаться на часть вектора или массива. <code>&amp;mut [T]</code> также позволяет изменять свои элементы, но его длину изменить нельзя.<a href="#fnref2">↩</a></p></li>
  <li id="fn3"><p>Фактическое определение <code>vec!</code> в libcollections отличается от представленного здесь по соображениям эффективности и повторного использования.<a href="#fnref3">↩</a></p></li>
  </ol>
  </section>
</article>

</body>
</html>
