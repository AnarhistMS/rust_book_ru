% Стек и Куча

Как любой системный язык программирования, Rust работает на низком уровне. Если
вы пришли из языка высокого уровня, то вам могут быть незнакомы некоторые
аспекты системного программирования. Наиболее важными из них являются те,
которые касаются работы с памятью в стеке и в куче. Если вы уже знакомы с тем,
как в C-подобных языках используется выделение памяти в стеке, то эта глава
освежит ваши знания. Если же вы еще не знакомы с этим, то узнаете об этом более
общей концепции, но с акцентом на Rust.

# Управление памятью

Эти два термина касаются управления памятью. Стек и куча - это абстракции,
которые помогают вам определить, когда требуется выделение и освобождение
памяти.

Вот высокоуровневое сравнение:

Стек работает очень быстро, в Rust память выделяется в стеке по умолчанию.
Выделение памяти в стеке является локальным по отношению к вызову функции, и
имеет ограниченный размер. Куча, с другой стороны, работает медленнее, а
выделение памяти в куче осуществляется в программе явно. Но такая память имеет
эффективно неограниченный размер, и глобально доступна.

# Стек

Давайте поговорим о следующей программе на Rust:

```rust
fn main() {
    let x = 42;
}
```

Эта программа имеет одно связывание переменной, `x`. Память для этого необходимо
где-то выделить. Rust по умолчанию "выделяет память в стеке", что означает, что
переменные "помещаются в стеке". Что это значит?

Хорошо, когда функция вызывается, то выделяется некоторый объем памяти для всех
её локальных переменных и некоторой дополнительной информации. Это называется
"стековый фрейм" (кадр), в этом туториале мы будем игнорировать эту
дополнительную информацию, и будем рассматривать лишь локальные переменные,
которые мы выделяем. Таким образом, в этом случае, когда выполняется `main()`,
мы выделяем одно 32-битное целое число в нашем фрейме стека. Как вы можете
видеть, это происходит автоматически, мы не должны писать какой-либо специальный
код на Rust или что-нибудь ещё для этого.

Когда функция завершается, её стековый фрейм освобождается. Это происходит
автоматически, мы не должны делать что-либо специальное для этого.

Вот и все, что касается этой простой программы. Главное, что здесь нужно понять,
это что выделение в стеке очень, очень быстро. Поскольку нам известны все
локальные переменные заранее, то мы можем выделить для них сразу всю память
единовременно. И так как они, как правило, одновременно выходят из области
своего определения, то мы можем освободить выделенную память также очень быстро.

Недостатком является то, что мы не можем хранить необходимые значения дольше,
чем в рамках одной функции. Мы ещё не говорили о том, что же означает название
"Стек". Для этого мы должны привести немного более сложный пример:

```rust
fn foo() {
    let y = 5;
    let z = 100;
}

fn main() {
    let x = 42;

    foo();
}
```

Эта программа имеет в общей сложности три переменные: две в `foo()`, одну в
`main()`. Так же как и раньше, когда вызывается `main()`, в её стековом фрейме
выделяется одно целое число. Но, прежде чем мы сможем показать, что происходит,
когда вызывается `foo()`, мы должны визуализировать то, что происходит с
памятью. Ваша операционная система представляет отображение памяти для вашей
программы, это довольно просто: огромный список адресов, от 0 до большого числа,
представляющего количество оперативной памяти у вашего компьютера. Например,
если у вас есть гигабайт оперативной памяти, то ваши адреса будут от `0` до
`1,073,741,824`. Это число получается из `2<sup>30</sup>`, число байтов в
гигабайте.

Эта память вроде гигантского массива: адреса начинаются с нуля и продолжаются до
конечного числа. Так вот схема нашего первого кадра стека:

| Address | Name | Value |
|---------|------|-------|
| 0       | x    | 42    |

У нас есть переменная `x`, расположенная по адресу `0`, имеющая значение `42`.

Когда вызывается `foo()`, выделяется новый стековый фрейм:

| Address | Name | Value |
|---------|------|-------|
| 2       | z    | 100   |
| 1       | y    | 5     |
| 0       | x    | 42    |

Поскольку `0` было задействовано в первом фрейме, для фрейма `foo()`
используются `1` и `2`. Стек растет вверх, для дальнейших функций, которые мы
вызываем.


Здесь необходимо принять к сведению некоторые важные замечания. Адреса 0, 1 и 2
приведены исключительно в иллюстративных целях, и не имеют никакого отношения к
фактическим адресам, которые компьютер будет использовать. В частности, набор
адресов в действительности включает разделители, состоящие из некоторого числа
байтов, которые отделяют каждый из адресов, и размер этого разделителя может
даже превышать размер хранящегося значения.

После того, как `foo()` завершается, её фрейм будет освобожден:

| Address | Name | Value |
|---------|------|-------|
| 0       | x    | 42    |

А потом, после `main()`, даже это последнее значение уходит. Легко!

Это называется "стек", потому что он работает как стек тарелок: первая тарелка,
которую вы положили, будет последней тарелкой, которую вы возьмете обратно. Стек
иногда называют "последним пришел, первым вышел очередью" по этой причине,
потому что последнее значение, которое вы положили в стек, будет первым, которое
вы получите из него.

Давайте попробуем трех-уровневый пример:

```rust
fn bar() {
    let i = 6;
}

fn foo() {
    let a = 5;
    let b = 100;
    let c = 1;

    bar();
}

fn main() {
    let x = 42;

    foo();
}
```

Хорошо, сначала вызывается `main()`:

| Address | Name | Value |
|---------|------|-------|
| 0       | x    | 42    |

Затем из `main()` вызывается `foo()`:

| Address | Name | Value |
|---------|------|-------|
| 3       | c    | 1     |
| 2       | b    | 100   |
| 1       | a    | 5     |
| 0       | x    | 42    |

И затем из `foo()` вызывается `bar()`:

| Address | Name | Value |
|---------|------|-------|
| 4       | i    | 6     |
| 3       | c    | 1     |
| 2       | b    | 100   |
| 1       | a    | 5     |
| 0       | x    | 42    |

Уф! Наш стек растет вверх.

После того, как `bar()` завершается, её фрейм будет освобожден, оставляя только
`foo()` и `main()`:

| Address | Name | Value |
|---------|------|-------|
| 3       | c    | 1     |
| 2       | b    | 100   |
| 1       | a    | 5     |
| 0       | x    | 42    |

И затем завершается `foo()`, оставляя только `main()`

| Address | Name | Value |
|---------|------|-------|
| 0       | x    | 42    |

И вот мы закончили. Уловили суть? Это как стопка тарелок: вы кладете наверх, и
вы берете сверху.

# Куча

Такой способ выделения памяти работает очень хорошо, но он не всегда может быть
использован. Иногда вам необходимо передать некоторую память между различными
функциями или сохранить её валидность после окончания выполнения функции. Для
этого, мы можем использовать кучу.

В Rust, вы можете выделить память в куче с помощью [типа `Box<T>`][box]. Вот
пример:

```rust
fn main() {
    let x = Box::new(5);
    let y = 42;
}
```

[box]: ../std/boxed/index.html

Вот что происходит с памятью, когда вызывается `main()`:

| Address | Name | Value  |
|---------|------|--------|
| 1       | y    | 42     |
| 0       | x    | ?????? |

Мы выделяем место для двух переменных в стеке. `y` представляет собой `42`, тут
всё как обычно, но что насчёт `x`? Хорошо, `x` представляет собой `Box<i32>`, а
боксы выделяют память в куче. Фактическое значение бокса - структура, которая
имеет указатель на "кучу". Когда начинает выполняться функция, осуществляется
вызов `Box::new()`, который выделяет некоторый объем памяти в куче, и кладет
туда `5`. Память в настоящее время выглядит следующим образом:

| Address         | Name | Value          |
|-----------------|------|----------------|
| 2<sup>30</sup>  |      | 5              |
| ...             | ...  | ...            |
| 1               | y    | 42             |
| 0               | x    | 2<sup>30</sup> |

У нас есть 2<sup>30</sup> в нашем гипотетическом компьютере с 1Гб оперативной
памяти. А так как наш стек растет от нуля, то проще всего выделить память с
другого конца. Таким образом, наше первое значение находится на самом высоком
месте в памяти. А значением структуры в `x` является [сырой
указатель][rawpointer] на адрес, который мы выделили в куче, так что значение
`x` равно 2<sup>30</sup>, это то самое местоположение в памяти.

[rawpointer]: raw-pointers.html

Мы не слишком много говорили о том, что на самом деле означает выделить и
освободить память в этих контекстах. Чрезмерное углубление в детали по этому
вопросу выходит за рамки данного руководства, но важно отметить, что куча - это
не просто стек, который растет с противоположного конца. Как мы увидим в
примерах в этой книге дальше, память из кучи может быть выделена и освобождена в
любом порядке, что в конечном итоге может привести к "дыркам". Вот схема
размещения памяти программы, проработавшей в течение некоторого времени:

| Address              | Name | Value                |
|----------------------|------|----------------------|
| 2<sup>30</sup>       |      | 5                    |
| (2<sup>30</sup>) - 1 |      |                      |
| (2<sup>30</sup>) - 2 |      |                      |
| (2<sup>30</sup>) - 3 |      | 42                   |
| ...                  | ...  | ...                  |
| 3                    | y    | (2<sup>30</sup>) - 3 |
| 2                    | y    | 42                   |
| 1                    | y    | 42                   |
| 0                    | x    | 2<sup>30</sup>       |

В этом примере мы выделили четыре элемента в куче, но освободили лишь два из
них. Отсюда разрыв между 2<sup>30</sup> и (2<sup>30</sup>) - 3, который в
настоящее время не используется. Конкретные детали того, как и почему это
происходит, зависят от того, какую стратегию вы используете для управления
кучей. Различные программы могут использовать различные "распределители памяти",
которые представляют собой библиотеки, которые управляют памятью за вас. Rust
программы используют [jemalloc][jemalloc] для этой цели.

[jemalloc]: http://www.canonware.com/jemalloc/

Короче, вернемся к нашему примеру. Так как эта память расположена в куче, то она
может оставаться в живых (валидной) дольше, чем функция, которые выделяет бокс.
В данном случае, однако, это не так.[^moving] Когда функция завершается, мы
должны освободить фрейм стека для `main()`. Хотя у `Box<T>` для этого есть свой
трюк: [Drop][drop]. Реализация `Drop` для `Box` освобождает память, которая была
выделена при создании. Отлично! Поэтому, когда `x` уходит, сначала освобождается
память, выделенная в куче:

| Address | Name | Value  |
|---------|------|--------|
| 1       | y    | 42     |
| 0       | x    | ?????? |

[drop]: drop.html
[moving]: Мы можем сделать время жизни памяти более долгим путем передачи права
          собственности, что иногда называют "перемещение из бокса" ("moving out
          of the box"). Более сложные примеры будут рассмотрены позже.


А потом фрейм стека уходит, освобождая всю нашу память.

# Аргументы и заимствование

У нас есть некоторые простые примеры со стеком и кучей, но что насчёт аргументов
функции и заимствования? Вот небольшая программа на Rust:

```rust
fn foo(i: &i32) {
    let z = 42;
}

fn main() {
    let x = 5;
    let y = &x;

    foo(y);
}
```

Когда мы входим в `main()`, память выглядит следующим образом:

| Address | Name | Value |
|---------|------|-------|
| 1       | y    | 0     |
| 0       | x    | 5     |

Значением `x` является `5`, а `y` представляет собой ссылку на `x`. То есть, ее
значением является адрес памяти, в котором расположен `x`, который в данном
случае является `0`.

А что насчёт случая, когда мы вызываем `foo()`, передавая `y` в качестве
аргумента?

| Address | Name | Value |
|---------|------|-------|
| 3       | z    | 42    |
| 2       | i    | 0     |
| 1       | y    | 0     |
| 0       | x    | 5     |

Фреймы стека используются не только для локальных привязок, но также и для
аргументов. Таким образом, в этом случае, наш фрейм должен содержать как `i`,
наш аргумент, так и `z`, нашу привязку локальной переменной. `i` - это копия
аргумента `y`. Соответственно, значением `i`, как и значением `y`, является `0`.

Это одна из причин, почему заимствование переменной не освобождает какую-либо
память: значением ссылки является просто указатель на область памяти. Если мы
освободим нижележащую по этому указателю память, то это может привести к ошибкам
в дальнейшей работе.

# Комплексный пример

Хорошо, давайте рассмотрим следующую комплексную программу шаг за шагом:

```rust
fn foo(x: &i32) {
    let y = 10;
    let z = &y;

    baz(z);
    bar(x, z);
}

fn bar(a: &i32, b: &i32) {
    let c = 5;
    let d = Box::new(5);
    let e = &d;

    baz(e);
}

fn baz(f: &i32) {
    let g = 100;
}

fn main() {
    let h = 3;
    let i = Box::new(20);
    let j = &h;

    foo(j);
}
```

Сначала, мы вызываем `main()`:

| Address         | Name | Value          |
|-----------------|------|----------------|
| 2<sup>30</sup>  |      | 20             |
| ...             | ...  | ...            |
| 2               | j    | 0              |
| 1               | i    | 2<sup>30</sup> |
| 0               | h    | 3              |

Мы выделяем память для `j`, `i`, и `h`. `i` выделна в куче и поэтому содержит
указатель на значение в куче.

Далее, в конце вызова `main()`, вызывается `foo()`:

| Address         | Name | Value          |
|-----------------|------|----------------|
| 2<sup>30</sup>  |      | 20             |
| ...             | ...  | ...            |
| 5               | z    | 4              |
| 4               | y    | 10             |
| 3               | x    | 0              |
| 2               | j    | 0              |
| 1               | i    | 2<sup>30</sup> |
| 0               | h    | 3              |

Пространство выделяется для `x`, `y` и `z`. Аргумент `x` имеет такое же
значение, как и `j`, так как мы передали в качестве аргумента именно его. Это
указатель на адрес `0`, так как `j` указывает на `h`.

Далее, `foo()` вызывает `baz()`, передавая `z`:

| Address         | Name | Value          |
|-----------------|------|----------------|
| 2<sup>30</sup>  |      | 20             |
| ...             | ...  | ...            |
| 7               | g    | 100            |
| 6               | f    | 4              |
| 5               | z    | 4              |
| 4               | y    | 10             |
| 3               | x    | 0              |
| 2               | j    | 0              |
| 1               | i    | 2<sup>30</sup> |
| 0               | h    | 3              |

Мы выделили память для `f` и `g`. `baz()` очень короткая, и когда она
завершается, мы избавляемся от её фрейма стека:

| Address         | Name | Value          |
|-----------------|------|----------------|
| 2<sup>30</sup>  |      | 20             |
| ...             | ...  | ...            |
| 5               | z    | 4              |
| 4               | y    | 10             |
| 3               | x    | 0              |
| 2               | j    | 0              |
| 1               | i    | 2<sup>30</sup> |
| 0               | h    | 3              |

Далее `foo()` вызывает `bar()` с аргументами `x` и `z`:

| Address              | Name | Value                |
|----------------------|------|----------------------|
|  2<sup>30</sup>      |      | 20                   |
| (2<sup>30</sup>) - 1 |      | 5                    |
| ...                  | ...  | ...                  |
| 10                   | e    | 9                    |
| 9                    | d    | (2<sup>30</sup>) - 1 |
| 8                    | c    | 5                    |
| 7                    | b    | 4                    |
| 6                    | a    | 0                    |
| 5                    | z    | 4                    |
| 4                    | y    | 10                   |
| 3                    | x    | 0                    |
| 2                    | j    | 0                    |
| 1                    | i    | 2<sup>30</sup>       |
| 0                    | h    | 3                    |

Тут мы выделяем другое значение в куче, и поэтому мы вычитаем единицу из
2<sup>30</sup>. Это выражение написать легче, чем `1,073,741,823`. В любом
случае, переменные создаются, как обычно.

В конце `bar()` вызывает `baz()`:

| Address              | Name | Value                |
|----------------------|------|----------------------|
|  2<sup>30</sup>      |      | 20                   |
| (2<sup>30</sup>) - 1 |      | 5                    |
| ...                  | ...  | ...                  |
| 12                   | g    | 100                  |
| 11                   | f    | 4                    |
| 10                   | e    | 9                    |
| 9                    | d    | (2<sup>30</sup>) - 1 |
| 8                    | c    | 5                    |
| 7                    | b    | 4                    |
| 6                    | a    | 0                    |
| 5                    | z    | 4                    |
| 4                    | y    | 10                   |
| 3                    | x    | 0                    |
| 2                    | j    | 0                    |
| 1                    | i    | 2<sup>30</sup>       |
| 0                    | h    | 3                    |

Сейчас мы находимся в самой глубокой точке! Уф! Поздравляю с достижением данной
точки.

После завершения `baz()`, мы избавляемся от `f` и `g`:

| Address              | Name | Value                |
|----------------------|------|----------------------|
|  2<sup>30</sup>      |      | 20                   |
| (2<sup>30</sup>) - 1 |      | 5                    |
| ...                  | ...  | ...                  |
| 10                   | e    | 9                    |
| 9                    | d    | (2<sup>30</sup>) - 1 |
| 8                    | c    | 5                    |
| 7                    | b    | 4                    |
| 6                    | a    | 0                    |
| 5                    | z    | 4                    |
| 4                    | y    | 10                   |
| 3                    | x    | 0                    |
| 2                    | j    | 0                    |
| 1                    | i    | 2<sup>30</sup>       |
| 0                    | h    | 3                    |

Далее мы выполняем возврат из `bar()`. В этом случае `d` представляет собой
`Box<T>`, поэтому он также освобождает и то, на что он указывает:
(2<sup>30</sup>) - 1.

| Address         | Name | Value          |
|-----------------|------|----------------|
|  2<sup>30</sup> |      | 20             |
| ...             | ...  | ...            |
| 5               | z    | 4              |
| 4               | y    | 10             |
| 3               | x    | 0              |
| 2               | j    | 0              |
| 1               | i    | 2<sup>30</sup> |
| 0               | h    | 3              |

И после этого происходит возврат из `foo()`:

| Address         | Name | Value          |
|-----------------|------|----------------|
|  2<sup>30</sup> |      | 20             |
| ...             | ...  | ...            |
| 2               | j    | 0              |
| 1               | i    | 2<sup>30</sup> |
| 0               | h    | 3              |

И вот, наконец, `main()`, которая очищает все остальное. Когда `i` дропается
(`Drop`), будет также очищен и конец кучи.

# А что делают другие языки?

Большинство языков с сборщиком мусора по умолчанию выделяет память из кучи. Это
означает, что каждое значение будет упаковано. Есть ряд причин, почему делается
именно так, но они выходит за рамки данного руководства. Есть несколько
возможных оптимизаций, которые правда также не достигают своей цели во всех 100%
случаях. Вместо того чтобы полагаться на стек и `Drop` в вопросах очистки
памяти, сборщик мусора работает с кучей.

# Что использовать?

Но, если стек быстрее и проще в управлении, зачем тогда нужна куча? Весомая
причина заключается в том, что само по себе выделение в стеке означает, что вы
можете использовать только LIFO семантику для повторно используемого хранения
(reclaiming storage). Выделение в куче является определённо более общим,
позволяя хранение с возможностью взятия и возвращения обратно в произвольном
порядке, но ценой сложности.

В общем случае, следует предпочитать выделение в стеке, и поэтому, Rust
использует выделение в стеке по умолчанию. LIFO модель стека проще, на
фундаментальном уровне. Это оказывает два больших воздействия: эффективность
выполнения и смысловое воздействие.

## Эффективность времени выполнения.

Управление памятью для стека тривиально: машина просто увеличивает или уменьшает
одно значение, так называемый "указатель стека". Управление памятью для кучи
нетривиально: память, выделенная в куче, освобождается в произвольные точки, а
каждый блок выделенной в куче памяти может быть произвольного размера. Менеджеру
памяти, как правило, требуется приложить гораздо больше усилий для определения
памяти, которую можно использовать заново.

Если вы хотите изучить эту тему более подробно, то [эта статья][wilson] будет
отличным введением.

[wilson]: http://www.cs.northwestern.edu/~pdinda/icsclass/doc/dsa.pdf

## Смысловое воздействие

Выделения в стеке оказывает воздействие как на сам язык Rust, так и на модель
мышления разработчиков. Семантика LIFO является движком того, как язык Rust
выполняет автоматическое управление памятью. Даже освобождение выделенного в
куче и имеющего одного единственного владельца бокса может быть осуществлено с
помощью основанной на стеке семантики LIFO, как описано в этой главе. Гибкость
(т.е. выразительность) не являющихся LIFO семантики означает, что в целом
компилятор не может автоматически вывести время компиляции, когда память должна
быть освобождена; он должен полагаться на динамические протоколы, возможно не
являющиеся частью самого языка, в стремлении освобождения (подсчет ссылок,
используемый `Rc<T>` и `Arc<T>`, является одним из примеров этого).

Когда выжать все возможное, увеличится выразительная сила выделения в куче,
происходящая либо за счет существенной поддержки во время выполнения (например,
в виде сборщика мусора), либо за счет значительных усилий со стороны
программиста (в виде явных вызовов управления памятью, которые требуют проверки,
не предусмотренной компилятором Rust).
