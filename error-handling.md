% Обработка ошибок

> The best-laid plans of mice and men  
> Often go awry
>
> "Tae a Moose", Robert Burns

Иногда что-то может пойти не так. Очень важно иметь план действий на тот случай,
когда это неизбежно произойдет. Rust имеет богатую поддержку для обработки
ошибок, которые могут (давайте будем честны: будут) происходить в ваших
программах.

Есть два основных типа ошибок, которые могут возникнуть в ваших программах:
неудачи (failures), и паники (panics). Давайте поговорим о разнице между ними, а
затем обсудим, как справиться с каждой из них. Затем мы обсудим преобразование
неудачи в панику.

# Типы ошибок: неудача, паника

Rust использует два понятия, чтобы различать два типа ошибок: неудачи и паники.
*Неудача* - это ошибка, после которой, в некоторых случаях, может быть
восстановлена работоспособность программы. *Паника* - это ошибка, после которой
работоспособность программы не может быть восстановлена.

Что мы подразумеваем под понятием "восстановить"? В большинстве случаев,
возможность возникновения ошибок ожидаема. Например, рассмотрим функцию
`from_str`:

```{rust,ignore}
from_str("5");
```

Эта функция принимает строку в качестве аргумента и преобразует его в другой
тип. Но, так как это строка, вы не можете быть уверены, что преобразование
пройдет успешно. Например, во что должно быть преобразовано следующее?

```{rust,ignore}
from_str("hello5world");
```

Это не будет работать. Итак, мы знаем, что эта функция будет работать только при
некоторых входных данных. Это ожидаемое поведение. Мы называем такой тип ошибок
*неудача*.

С другой стороны, иногда есть ошибки, которые являются неожиданными, или после
которых мы не можем восстановить работоспособность программы. Классическим
примером является `assert!`:

```{rust,ignore}
assert!(x == 5);
```

Мы используем `assert!`, чтобы заявить, что что-то не верно. Если это не верно,
то что-то очень неправильно. Настолько неправильно, что мы не можем продолжать
работу программы в текущем состоянии. Другой пример - использование макроса
`unreachable!()`:

```{rust,ignore}
enum Event {
    NewRelease,
}

fn probability(_: &Event) -> f64 {
    // real implementation would be more complex, of course
    0.95
}

fn descriptive_probability(event: Event) -> &'static str {
    match probability(&event) {
        1.00 => "certain",
        0.00 => "impossible",
        0.00 ... 0.25 => "very unlikely",
        0.25 ... 0.50 => "unlikely",
        0.50 ... 0.75 => "likely",
        0.75 ... 1.00 => "very likely",
    }
}

fn main() {
    std::io::println(descriptive_probability(NewRelease));
}
```

Этот пример выведет следующую ошибку:

```text
error: non-exhaustive patterns: `_` not covered [E0004]
```

Хотя мы и знаем, что рассмотрели все возможные случаи, но Rust этого не знает.
Он не знает, что вероятность находится между 0,0 и 1,0. Поэтому мы добавляем еще
один случай:

```rust
use Event::NewRelease;

enum Event {
    NewRelease,
}

fn probability(_: &Event) -> f64 {
    // real implementation would be more complex, of course
    0.95
}

fn descriptive_probability(event: Event) -> &'static str {
    match probability(&event) {
        1.00 => "certain",
        0.00 => "impossible",
        0.00 ... 0.25 => "very unlikely",
        0.25 ... 0.50 => "unlikely",
        0.50 ... 0.75 => "likely",
        0.75 ... 1.00 => "very likely",
        _ => unreachable!()
    }
}

fn main() {
    println!("{}", descriptive_probability(NewRelease));
}
```

Мы никогда не должны попадать в случай `_`, поэтому мы используем макрос
`unreachable!()`, чтобы сообщить об этом. `unreachable!()` выдает другой тип
ошибки, нежели `Result`. Rust называет такой тип ошибок *паника*.

# Обработка ошибок с помощью `Option` и `Result`

Простейший способ указать, что функция может потерпеть неудачу, это использовать
тип `Option<T>`. Помните наш пример с функцией `from_str()`? Вот ее сигнатура:

```{rust,ignore}
pub fn from_str<A: FromStr>(s: &str) -> Option<A>
```

Функция `from_str()` возвращает `Option<A>`. Если преобразование успешно, то она
возвращает `Some(value)`, а если неудачно, то `None`.

Такой вариант подходит для простейших случаев, однако он не дает нам достаточно
информации в случае неудачи. Что же делать, если мы хотим знать причину,
_почему_ преобразование не удалось? Для этого мы можем использовать `Result<T,
E>`. Выглядит это следующим образом:

```rust
enum Result<T, E> {
   Ok(T),
   Err(E)
}
```

Это перечисление определено непосредственно в Rust, так что вам не нужно
определять его самостоятельно, чтобы использовать в своем коде. `Ok(T)` вариант
представляет собой успех, а `Err(E)` вариант представляет собой неудачу.
Рекомендуется возвращать `Result` вместо `Option` во всех случаях, кроме самых
тривиальных.

Ниже приведен пример использования `Result`:

```rust
#[derive(Debug)]
enum Version { Version1, Version2 }

#[derive(Debug)]
enum ParseError { InvalidHeaderLength, InvalidVersion }

fn parse_version(header: &[u8]) -> Result<Version, ParseError> {
    if header.len() < 1 {
        return Err(ParseError::InvalidHeaderLength);
    }
    match header[0] {
        1 => Ok(Version::Version1),
        2 => Ok(Version::Version2),
        _ => Err(ParseError::InvalidVersion)
    }
}

let version = parse_version(&[1, 2, 3, 4]);
match version {
    Ok(v) => {
        println!("working with version: {:?}", v);
    }
    Err(e) => {
        println!("error parsing header: {:?}", e);
    }
}
```

В примере показана функция, которая использует перечисление `ParseError`, чтобы
определить ошибки, которые могут возникнуть.

# Использование `panic!`

В случае ошибки, которая является неожиданной, и после которой не может быть
восстановлена работоспособность программы, макрос `panic!` будет вызывать
панику. Это приведет к аварийному завершению текущего потока, и выдаст сообщение
об ошибке:

```{rust,ignore}
panic!("boom");
```

выводит

```text
thread '<main>' panicked at 'boom', hello.rs:2
```

когда вы запускаете пример.

Подобные ситуации встречаются довольно редко, поэтому используйте паники
осмотрительно.

# Преобразование неудачи в панику

В некоторых случаях, когда функция может потерпеть неудачу, нам может
понадобиться рассматривать эту неудачу как панику. Например,
`io::stdin().read_line()` возвращает `IoResult<String>`, один из видов `Result`,
если произошла ошибка при чтении строки. Это позволяет нам обработать такого
рода ошибку и, возможно, восстановить работоспособность программы.

Если же нам не нужно обрабатывать ошибку, а нужно просто прервать программу, то
мы можем использовать метод `unwrap()`:

```{rust,ignore}
io::stdin().read_line().unwrap();
```

`unwrap()` вызывает `panic!`, если `Option` будет `None`. Такой подход просто
говорит: "Дай мне значение, но если что-то пойдет не так, то просто аварийно
заверши программу". Такой подход менее надежен, чем распаковка ошибки с
последующей пыткой восстановления работоспособности программы, но он значительно
короче. Хотя в некоторых ситуациях аварийное завершение программы более
целесообразно.

Вот еще один способ распаковки ошибок, который немного лучше, чем `unwrap()`:

```{rust,ignore}
let input = io::stdin().read_line()
                       .ok()
                       .expect("Failed to read line");
```

`ok()` преобразует `IoResult` в `Option`, а `expect()` делает то же самое, что и
`unwrap()`, но принимает сообщение. Это сообщение передается в нижележащий вызов
`panic!`, обеспечивая лучшее сообщение об ошибке, если ошибок в коде.

# Использование `try!`

При написании кода, который вызывает множество функций, возвращающих тип
`Result`, обработка ошибок может быть утомительной. Макрос `try!` скрывает
некоторые шаблонные действия, передавая ошибки выше по стеку вызовов.

Он заменяет этот код:

```rust
use std::fs::File;
use std::io;
use std::io::prelude::*;

struct Info {
    name: String,
    age: i32,
    rating: i32,
}

fn write_info(info: &Info) -> io::Result<()> {
    let mut file = File::open("my_best_friends.txt").unwrap();

    if let Err(e) = writeln!(&mut file, "name: {}", info.name) {
        return Err(e)
    }
    if let Err(e) = writeln!(&mut file, "age: {}", info.age) {
        return Err(e)
    }
    if let Err(e) = writeln!(&mut file, "rating: {}", info.rating) {
        return Err(e)
    }

    return Ok(());
}
```

на этот код:

```rust
use std::fs::File;
use std::io;
use std::io::prelude::*;

struct Info {
    name: String,
    age: i32,
    rating: i32,
}

fn write_info(info: &Info) -> io::Result<()> {
    let mut file = try!(File::open("my_best_friends.txt"));

    try!(writeln!(&mut file, "name: {}", info.name));
    try!(writeln!(&mut file, "age: {}", info.age));
    try!(writeln!(&mut file, "rating: {}", info.rating));

    return Ok(());
}
```

Упаковка выражения в `try!` приведет к распакованному успешному (`Ok`) значению,
если результат не `Err`, и в этом случае `Err` возвращается раньше от функции
включения.

Стоит отметить, что вы можете использовать `try!` только из функции, которая
возвращает `Result`, что означает, что вы не можете использовать `try!` внутри
функции `main()`, потому что `main()` ничего не возвращают.

`try!` использует [`FromError`](../std/error/#the-fromerror-trait), чтобы
определять, что следует вернуть в случае ошибки.
