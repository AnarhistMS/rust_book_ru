% Агрегатные типы данных

Как и во многих других языках программирования, в Rust есть несколько встроенных
типов данных. Вы уже работали с целыми числами и строками, а теперь мы поговорим
о более сложных способах хранения данных.

## Кортежи

Первый агрегатный тип данных, о котором мы поговорим - это *кортеж*. Кортеж -
это упорядоченный список фиксированного размера. Вроде такого:

```rust
let x = (1, "привет");
```

Этот кортеж из двух элементов создан с помощью скобок и запятой между элементами.
Вот тот же код, но с аннотациями типов:

```rust
let x: (i32, &str) = (1, "привет");
```

Как вы можете видеть, тип кортежа выглядит как сам кортеж, но места элементов
занимают типы. Внимательные читатели также отметят, что кортежи гетерогенны:
в этом кортеже одновременно хранятся значения типов `i32` и `&str`. Мы уже
встречали тип `&str` ранее, и мы обсудим строки подробнее далее. В языках
системного программирования строки немного более сложны, чем в других языках.
Пока вы можете читать `&str` как *срез строки*. Мы вскоре узнаем об этом больше.

Доступ к полям кортежа можно получить с помощью *деконструирующего let*.
Вот пример:

```rust
let (x, y, z) = (1, 2, 3);

println!("x это {}", x);
```

Помните, я говорил, что левая часть оператора `let` более полезна, чем
просто присваивание имени? Об этом я и говорил. Мы можем написать слева от `let`
образец, и, если он совпадает со значением справа, произойдёт присваивание
имён сразу нескольким значениям. В данном случае, `let` "деконструирует" или
"разбивает" кортеж, и присваивает его части трём именам.

Это очень удобный шаблон программирования, и мы ещё не раз увидим его.

Некоторые вещи можно делать с кортежами как с единым целым, без разбиения.
Можно присваивать один кортеж другому, если они содержат значения одинаковых
типов и имеют одинаковую [арность][arity]. Арность кортежей одинакова, когда их длина
совпадает.

```rust
let mut x = (1, 2); // x: (i32, i32)
let y = (2, 3); // y: (i32, i32)

x = y;
```

Вы также можете проверять кортежи на равенство с помощью операции `==`.
Опять-таки, это скомпилируется только если кортежи имеют одинаковые типы.

```rust
let x = (1, 2, 3);
let y = (2, 2, 4);

if x == y {
    println!("да");
} else {
    println!("нет");
}
```

Этот код напечатает `нет`, потому что некоторые элементы не равны.

Заметьте, что порядок элементов важен при сравнении кортежей, поэтому
в следующем примере код также напечатает `нет`.

```rust
let x = (1, 2, 3);
let y = (2, 1, 3);

if x == y {
    println!("да");
} else {
    println!("нет");
}
```

Другой способ использовать кортежи - это возврат множества значений из функции:

```rust
fn next_two(x: i32) -> (i32, i32) { (x + 1, x + 2) }

fn main() {
    let (x, y) = next_two(5);
    println!("x, y = {}, {}", x, y);
}
```

Несмотря на то, что функции в Rust могут возвращать только одно значение,
в данном случае это не помеха. Кортеж - это *одно* значение, которое состоит
из нескольких. В этом примере вы также можете видеть пример разбиения кортежа,
возвращаемого функцией.

Кортежи - это очень простая структура данных, и часто они вам не подойдут.
Давайте рассмотрим их старшего брата, структуры.

## Структуры

Структура - это другой вид *агрегатного типа*, как и кортеж. Разница в том, что
в структурах у каждого элемента есть имя. Элемент структуры называется *полем*
или *членом структуры*. Смотрите:

```rust
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let origin = Point { x: 0, y: 0 }; // origin: Point

    println!("Начало координат находится в ({}, {})", origin.x, origin.y);
}
```

Этот код делает много разных вещей, поэтому давайте разберём его по порядку.
Мы объявляем структуру с помощью ключевого слова `struct`, за которым следует
имя объявляемой структуры. Обычно, имена типов-структур начинаются с
заглавной буквы и используют чередующийся регистр букв: название `PointInSpace`
выглядит привычно, а `Point_In_Space` - нет.

Как всегда, мы можем создать экземпляр нашей структуры с помощью оператора `let`.
Однако в данном случае мы используем синтаксис вида `ключ: значение` для
установки значения каждого поля. Порядок инициализации полей не обязательно
должен совпадать с порядком их объявления.

Наконец, поскольку у полей есть имена, мы можем получить поле с помощью операции
`точка`: `origin.x`.

Значения, хранимые в структурах, неизменяемы по умолчанию. В этом плане они не
отличаются от других именованных сущностей. Чтобы они стали изменяемы,
используйте ключевое слово `mut`:

```{rust}
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let mut point = Point { x: 0, y: 0 };

    point.x = 5;

    println!("Точка находится в ({}, {})", point.x, point.y);
}
```

Этот код напечатает `Точка находится в (5, 0)`.

## Кортежные структуры и новые типы

В Rust есть ещё один тип данных, который представляет собой нечто среднее
между кортежем и структурой. Он называется *кортежной структурой*. Кортежные
структуры именуются, а вот у их полей имён нет:


```{rust}
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);
```

Эти два объекта различны, несмотря на то, что у них одинаковые значения:

```{rust}
# struct Color(i32, i32, i32);
# struct Point(i32, i32, i32);
let black = Color(0, 0, 0);
let origin = Point(0, 0, 0);
```

Почти всегда, вместо кортежной структуры лучше использовать обычную структуру.
Мы бы скорее объявили типы `Color` и `Point` вот так:

```{rust}
struct Color {
    red: i32,
    blue: i32,
    green: i32,
}

struct Point {
    x: i32,
    y: i32,
    z: i32,
}
```

Теперь у нас есть настоящие имена, а не только позиции. Хорошие имена важны,
и при использовании структуры у нас есть эти имена.

Однако, _есть_ один случай, когда кортежные структуры очень полезны. Это
кортежная структура с всего одним элементом. Такое использование называется
*новым типом*, потому что оно позволяет создать новый тип, отличный от типа
значения, содержащегося в кортежной структуре. При этом новый тип обозначает
что-то другое:

```{rust}
struct Inches(i32);

let length = Inches(10);

let Inches(integer_length) = length;
println!("Длина в дюймах: {}", integer_length);
```

Как вы можете видеть в данном примере, извлечь вложенный целый тип можно
с помощью деконструирующего `let`. Мы обсуждали это выше, в разделе "кортежи".
В данном случае, оператор `let Inches(integer_length)` присваивает `10`
имени `integer_length`.

## Перечисления

Наконец, в Rust есть "типы-суммы", или *перечисления* (тип-сумма - это термин
из теории типов). Перечисления - это очень
полезная возможность Rust, и они очень много используются в стандартной
библиотеке языка. Они объявляются с помощью ключевого слова `enum`. `enum` - это
тип, который соотносит набор неких вариантов одному имени. Например, ниже мы
определяем перечисление `Character` (символ), представляющее собой или цифру
(`Digit`), или что-то другое. Объявленные варианты можно использовать с помощью
полностью квалифицированных имён, таких, как `Character::Other` (мы поговорим
об операции `::` ниже).

```rust
enum Character {
    Digit(i32),
    Other,
}
```

Б'ольшая часть обычных типов могут быть вариантами перечисления. Вот несколько
примеров:

```rust
struct Empty;
struct Color(i32, i32, i32);
struct Length(i32);
struct Status { Health: i32, Mana: i32, Attack: i32, Defense: i32 }
struct HeightDatabase(Vec<i32>);
```

Здесь мы видим, что, в зависимости от типа, вариант перечисления может
содержать вложенные данные, а может и не иметь таковых. Например, в перечислении
`Character` (символ), вариант `Digit` (цифра) даёт значимое имя числу типа
`i32`. А вот вариант `Other` представляет собой лишь имя, без значения. Однако
наиболее полезно именно то, что отдельные варианты представляют собой отдельные
виды символов (`Character`).

Как и структуры, варианты перечислений по умолчанию не сравнимы операциями
сравнения (`==`, `!=`), не упорядочены (не реализуют `<`, `>=` и другие) и не
поддерживают другие двухместные операции, такие как умножение (`*`) и сложение
(`+`). Нижеследующий код, как таковой, не верен (если мы используем приведённый
выше тип-перечисление `Character`):

```{rust,ignore}
// Оба этих присваивания успешны
let ten  = Character::Digit(10);
let four = Character::Digit(4);

// Error: `*` is not implemented for type `Character`
let forty = ten * four;

// Error: `<=` is not implemented for type `Character`
let four_is_smaller = four <= ten;

// Error: `==` is not implemented for type `Character`
let four_equals_ten = four == ten;
```

Наверное, это выглядит неудобным. Но мы можем преодолеть данное
ограничение. Есть два способа сделать это: реализовать сравнение самим, или
использовать сопоставление вариантов с образцом с помощью выражений
[`match`][match]. Мы узнаем о них в следующей главе. Пока мы не имеем
достаточных знаний Rust для реализации сравнения. Но мы можем использовать
перечисление `Ordering` (порядок) из стандартной библиотеки, которое выглядит
так:

```
enum Ordering {
    Less,
    Equal,
    Greater,
}
```

Поскольку перечисление `Ordering` уже определено, мы импортируем его с помощью
ключевого слова `use`. Вот пример его использования:

```{rust}
use std::cmp::Ordering;

fn cmp(a: i32, b: i32) -> Ordering {
    if a < b { Ordering::Less }
    else if a > b { Ordering::Greater }
    else { Ordering::Equal }
}

fn main() {
    let x = 5;
    let y = 10;

    let ordering = cmp(x, y); // ordering: Ordering

    if ordering == Ordering::Less {
        println!("меньше");
    } else if ordering == Ordering::Greater {
        println!("больше");
    } else if ordering == Ordering::Equal {
        println!("равно");
    }
}
```

Мы используем символ `::` для обозначения пространства имён. В данном случае,
перечисление `Ordering` находится в под-модуле модуля `std`. Мы подробнее
поговорим о модулях позже. Пока же достаточно знать, что вы можете использовать
(`use`) вещи из стандартной библиотеки, если они вам понадобятся.

Отлично, теперь давайте поговорим о самом коде примера. `cmp` - это функция,
которая сравнивает два объекта, и возвращает значение типа "порядок"
(`Ordering`). Мы возвращаем одно из значений `Ordering::Less`,
`Ordering::Greater` или `Ordering::Equal`, когда первое значение меньше,
больше или равно второму, соответственно. Заметьте, что варианты перечисления
находятся в пространстве имён самого перечисления: к нему нужно обращаться
`Ordering::Greater`, а не `Greater`.

Переменная `ordering` имеет тип `Ordering`, и содержит одно из трёх значений.
Затем мы делаем несколько сравнений с помощью `if`/`else`, чтобы проверить,
какое из значений мы получили.

Запись `Ordering::Greater` неудобна из-за своей длины. Давайте используем другой
вид оператора `use` и импортируем сами варианты перечисления. В таком коде
не нужно полностью специфицировать имена вариантов:

```{rust}
use std::cmp::Ordering::{self, Equal, Less, Greater};

fn cmp(a: i32, b: i32) -> Ordering {
    if a < b { Less }
    else if a > b { Greater }
    else { Equal }
}

fn main() {
    let x = 5;
    let y = 10;

    let ordering = cmp(x, y); // ordering: Ordering

    if ordering == Less { println!("меньше"); }
    else if ordering == Greater { println!("больше"); }
    else if ordering == Equal { println!("равно"); }
}
```

Импорт вариантов удобен и компактен, но он может вызывать конфликты имён,
поэтому будьте осторожны при его использовании. Обычно стилистически лучше
импортировать перечисление, а не его варианты.

Как видите, перечисления довольно удобны, и особенно полезны когда они
[обобщены][generics] относительно вложенных в них типов. Однако, прежде чем
мы перейдём к рассмотрению обобщённых типов, давайте поговорим об использовании
перечислений при сопоставлении с образцом. Сопоставление с образцом - это
инструмент, позволяющий нам элегантно разбирать типы-суммы вроде `Ordering`.
Данная техника позволит нам избежать всех этих хрупких сравнений с помощью
`if`/`else`.


[arity]: ./glossary.html#arity
[match]: ./match.html
[generics]: ./generics.html
