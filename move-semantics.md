% Семантика перемещения

Важным аспектом [владения][ownership] является ’семантика перемещения’.
Семантика перемещения контролирует, как и когда право собственности перемещается
между привязками (связываниями).

[ownership]: ownership.html

В качестве примера рассмотрим тип, который владеет своим содержимым, такой как
`Vec<T>`:

```rust
let v = vec![1, 2, 3];
```

Мы можем присвоить этот вектор другой привязке:

```rust
let v = vec![1, 2, 3];

let v2 = v;
```

Но, если после этого мы попытаемся использовать `v`, то получим ошибку:

```rust,ignore
let v = vec![1, 2, 3];

let v2 = v;

println!("v[0] is: {}", v[0]);
```

Ошибка выглядит следующим образом:

```text
error: use of moved value: `v`
println!("v[0] is: {}", v[0]);
                        ^
```

То же самое произойдет, если мы определим функцию, которая принимает право
владения, и попробуем использовать что-то после того как мы передали это что-то
в качестве аргумента в эту функцию:

```rust,ignore
fn take(v: Vec<i32>) {
    // what happens here isn’t important.
}

let v = vec![1, 2, 3];

take(v);

println!("v[0] is: {}", v[0]);
```

Та же самая ошибка: "используется перемещенное значение". Когда мы передаем
право владения куда-то еще, мы как бы говорим, что мы 'перемещаем' то, на что
ссылаемся. При этом не нужно указывать какую-либо специальную аннотацию, Rust
делает это по-умолчанию.

# Детали

Причина, по которой мы не можем использовать привязку после того как мы ее
переместили, трудно заметная, но очень важная. Когда мы пишем код вроде этого:

```rust
let v = vec![1, 2, 3];

let v2 = v;
```

Первая строка создает некоторые данные для вектора в стеке, `v`. Данные самого
вектора, однако, сохраняются в куче, и поэтому стековые данные содержат
указатель на данные в куче. Когда мы перемещаем `v` в `v2`, то создается копия
стековых данных, для `v2`. Что будет означать, что два указателя ссылаются на
расположенный в куче вектор. Такое поведение могло бы быть проблемой: оно
нарушало бы гарантии безопасности Rust, привнося гонки данных. Поэтому Rust
запрещает использование `v` после того как мы выполнили его перемещение.

Важно также отметить, что оптимизация может удалить фактическую (точную) копию
байтов, в зависимости от обстоятельств. Так что это может быть не так уж
неэффективно, как выглядит на первый взгляд.

# Типы, реализующие трейт `Copy`

Мы установили, что, как только право собственности передается другой привязке,
то вы больше не можете использовать оригинальную привязку. Тем не менее,
существует [трейт][traits], который изменяет такое поведение, и он называется
`Copy`. Мы еще не обсуждали трейты, но пока вы можете думать о них как об
аннотациях к конкретному типу, которые придают дополнительное поведение.
Например:

```rust
let v = 1;

let v2 = v;

println!("v is: {}", v);
```

В этом примере `v` является` i32`, который реализует трейт `Copy`. Это означает,
что, как и при перемещении, когда мы присваиваем привязку `v` привязке `v2`,
будет создана копия данных. Но, в отличие от перемещения, мы можем использовать
`v` в дальнейшем. Это потому, что в `i32` не имеет указателей на данные в каком-
либо другом месте, поэтому копирование - это полная копия.

Мы будем обсуждать, как сделать свои собственные типы, реализующие трейт `Copy`
в разделе [Трейты][traits].

[traits]: traits.html
