% Связывание переменных

Для начала рассмотрим тему о *связывании переменных*. Это выглядит так:

```rust
fn main() {
    let x = 5;
}
```

> Все операции производимые ниже будут происходть в функции `main()`, так как каждый раз вставлять в примеры `fn main() {` немного утомляет. Убедитесь что примеры приведенные в этом разделе вводите в функции `main()`, иначе вы можете получить ошибку при компилировании.

Во многих языках программирования это называется *переменная*. Но связывание переменных в Rust имеет пару трюков в рукаве. Rust имеет мощную особенность называемую *шаблоном*, который мы рассмотрим позже более детально, с левой стороны выражение `let` это полный шаблон, а не просто имя переменной. Это значит что мы можем делать вещи вроде этой:

```rust
let (x, y) = (1, 2);
```

После завершения этого выражения `x` будет единицей, a `y` двойкой. Шаблоны очень мощны, но пока это все, что мы можем с ними сделать. Мы их рассмотрим в отдельной теме.

Rust статически типизированный язык программирования, что означает, что мы сперва мы должны указать наш тип. Так почему же наш первый пример скомпилировался? В Rust'е есть такая вещь, как *определение типа*. Если Rust может понять какой тип у чего-либо, то он не требует указывать его.

Тем не менее, мы можем указать желаемый тип. Он следует после двоеточия (`:`):

```rust
let x: i32 = 5;
```

Если бы я попросил вас прочитать это вслух, то вы бы сказали "`x` связан с типом `int` и имеет значение `пять`"

В этом случае мы указали что `x` у нас будет 32-битным целым числом со знаком. Есть ещё и другие целочисленные типы. Они начинаются с `i` для целых чисел со знаком и `u` для целых чисел без знака. Возможный размер чисел может быть 8, 16, 32 и 64 бита.

Далее в примерах этого руководства, мы будем указывать тип в комментарии. Это будет выглядеть вот так:

```rust
fn main() {
    let x = 5; // x: i32
}
```

Добавлять эти комментарии вам не обязательно. Мы указываем их для того, чтобы помочь вам понять с каким типом Rust связывает переменную.

По-умолчанию, связывание *неизменяемо*. Этот код не скомпилируется:

```rust
let x = 5;
x = 10;
```

И вы получите ошибку:

```text
error: re-assignment of immutable variable `x`
     x = 10;
     ^~~~~~~
```

Если вы хотите что бы связывание было изменяемым, вы можете использовать `mut`:

```rust
let mut x = 5; // mut x: i32
x = 10;
```

Может показаться, что нет ни одной причины делать связывание неизменяемым по-умолчанию, но вспомните, на чем в первую очередь сфокусирован Rust: на безопасности. Если вы случайно забыли указать `mut`, компилятор поймет это, и вы узнаете, что изменили то, что возможно не собирались менять. Если бы связывание по-умолчанию было бы изменяемым, в такой ситуации компилятор не смог бы вам помочь. Если вы намерены сделать изменение, решение очень простое: добавьте `mut`.

Есть и другие весомые аргументы, по-возможности, избегать изменяемых состояний, но они выходят за рамки этого руководства. В общем, зачастую вы можете избежать явных изменений, поэтому это предпочтительнее в Rust. Тем не менее, иногда изменение это то, что вам нужно, так что это не запрещено.

Вернемся к связыванию. При связывании переменных в Rust есть еще одно отличие от других языков: связывание требует инициализации перед использованием.

Давайте приступим к рассмотрению вышесказаного. Измените ваш файл `src/main.rs` так, что бы он выглядел следующим образом:

```rust
fn main() {
    let x: i32;

    println!("Hello world!");
}
```

Используйте команду `cargo build` в командной строке чтобы собрать проект. Вы должны получить предупреждение, но программа будет работать и выводить строку "Hello, world!":

```text
   Compiling hello_world v0.0.1 (file:///home/you/projects/hello_world)
src/main.rs:2:9: 2:10 warning: unused variable: `x`, #[warn(unused_variable)] on by default
src/main.rs:2     let x: i32;
                      ^
```

Rust предупредит нас о том, что мы никогда не используем связанную переменную, но, так как мы не используем ее, никакого вреда и нарушения в этом нет. Однако, все изменится если мы попробуем использовать `x`. Сделаем это. Измените вашу программу так, что бы она выглядела следующим образом:

```rust
fn main() {
    let x: i32;

    println!("The value of x is: {}", x);
}
```

И попробуйте собрать проект. Вы получите ошибку:

```bash
$ cargo build
   Compiling hello_world v0.0.1 (file:///home/you/projects/hello_world)
src/main.rs:4:39: 4:40 error: use of possibly uninitialized variable: `x`
src/main.rs:4     println!("The value of x is: {}", x);
                                                    ^
note: in expansion of format_args!
<std macros>:2:23: 2:77 note: expansion site
<std macros>:1:1: 3:2 note: in expansion of println!
src/main.rs:4:5: 4:42 note: expansion site
error: aborting due to previous error
Could not compile `hello_world`.
```

Rust не позволит нам использовать неинициализированную переменную. Далее, поговорим о том, что мы добавили в `println!`.

Если вы добавите две фигурные скобки (`{}`, иногда называемые "усами"...) в вашу печатаемую строку, Rust истолкует это как просьбу своего рода вставки значения. *Строковая вставка* это термин в информатике, который обозначает "вставить посреди строки". Мы добавили запятую, и затем `x`, что бы указать, что мы хотим вставить `x` в строку. Запятая используется для разделения параметров передаваемых нами в функции и макросы, если вы передаёте больше одного.

Когда вы используете фигурные скобки, Rust попытается отобразить значение осмысленно, проверяя его тип. Если вы хотите указать формат более детально, тут есть [большое количество доступных параметров](http://doc.rust-lang.org/std/fmt/index.html). На данный момент мы будем вставлять как есть: целые числа не очень сложны для печати.