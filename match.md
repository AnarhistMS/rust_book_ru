% Сопоставление с образцом (Match)

Простого `if`/`else` часто недостаточно, потому что нужно проверить больше, чем
два возможных варианта. Да и к тому же условия в `else` часто становятся очень
сложными. Как же решить эту проблему?

В Rust есть ключевое слово `match`, позволяющее заменить группы операторов
`if`/`else` чем-то более удобным. Смотрите:

```{rust}
let x = 5;

match x {
    1 => println!("один"),
    2 => println!("два"),
    3 => println!("три"),
    4 => println!("четыре"),
    5 => println!("пять"),
    _ => println!("что-то ещё"),
}
```

`match` принимает выражение и выбирает одну из ветвей исполнения согласно его
значению. Каждая *ветвь* имеет форму `значение => выражение`. Выражение ветви
вычисляется, когда значение данной ветви совпадает со значением, принятым
оператором `match` (в данном случае, `x`). Эта конструкция называется `match`
(сопоставление), потому что она выполняет сопоставление значения неким
"образцам".

Так в чём же преимущества данной конструкции? Их несколько. Во-первых, ветви
`match` *проверяются на полноту*. Видите последнюю ветвь, со знаком
подчёркивания (`_`)? Если мы удалим её, Rust выдаст ошибку:

```text
error: non-exhaustive patterns: `_` not covered
```

Другими словами, компилятор сообщает нам, что мы забыли сопоставить какие-то
значения. Поскольку `x` - это целое число, оно может принимать разные значения -
например, `6`. Однако, если мы убираем ветвь `_`, ни одна ветвь не совпадёт,
поэтому такой код не скомпилируется. `_` - это *совпадение с любым значением*.
Если ни одна другая ветвь не совпала, совпадёт ветвь с `_`. Поскольку в примере
выше есть ветвь с `_`, мы покрываем всё множество значений `x`, и наша программа
скомпилируется.

Оператор `match` также осуществляет разбор перечислений. Помните этот код из
раздела про перечисления?

```{rust}
use std::cmp::Ordering;

fn cmp(a: i32, b: i32) -> Ordering {
    if a < b { Ordering::Less }
    else if a > b { Ordering::Greater }
    else { Ordering::Equal }
}

fn main() {
    let x = 5;
    let y = 10;

    let ordering = cmp(x, y);

    if ordering == Ordering::Less {
        println!("меньше");
    } else if ordering == Ordering::Greater {
        println!("больше");
    } else if ordering == Ordering::Equal {
        println!("равно");
    }
}
```

Мы можем переписать его с использованием `match`:

```{rust}
use std::cmp::Ordering;

fn cmp(a: i32, b: i32) -> Ordering {
    if a < b { Ordering::Less }
    else if a > b { Ordering::Greater }
    else { Ordering::Equal }
}

fn main() {
    let x = 5;
    let y = 10;

    match cmp(x, y) {
        Ordering::Less => println!("меньше"),
        Ordering::Greater => println!("больше"),
        Ordering::Equal => println!("равно"),
    }
}
```

Такой код не только чище, но и проверяет полноту сопоставления вариантов
перечисления `Ordering`. Если бы мы забыли случай `Greater` в примере с
`if`/`else`, наша программа всё равно скомпилировалась бы. А вот если мы забудем
сопоставить вариант перечисления в операторе `match`, то компилятор выдаст
ошибку. Rust помогает нам удостовериться, что перечисление обрабатывается верно.

Оператор `match` также позволяет извлекать значения, содержащихся в
перечислении. Это по-другому называется "деконструкцией" или "разбором".

```{rust}
enum OptionalInt {
    Value(i32),
    Missing,
}

fn main() {
    let x = OptionalInt::Value(5);
    let y = OptionalInt::Missing;

    match x {
        OptionalInt::Value(n) => println!("x равен {}", n),
        OptionalInt::Missing => println!("x отсутствует!"),
    }

    match y {
        OptionalInt::Value(n) => println!("y равен {}", n),
        OptionalInt::Missing => println!("y отсутствует!"),
    }
}
```

Вот так вы можете получить и использовать значения из перечислений. Это также
позволяет нам организовать обработку ошибок или непредвиденных ситуаций.
Например, функция, которая не всегда может вычислить результат (в данном случае
типа `i32`), может возвращать `OptionalInt`. Такое значение затем можно
обработать с помощью `match`. Как вы можете видеть, `enum` и `match` отлично
дополняют друг друга!

`match` также является выражением. Это значит, что мы можем использовать его в
правой части оператора `let` или прямо как результат. Мы могли бы реализовать
предыдущий пример так:

```{rust}
use std::cmp::Ordering;

fn cmp(a: i32, b: i32) -> Ordering {
    if a < b { Ordering::Less }
    else if a > b { Ordering::Greater }
    else { Ordering::Equal }
}

fn main() {
    let x = 5;
    let y = 10;

    println!("{}", match cmp(x, y) {
        Ordering::Less => "меньше",
        Ordering::Greater => "больше",
        Ordering::Equal => "равно",
    });
}
```

Иногда это очень удобно.
