% Кортежи

Первый агрегатный тип данных, о котором мы поговорим - это *кортеж*. Кортеж -
это упорядоченный список фиксированного размера. Вроде такого:

```rust
let x = (1, "привет");
```

Этот кортеж из двух элементов создан с помощью скобок и запятой между
элементами. Вот тот же код, но с аннотациями типов:

```rust
let x: (i32, &str) = (1, "привет");
```

Как вы можете видеть, тип кортежа выглядит как сам кортеж, но места элементов
занимают типы. Внимательные читатели также отметят, что кортежи гетерогенны: в
этом кортеже одновременно хранятся значения типов `i32` и `&str`. Мы уже
встречали тип `&str` ранее, и мы обсудим строки подробнее далее. В языках
системного программирования строки немного более сложны, чем в других языках.
Пока вы можете читать `&str` как *срез строки*. Мы вскоре узнаем об этом больше.

Доступ к полям кортежа можно получить с помощью *деконструирующего let*. Вот
пример:

```rust
let (x, y, z) = (1, 2, 3);

println!("x это {}", x);
```

Помните, я говорил, что левая часть оператора `let` более полезна, чем просто
присваивание имени? Об этом я и говорил. Мы можем написать слева от `let`
образец, и, если он совпадает со значением справа, произойдёт присваивание имён
сразу нескольким значениям. В данном случае, `let` "деконструирует" или
"разбивает" кортеж, и присваивает его части трём именам.

Это очень удобный шаблон программирования, и мы ещё не раз увидим его.

Некоторые вещи можно делать с кортежами как с единым целым, без разбиения. Можно
присваивать один кортеж другому, если они содержат значения одинаковых типов и
имеют одинаковую [арность][arity]. Арность кортежей одинакова, когда их длина
совпадает.

```rust
let mut x = (1, 2); // x: (i32, i32)
let y = (2, 3); // y: (i32, i32)

x = y;
```

Вы также можете проверять кортежи на равенство с помощью операции `==`. Опять-
таки, это скомпилируется только если кортежи имеют одинаковые типы.

```rust
let x = (1, 2, 3);
let y = (2, 2, 4);

if x == y {
    println!("да");
} else {
    println!("нет");
}
```

Этот код напечатает `нет`, потому что некоторые элементы не равны.

Заметьте, что порядок элементов важен при сравнении кортежей, поэтому в
следующем примере код также напечатает `нет`.

```rust
let x = (1, 2, 3);
let y = (2, 1, 3);

if x == y {
    println!("да");
} else {
    println!("нет");
}
```

Другой способ использовать кортежи - это возврат множества значений из функции:

```rust
fn next_two(x: i32) -> (i32, i32) { (x + 1, x + 2) }

fn main() {
    let (x, y) = next_two(5);
    println!("x, y = {}, {}", x, y);
}
```

Несмотря на то, что функции в Rust могут возвращать только одно значение, в
данном случае это не помеха. Кортеж - это *одно* значение, которое состоит из
нескольких. В этом примере вы также можете видеть пример разбиения кортежа,
возвращаемого функцией.

Кортежи - это очень простая структура данных, и часто они вам не подойдут.
Давайте рассмотрим их старшего брата, структуры.

[arity]: ./glossary.html#arity
