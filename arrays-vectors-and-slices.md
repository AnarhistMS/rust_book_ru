% Массивы, вектора, срезы

В Rust, как и во многих других языках программирования, есть типы-списки для
представления последовательностей неких вещей. Самый простой из них - это
*массив*, то есть список элементов одного и того же типа, имеющий фиксированный
размер. Массивы неизменяемы по умолчанию.

```{rust}
let a = [1, 2, 3]; // a: [i32; 3]
let mut m = [1, 2, 3]; // mut m: [i32; 3]
```

Для инициализации всех элементов массива одним и тем же значением есть
специальный синтаксис. В этом примере каждый элемент `a` будет инициализирован
значением `0`:

```{rust}
let a = [0; 20]; // a: [i32; 20]
```

Тип массивов - `[T; N]`. Мы поговорим об этих обозначениях позже, когда будем
рассматривать обобщенные типы.

Вы можете получить число элементов массива `a` с помощью вызова `a.len()`, и
использовать `a.iter()` для перебора элементов в цикле. Этот код напечатает все
числа по порядку:

```{rust}
let a = [1, 2, 3];

println!("Число элементов в a: {}", a.len());
for e in a.iter() {
    println!("{}", e);
}
```

Вы можете получить определённый элемент массива с помощью *индекса*:

```{rust}
let names = ["Graydon", "Brian", "Niko"]; // names: [&str; 3]

println!("Второе имя: {}", names[1]);
```

Индексы нумеруются с нуля, как и в большинстве языков программирования, поэтому
мы получаем первое имя с помощью `names[0]`, а второе - с помощью `names[1]`.
Пример выше печатает `Второе имя: Brian`. Если вы попытаетесь использовать
индекс, который не входит в массив, вы получите ошибку: при доступе к массивам
происходит проверка границ во время исполнения программы. Такая ошибочная
попытка доступа - источник многих проблем в других языках системного
программирования.

*Вектор* - это динамический, "растущий" массив, реализованный в виде
стандартного библиотечного типа [`Vec<T>`](../std/vec/) (позже мы поговорим о
том, что здесь означает `<T>`). Вектора всегда помещают данные в куче. Вектора и
срез - это как `String` и `&str`. Вы можете создавать их с помощью макроса
`vec!`:

```{rust}
let v = vec![1, 2, 3]; // v: Vec<i32>
```

(Заметьте, что, в отличие от макроса `println!`, который мы использовали ранее,
с `vec!` используются квадратные скобки `[]`. Rust разрешает использование и
круглых, и квадратных скобок в обеих ситуациях - это просто стилистическое
соглашение.)

Для создания вектора из повторяющихся значений есть другая форма `vec!`:

```
let v = vec![0; 10]; // ten zeroes
```

Вы можете получать длину, перебирать и индексировать вектора так же, как и
массивы. К тому же, (изменяемые) вектора могут расти автоматически:

```{rust}
let mut nums = vec![1, 2, 3]; // mut nums: Vec<i32>

nums.push(4);

println!("Теперь длина nums составляет {}", nums.len()); // Печатает 4
```

У векторов есть много других полезных методов.

*Срез* - это ссылка на (или "проекция" в) массив. Они полезны, когда нужно
обеспечить безопасный, эффективный доступ к части массива без копирования.
Например, возможно вам нужно сослаться на единственную строку файла, считанного
в память. Из-за своей ссылочной природы, срезы создаются не напрямую, а из
существующих переменных. У срезов есть длина, они могут быть изменяемы или нет,
и во многих случаях они ведут себя как массивы:

```{rust}
let a = [0, 1, 2, 3, 4];
let middle = &a[1..4]; // Срез a: только элементы 1, 2, и 3

for e in middle.iter() {
    println!("{}", e); // Печатает 1, 2, 3
}
```

Вы также можете взять срез вектора, типа `String` или `&str`, потому что все они
реализованы через массивы. Срезы имеют тип `&[T]`, и мы поговорим о нём позже,
во время обсуждения обобщённых типов.

Мы изучили все основные элементы языка Rust.
