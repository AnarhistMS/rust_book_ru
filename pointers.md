% Указатели

Rust уникален в своей реализации указателей. В то же время, эта черта языка -
одна из наиболее непонятных для новичков. И даже люди, имеющие опыт с
указателями в других языках, могут смутиться. Эта глава поможет вам разобраться
с этой важной темой.

Не-ссылочные указатели в Rust надо использовать с умом - не применяйте их
"просто, чтобы программа скомпилировалась". Каждый вид указателей имеет
определённую область применения. По умолчанию, используйте обычные ссылки.

[Страница подсказок](#cheat-sheet) с обзором типов, имён и назначений различных
указателей также может быть вам интересна.

# Введение

Короткое введение для тех, кто не знаком с понятием "указатель".  Это
основополагающая сущность в языках системного программирования.  Убедитесь в
том, что вы понимаете данную тему.

## Основы указателей

Когда вы создаёте новое имя с помощью оператора `let`, вы называете значение,
находящееся в определённом месте на стеке. (Если вы не знакомы с понятиями
*стек* и *куча*, рассмотрите
[данный вопрос на Stack Overflow](http://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap).
Текст далее подразумевает, что вы понимаете разницу.)

Вот о чём мы говорим:

```{rust}
let x = 5;
let y = 8;
```

| адрес    | значение |
|----------|----------|
| 0xd3e030 | 5        |
| 0xd3e028 | 8        |

Адреса в памяти в данном случае придуманы. Это просто значения для примера. Суть
в том, что имя `x` соответствует адресу `0xd3e030`, и значение, хранящееся по
этому адресу - это `5`. Когда мы обращаемся к `x`, мы получаем соответствующее
значение. Таким образом, `x` - это `5`.

Давайте введём указатель. В некоторых языках только один тип указателей, но в
Rust их несколько. В данном случае мы используем *ссылку*. Это простейший вид
указателей:

```{rust}
let x = 5;
let y = 8;
let z = &y;
```

|адрес    | значение |
|-------- |----------|
|0xd3e030 | 5        |
|0xd3e028 | 8        |
|0xd3e020 | 0xd3e028 |

Видите разницу? Значение указателя - это адрес в памяти. В данном случае, это
адрес `y`. `x` и `y` имеют тип `i32`, а вот `z` - `&i32`.  Мы можем распечатать
адрес с помощью форматной строки `{:p}`:

```{rust}
let x = 5;
let y = 8;
let z = &y;

println!("{:p}", z);
```

С нашими придуманными адресами, этот код напечатал бы `0xd3e028`.

Поскольку `i32` и `&i32` - разные типы, мы не можем складывать их:

```{rust,ignore}
let x = 5;
let y = 8;
let z = &y;

println!("{}", x + z);
```

Такой код выдаёт ошибку:

```text
hello.rs:6:24: 6:25 error: mismatched types: expected `_`, found `&_` (expected integral variable, found &-ptr)
hello.rs:6     println!("{}", x + z);
                                  ^
```

Мы можем *разыменовать* указатель с помощью операции `*`. Разыменовать
указатель - значит получить значение, хранящееся по данному адресу в памяти. Вот
пример рабочего кода:

```{rust}
let x = 5;
let y = 8;
let z = &y;

println!("{}", x + *z);
```

Он напечатает `13`.

Вот и всё! Указатели просто указывают на некоторое место в памяти. Ничего
особенного. Теперь, когда мы узнали, *что* такое указатели, обсудим, *зачем* они
нужны.

## Использование указателей

Указатели в Rust используются по-другому, нежели в других языках системного
программирования. Позже мы поговорим о лучших способах их применения в Rust, а
пока рассмотрим указатели в других языках.

В C, строки - это указатели на список `char`ов, закачивающийся нулевым
байтом. Только поняв указатели, вы сможете пользоваться строками.

Указатели используют для указания на места в памяти, которые не находятся на
стеке. Наш предыдущий пример использовал две стековые переменные, и мы могли
дать им имя. В C, функция `malloc` выделяет память в куче, и она возвращает
указатель.

Как обобщение предыдущих двух случаев, указатели используют когда нужно хранить
некие структуры переменного размера. Размер памяти, необходимый для хранения
таких структур, нельзя определить во время компиляции. Поэтому память выделяют
динамически, и сохраняют указатель на эту память.

Указатели полезны в языках, в которых используется передача аргументов функциям
по значению. По сути, языки следуют одной из двух моделей (пример дальше - на
выдуманном языке, не Rust):

```text
func foo(x) {
    x = 5
}

func main() {
    i = 1
    foo(i)
    // каково значение i здесь?
}
```

В языках с передачей аргументов по значению `foo` получит свою копию `i`, так
что исходная версия переменной не поменяется. В конце программы `i` всё равно
будет равно `1`. А в языках, использующих передачу по ссылке, `foo` получит
ссылку на `i` и сможет изменять её значение. В конце программы `i` будет `5`.

Так как всё это связано с указателями? Поскольку указатели указывают на место в
памяти...

```text
func foo(&i32 x) {
    *x = 5
}

func main() {
    i = 1
    foo(&i)
    // каково значение i здесь?
}
```

Даже в языке, использующем передачу по значению, `i` будет равно `5` в конце.
Аргумент функции `x` - это указатель, и хотя `foo` получит свою копию аргумента,
это всё равно будет указатель на то же место в памяти! Поэтому мы сможем
изменить исходную переменную. Это называется *передачей ссылки по значению*.
Хитро!

## Проблемы использования указателей

Мы поговорили о том, какие указатели классные. Но в чём же их недостатки?
Давайте рассмотрим проблемы, возникающие при использовании указателей в других
языках, и обсудим, как Rust решает их.

Неинициализированные указатели могут вызвать проблемы. К примеру, что сделает
эта программа?

```{ignore}
&int x;
*x = 5; // ой!
```

Никто не знает. Мы объявляем указатель, который не указывает ни на один объект.
Затем мы разыменовываем указатель и присваиваем этому месту в памяти значение
`5`. Но что это за место в памяти? Неизвестно. Возможно, этот код выполнится без
особых последствий, а возможно, случится катастрофа.

Когда вы работаете с указателями в функциях, легко случайно испортить память,
на которую указывает указатель. Например:

```text
func make_pointer(): &int {
    x = 5;

    return &x;
}

func main() {
    &int i = make_pointer();
    *i = 5; // ох!
}
```

`x` - это локальная переменная в функции `make_pointer`, и её значение
неопределено после выхода из функции. Но мы возвращаем указатель на это место
в памяти и пытаемся присвоить ему значение в `main`! Это похоже на предыдущий
пример. Присваивание значений по неверным адресам до добра не доведёт!

Ещё одна большая проблема указателей - это *совпадение* указателей. Два
указателя совпадают, если они указывают на одно и то же место в памяти. Вот так:

```text
func mutate(&int i, int j) {
    *i = j;
}

func main() {
  x = 5;
  y = &x;
  z = &x; //y and z are aliased


  run_in_new_thread(mutate, y, 1);
  run_in_new_thread(mutate, z, 100);

  // каково значение x здесь?
}
```

В этом придуманном примере, `run_in_new_thread` запускает вычисление функции в
новом потоке. Поскольку у нас два потока, и они работают с совпадающими
указателями, они будут пытаться изменить одно и то же место в памяти. Поэтому
значение `x` в конце программы не детерминировано. К тому же, один из потоков
мог испортить память, на которую указывал аргумент. Мы снова попытались бы
записать значение в неправильное место в памяти.

## Заключение

Мы рассмотрели указатели в целом. Как мы упоминали ранее, в Rust есть несколько
видов указателей. И в нашем языке все перечисленные проблемы решены. Это
достигается путём некоторого усложнения понятия "указатель", но это того стоит.

# Ссылки

Самый простой вид указателя в Rust - это *ссылка*. Ссылки в Rust выглядят так:

```{rust}
let x = 5;
let y = &x;

println!("{}", *y);
println!("{:p}", y);
println!("{}", y);
```

Мы можем сказать, что `y` - это ссылка на `x`. Первый `println!` печатает
значение, на которое ссылается `y`, с помощью разыменования (`*`). Второй
печатает адрес в памяти, на который указывает `y`, используя форматную строку
для указателей. Третий `println!` также печатает значение, на которое ссылается
`y`, потому что `println!` выполнит разыменование автоматически.

Вот функция, принимающая ссылку:

```{rust}
fn succ(x: &i32) -> i32 { *x + 1 }
```

Вы также можете использовать операцию `&` для создания ссылки, поэтому мы можем
вызвать данную функцию двумя разными способами:

```{rust}
fn succ(x: &i32) -> i32 { *x + 1 }

fn main() {

    let x = 5;
    let y = &x;

    println!("{}", succ(y));
    println!("{}", succ(&x));
}
```

Оба этих `println!` напечатают `6`.

Конечно, в настоящем коде мы бы не стали заморачиваться со ссылками и просто
написали бы так:

```{rust}
fn succ(x: i32) -> i32 { x + 1 }
```

Ссылки неизменяемы по умолчанию:

```{rust,ignore}
let x = 5;
let y = &x;

*y = 5; // error: cannot assign to immutable borrowed content `*y`
```

Вы можете сделать их изменяемыми с помощью ключевого слова `mut`, но для этого
нужно, чтобы они сами ссылались на изменяемые объекты. Вот это работает:

```{rust}
let mut x = 5;
let y = &mut x;
```

А это - нет:

```{rust,ignore}
let x = 5;
let y = &mut x; // error: cannot borrow immutable local variable `x` as mutable
```

Неизменяемые указатели могут совпадать:

```{rust}
let x = 5;
let y = &x;
let z = &x;
```

А изменяемые - нет:

```{rust,ignore}
let mut x = 5;
let y = &mut x;
let z = &mut x; // error: cannot borrow `x` as mutable more than once at a time
```

Во время исполнения ссылка представляется обычным указателем, как в C. Однако,
ссылки полностью безопасны. И при этом, они не добавляют накладных расходов.
Все проверки происходят во время компиляции, с помощью теории *региональных
указателей* (region pointers). Региональные указатели эволюционировали в то, что
теперь называется *сроками жизни*.

Объясним суть данной методики на простом примере. Скажите, вы считаете, что
такой код должен скомпилироваться?

```{rust,ignore}
fn main() {
    println!("{}", x);
    let x = 5;
}
```

Скорее всего, нет. И это потому, что обращение к `x` допустимо с момента
объявления до выхода этого имени из области видимости. В данном случае, область
видимости заканчивается в конце функции `main`. Поэтому вы можете быть уверены,
что такой код вызовет ошибку. Период с момента объявления некого имени до
выхода его из области видимости называется *сроком жизни*. Давайте рассмотрим
пример посложнее:

```{rust}
fn main() {
    let mut x = 5;

    if x < 10 {
        let y = &x;

        println!("О нет: {}", y);
        return;
    }

    x -= 1;

    println!("О нет: {}", x);
}
```

Здесь мы заимствуем указатель на `x` внутри `if`. Но компилятор распознаёт, что
сам `x` не будет изменён за время существования указателя, и компилирует такой
код. А вот такой пример работать не будет:

```{rust,ignore}
fn main() {
    let mut x = 5;

    if x < 10 {
        let y = &x;

        x -= 1;

        println!("О нет: {}", y);
        return;
    }

    x -= 1;

    println!("О нет: {}", x);
}
```

It gives this error:

```text
test.rs:7:9: 7:15 error: cannot assign to `x` because it is borrowed
test.rs:7         x -= 1;
                  ^~~~~~
test.rs:5:18: 5:19 note: borrow of `x` occurs here
test.rs:5         let y = &x;
                           ^
```

Такой анализ сложен не только для человека, но и для компилятора. У нас есть
[отдельное руководство по ссылкам, владению и срокам жизни](ownership.html), и
оно рассматривает эту тему гораздо подробнее.

## Лучшие техники

В общем случае предпочитайте выделение памяти на стеке, нежели на
куче. Используйте ссылки на стековые данные, если это возможно. Таким образом,
указатели, которые вы должны использовать по умолчанию - это ссылки. Используйте
другие виды указателей в соответствующих ситуациях. Что это за ситуации, мы
опишем далее.

Если вам нужен указатель, но вы не хотите принимать владение данными,
используйте ссылку. Ссылки заимствуют данные, что более правильно, если
владение вам не нужно. Другими словами, предпочитайте такой код:

```{rust}
fn succ(x: &i32) -> i32 { *x + 1 }
```

такому

```{rust}
fn succ(x: Box<i32>) -> i32 { *x + 1 }
```

Заодно вы получаете возможность принимать целую кучу разных указателей в
качестве аргумента, а не только то, что вы явно прописали (`Box<i32>`). Так что
этот код лучше:

```{rust}
fn succ(x: &i32) -> i32 { *x + 1 }
```

чем этот

```{rust}
use std::rc::Rc;

fn box_succ(x: Box<i32>) -> i32 { *x + 1 }

fn rc_succ(x: Rc<i32>) -> i32 { *x + 1 }
```

Однако заметьте, что вам потребуется сделать небольшие изменения на
вызывающей стороне:

```{rust}
use std::rc::Rc;

fn succ(x: &i32) -> i32 { *x + 1 }

let ref_x = &5;
let box_x = Box::new(5);
let rc_x = Rc::new(5);

succ(ref_x);
succ(&box_x);
succ(&rc_x);
```

`&` здесь получает из указателей (`Box` и `Rc`) обычную ссылку и передаёт её в
качестве аргумента.

# Упакованные указатели

`Box<T>` - это тип *упакованного указателя*. Упакованный указатель - это простейший способ выделить
память в куче. Вот как создать такой указатель:

```{rust}
let x = Box::new(5);
```

Упакованные указатели выделяются на куче и освобождают память автоматически,
когда выходят из области видимости:

```{rust}
{
    let x = Box::new(5);

    // что-то происходит

} // x уничтожается и освобождает память
```

При этом, упакованные указатели _не_ используют подсчёт ссылок или сборку
мусора. Они - представители так называемого *афинного типа*. Это значит, что
компилятор Rust статически определяет, когда каждый упакованный указатель
становится виден и когда - выходит из области видимости. Благодаря этому,
компилятор может вставить соответствующие вызовы процедур деинициализации там,
где это необходимо.

К счастью, вам не нужно быть гуру теории типов чтобы понять суть упакованных
указателей. В принципе, вы можете воспринимать такой код на Rust:

```{rust}
{
    let x = Box::new(5);

    // что-то происходит
}
```

как аналогичный такому коду на C:

```c
{
    int *x;
    x = (int *)malloc(sizeof(int));
    *x = 5;

    // что-то происходит

    free(x);
}
```

Конечно, здесь мы утрируем - например, не говорим о вызовах деструкторов. Но в
целом идея проста - вы получаете автоматический вызов `malloc` и `free`. Это
даёт нам следующие преимущества:

1. Вы не можете выделить неправильное количество памяти для хранения объекта.
   Rust определяет размер из типа выделяемых данных.
2. Вы не можете забыть освободить выделенную память, потому что это происходит
   само.
3. Rust гарантирует, что `free` вызывается в правильный момент - когда данный
   объект точно никем не используется. Типичная ошибка использования после
   освобождения исключена.
4. Rust проверяет, что нет других изменяемых указателей на эту память в куче.
   Это означает, что запись по неверному указателю невозможна.

Более подробное обсуждение ссылок, упакованных указателей и сроков жизни можно
найти в [руководстве по владению](ownership.html).

Использование упакованных указателей в комбинации со ссылками очень
распространено. Например:

```{rust}
fn add_one(x: &i32) -> i32 {
    *x + 1
}

fn main() {
    let x = Box::new(5);

    println!("{}", add_one(&*x));
}
```

В данном случае компилятор знает, что функция `add_one()` заимствует `x`, не
производя изменений этого значения. Поэтому такой код допустим.

Мы даже можем заимствовать `x` несколько раз одновременно, если не хотим его
менять:

```{rust}
fn add(x: &i32, y: &i32) -> i32 {
    *x + *y
}

fn main() {
    let x = Box::new(5);

    println!("{}", add(&*x, &*x));
    println!("{}", add(&*x, &*x));
}
```

Мы можем несколько раз позаимствовать `x` с возможностью изменения, но только
если сам `x` изменяем. В таком случае мы не можем получить несколько ссылок
*одновременно*:

```{rust,ignore}
fn increment(x: &mut i32) {
    *x += 1;
}

fn main() {
    // Если имя не объявлено как "mut", это не скомпилируется
    let mut x = Box::new(5);

    increment(&mut x);
    increment(&mut x);
    println!("{}", x);
}
```

Заметьте, что в сигнатуре `increment()` указана изменяемая ссылка.

## Лучшие техники

Упакованные указатели применяются в двух ситуациях: для реализации рекурсивных
структур данных и, иногда, при возврате данных.

### Рекурсивные структуры данных

Иногда вам понадобятся рекурсивные структуры данных. Простейшая из них - это
список в стиле Lisp (*cons list*):

```{rust}
#[derive(Debug)]
enum List<T> {
    Cons(T, Box<List<T>>),
    Nil,
}

fn main() {
    let list: List<i32> = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Cons(3, Box::new(List::Nil))))));
    println!("{:?}", list);
}
```

Вот что напечатает код:

```text
Cons(1, Box(Cons(2, Box(Cons(3, Box(Nil))))))
```

Ссылка на следующий `List` внутри варианта перечисления `Cons` должна быть
упакованным указателем, потому что длина списка нам неизвестна. Из-за этого мы
не знаем, сколько памяти выделять под список. Поэтому мы пользуемся выделением
памяти в куче с помощью упакованных указателей.

Работа с рекурсивными структурами данных, а также работа с данными динамического
размера - это основная область применения упакованных указателей.

### Возврат данных

Эта тема важна настолько, что мы выделили её в отдельный раздел. Вот в чём суть:
обычно вам не нужно возвращать указатели, даже если бы вы сделали так в C или
C++.

Смотрите [возврат указателей](#returning-pointers) с более подробным описанием
этого тонкого момента.

# Ссылка с подсчётом и атомарная ссылка с подсчётом (Rc и Arc)

Этот раздел в процессе написания.

## Лучшие техники

Этот раздел в процессе написания.

# Голые указатели

Этот раздел в процессе написания.

## Лучшие практики

Этот раздел в процессе написания.

# Возврат указателей.

Во многих языках с указателями вы вернёте указатель из функции, когда
хотите избежать копирования большой структуры данных. Например:

```{rust}
struct BigStruct {
    one: i32,
    two: i32,
    // и так далее
    one_hundred: i32,
}

fn foo(x: Box<BigStruct>) -> Box<BigStruct> {
    Box::new(*x)
}

fn main() {
    let x = Box::new(BigStruct {
        one: 1,
        two: 2,
        one_hundred: 100,
    });

    let y = foo(x);
}
```

Суть в том, что при передаче упакованного указателя копируется только сам
указатель, а не сто `i32`, хранящихся в `BigStruct`.

В Rust так не делают. Пишут так:

```rust
#![feature(box_syntax)]

struct BigStruct {
    one: i32,
    two: i32,
    // и так далее
    one_hundred: i32,
}

fn foo(x: Box<BigStruct>) -> BigStruct {
    *x
}

fn main() {
    let x = Box::new(BigStruct {
        one: 1,
        two: 2,
        one_hundred: 100,
    });

    let y: Box<BigStruct> = box foo(x);
}
```

Заметьте, что вам придётся включить огороженную возможность `box_syntax`. Данный
синтаксис может измениться в будущем.

В этом варианте вы получаете гибкость без ущерба производительности.

Вы можете подумать, что это будет ужасно неэффективно: сначала вернуть большую
структуру по значению (что должно было бы вызвать её копирование), а затем
упаковать её, поместив в кучу. Выглядит как объединение худших черт возврата
упакованного указателя и обычного значения. Но, к счастью, компилятор более
умён, чем кажется. В таком коде не происходит копирования. `main` сразу выделяет
достаточно памяти для упакованного указателя, передаёт указатель на эту память
в `foo` в качестве `x`, и `foo` записывает значение прямо в `Box<T>`.

Это настолько важно, что мы повторим ещё раз: не надо использовать указатели
для оптимизации возврата значений из вашего кода! Позвольте вызывающей стороне
решить, куда они хотят поместить результат.

# Создание ваших собственных указателей.

Этот раздел в процессе написания.

## Лучшие техники

Этот раздел в процессе написания.

# Образцы (patterns) и `ref`

Когда вы сопоставляете с образцом нечто, доступное по указателю, прямое
сопоставление - не всегда лучшее решение. Давайте посмотрим, как поступить
правильно:

```{rust,ignore}
fn possibly_print(x: &Option<String>) {
    match *x {
        // ПЛОХО: перемещение значения из ссылки (`&`) невозможно
        Some(s) => println!("{}", s)

        // ХОРОШО: получите ссылку на значение внутри `Option`
        Some(ref s) => println!("{}", *s),
        None => {}
    }
}
```

`ref s` означает, что мы сопоставляем с типом `&String`, а не `String`.

Это важно, когда у значения, к которому вы обращаетесь, есть деструктор и вы не
хотите перемещать его. Достаточно простой ссылки.

# Страница подсказок

Вот краткий обзор указательных типов Rust:

| Тип          | Название                      | Описание                                                                             |
|--------------|-------------------------------|--------------------------------------------------------------------------------------|
| `&T`         | Ссылка                        | Одна или более неизменяемая ссылка на `T`                                            |
| `&mut T`     | Изменяемая ссылка             | Единственная ссылка для чтения и записи `T`                                          |
| `Box<T>`     | Упакованный указатель         | `T`, выделенный на куче, с единственным владельцем, который может и читать, и писать |
| `Rc<T>`      | Ссылка с подсчётом            | `T`, выделенный на куче, с множеством читателей                                      |
| `Arc<T>`     | Атомарная ссылка с подсчётом  | То же, что и выше, но безопасно для передачи в другие потоки                         |
| `*const T`   | Голый указатель               | Небезопасный доступ к `T` на чтение                                                  |
| `*mut T`     | Изменяемый голый указатель    | Небезопасный доступ к `T` на чтение и запись                                         |

# Другие документы

* [API упакованных указателей](../std/boxed/index.html)
* [Руководство по владению](ownership.html)
* [Статья про регионы в языке Cyclone](http://www.cs.umd.edu/projects/cyclone/papers/cyclone-regions.pdf), которая вдохновила систему сроков жизни Rust
