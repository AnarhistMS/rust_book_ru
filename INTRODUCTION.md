% Язык программирования Rust

Добро пожаловать! Эта книга обучает основным принципам работы с языком
программирования [Rust][rust]. Rust - это системный язык программирования,
внимание которого сосредоточено на трех задачах: безопасность, скорость и
параллелизм. Он решает эти задачи без сборщика мусора, что делает его полезным в
ряде случаев, когда использование других языков было бы не целесообразно: при
встраивании в другие языки, при написании программ с конкретными
пространственными и временными требованиями, при написании низкоуровневого кода,
такого как драйверы устройств и операционные системы. Это улучшает текущие
языки, имеющие аналогичную направленность, тем что имеет ряд проверок
безопасности во время компиляции, которые не создают накладных расходов во время
выполнения, но устраняют при этом гонки данных. Rust также направлен ​​на
достижение ‘абстракции с нулевой стоимостью‘, хотя некоторые из этих абстракций
ведут себя как в языках высокого уровня. Даже тогда Rust по-прежнему
обеспечивает точный контроль как делал бы язык низкого уровня.

[rust]: http://rust-lang.org

Книга "Язык программирования Rust" делится на семь разделов. Это введение
является первым из них. Затем:

* [C чего начать][gs] - Настройка компьютера для разработки на Rust.
* [Изучение Rust][lr] - Обучение программированию на Rust на примере небольших проектов.
* [Эффективное использование Rust][er] - Понятия более высокого уровня для написания качественного код на Rust.
* [Синтаксис и семантика][ss] - Каждая концепция Rust разбивается на небольшие кусочки.
* [Нестабильные фичи Rust][nr] - Передовые фичи, которые пока не добавлены в стабильную сборку.
* [Глоссарий][gl] - Ссылки на термины, используемые в книге.

[gs]: getting-started.html
[lr]: learn-rust.html
[er]: effective-rust.html
[ss]: syntax-and-semantics.html
[nr]: nightly-rust.html
[gl]: glossary.html

После прочтения этого введения, вы можете продлжить дальнейшее изучение либо в
направлении ’Изучение Rust’, либо в направлении ’Синтаксис и семантика’, в
зависимости от ваших предпочтений. ’Изучение Rust’ - если вы предпочитаете
изучить язык на примере реального проекта. ’Синтаксис и семантика’ - если вы
предпочитаете тщательно изучить каждую концепцию языка отдельно, перед тем как
двигаться дальше. Множество кросс-ссылок соединяет эти части воедино.

## Краткое введение в Rust

Rust - это язык, который мог бы заинтересовать вас? Давайте рассмотрим несколько
небольших примеров кода, чтобы продемонстрировать некоторые из его сильных
сторон.

Основная концепция, которое делает Rust уникальным, называется ‘владение’.
Рассмотрим этот небольшой пример:

```rust
fn main() {
    let mut x = vec!["Hello", "world"];
}
```

Эта программа создает [привязку переменной][var] с именем `x`. Значением этого
связывания является `Vec<T>`, ‘вектор‘, который мы создаем с помощью
[макроса][macro], определенного в стандартной библиотеке. Этот макрос называется
`vec`, и при его вызове используется символ `!`. Это следует из общего принципа
Rust: делать вещи ясными. Макрос может делать значительно более сложные вещи,
чем вызовов функций, и поэтому они визуально отличаются. Символ `!` также
помогает при парсинге, делая написание инструментов легче, что тоже важно.

Мы использовали `mut`, чтобы сделать `x` изменяемой: по умолчанию привязки
являются неизменяемыми в Rust. Мы будем изменять этот вектор в примере дальше.

Стоит также отметить, что мы не должны указывать тип здесь: несмотря на то что
Rust является статически типизированным, мы не должны явно указывать тип. Rust
обладает выводом типов, чтобы сбалансировать мощь статической типизации с
многословным указанием типов.

Rust предпочитает выделение памяти в стеке выделению памяти в куче: `x`
находится непосредственно в стеке. Однако тип `Vec<T>` выделяет пространство для
элементов вектора в куче. Если вы не знакомы с различиями этих двух видов
выделения памяти, вы можете пока просто проигнорировать эту информацию или же
ознакомиться с разделом [‘Стек и Куча‘][heap]. Как системный язык
программирования, Rust дает вам возможность контролировать выделение памяти, но
когда мы, как начать, это менее крупной сделки.

[var]: variable-bindings.html
[macro]: macros.html
[heap]: the-stack-and-the-heap.html

Ранее мы упоминали, что ‘владение‘ является ключевой новой концепцией в Rust. В
терминологиии Rust, `x` ‘владеет‘ вектором. Это означает, что как только `x`
выходит из области видимости, выделенная для вектора память будет освобождена.
Это делается детерминированно средствами компилятора Rust, а не через механизм
сборки мусора. Другими словами, в Rust вы не вызываете функции, такие как
`malloc` и `free`, самостоятельно: компилятор статически определяет, когда нужно
выделить или освободить память, и вставляет эти вызовы самостоятельно. Человек
может совершить ошибку при использовании этих вызовов, а компилятор - никогда.

Давайте добавим еще одну строку в наш пример:

```rust
fn main() {
    let mut x = vec!["Hello", "world"];

    let y = &x[0];
}
```

We’ve introduced another binding, `y`. In this case, `y` is a ‘reference’ to
the first element of the vector. Rust’s references are similar to pointers in
other languages, but with additional compile-time safety checks. References
interact with the ownership system by [‘borrowing’][borrowing] what they point
to, rather than owning it. The difference is, when the reference goes out of
scope, it will not deallocate the underlying memory. If it did, we’d
de-allocate twice, which is bad!

Мы создаем еще одну привязку, `y`. В этом случае, `y` является ‘ссылкой‘ на
первый элемент вектора. Ссылки в Rust похожи на указатели в других языках, но с
дополнительными проверками безопасности во время компиляции. Ссылки
взаимодействуют с системой прав владения следующим образом: они
[‘заимствуют’][borrowing] то, на что указывают, а не владеют этим. Разница в
том, что когда ссылка выходит за пределы области видимости, она не освобождает
основную память. Если бы это было не так, то память освобождалась бы два раза,
что плохо!

[borrowing]: references-and-borrowing.html

Давайте добавим третью строку. На первый взгляд в коде нет ничего такого, но он
вызывает ошибку компилятора:

```rust,ignore
fn main() {
    let mut x = vec!["Hello", "world"];

    let y = &x[0];

    x.push("foo");
}
```

`push` - это метод, который добавляет еще один элемент в конец вектора. Когда мы
пытаемся скомпилировать эту программу, то получаем ошибку:

```text
error: cannot borrow `x` as mutable because it is also borrowed as immutable
    x.push(4);
    ^
note: previous borrow of `x` occurs here; the immutable borrow prevents
subsequent moves or mutable borrows of `x` until the borrow ends
    let y = &x[0];
             ^
note: previous borrow ends here
fn main() {

}
^
```

Вот так! Компилятор Rust в некоторых случаях выдает достаточно подробные ошибки,
и это как раз один из тех случаев. Как объясняется в ошибке, мы не можем создать
изменяемое связывание (не можем вызвать метод `push`), так как у нас уже есть
неизменяемое связывание. Это потому, что у нас уже есть ссылка на элемент
вектора, `y`. Выполнять изменение вектора, пока существует другая ссылка на
него, опасно, потому что можно сделать ссылку недействительной. В данном
конкретном случае, когда мы создаем вектор, то у нас есть выделенное
пространство памяти только для трех элементов. Добавление четвертого элемента
будет означать: выделение нового блока памяти для всех этих элементов,
копирование старых значений и обновление внутреннего указателя на эту память.
Все это работает просто отлично. Проблема заключается в том, что `y` не будет
обновлена, из-за чего мы получим ‘зависший указатель‘. И это плохо. Любое
использование `y` в этом случае будет означать ошибку, и поэтому компилятор
поймал ее для нас.

Так как же нам решить эту проблему? Есть два подхода, которые мы можем
использовать. Первый заключается в создании копии вместо ссылки:

```rust
fn main() {
    let mut x = vec!["Hello", "world"];

    let y = x[0].clone();

    x.push("foo");
}
```

Rust использует [семантику перемещения][move] по умолчанию, поэтому, если мы
хотим сделать копию некоторых данных, мы должны вызывать метод `clone()`. В этом
примере `y` больше не является ссылкой на вектор, хранящейся в `x`, но является
копией его первого элемента, `"hello"`. Теперь, когда у нас больше нет ссылки,
метод `push()` работает просто отлично.

[move]: move-semantics.html

Если мы все же хотим ссылку, то следует использовать другой вариант: убедиться,
что наша ссылка выходит из области видимости прежде чем мы попытаемся сделать
изменения. Это выглядит примерно так:

```rust
fn main() {
    let mut x = vec!["Hello", "world"];

    {
        let y = &x[0];
    }

    x.push("foo");
}
```

Мы создали внутреннюю область видимости с помощью дополнительных фигурных
скобок. `y` выйдет за пределы этой области видимости до вызова метода `push()`,
и поэтому все будет хорошо.

Концепция права владения хороша не только для предотвращения повисших
указателей, но также всей совокупности связанных с этим проблем, таких как:
недействительность итератора, параллелизм и многое другое.
