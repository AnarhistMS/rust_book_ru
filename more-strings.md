% Больше о строках

Строки - важное понятие, которое необходимо освоить в любом языке программирования. Если вы пришли из управляемого языка, то можете быть удивлены сложностью обработки строк в системном языке программирования. Эффективный доступ и выделение памяти для структуры динамического размера включает в себя много нюансов. К счастью, Rust имеет большое количество инструментов, чтобы помочь нам в этом вопросе.

**string** - это последовательность скалярных значений юникод, закодированных в виде потока UTF-8 байт. Все строки должны быть гарантированно валидными UTF-8 последовательностями. Кроме того, строки не оканчиваются нулем и могут содержать нулевые байты.

Rust имеет два основных типа строк: `&str` и `String`.

# `&str`

Первый тип строк - `&str`. Это произносится как 'строковый слайс (срез)'. Строковые литералы имеют тип `&str`:

```
let string = "Hello there.";
```

Как и любая ссылка Rust, строковые слайсы имеют связанный срок жизни. Для строкового литерала - `&'static str`. Строковый слайс можно записать без явного указания срока жизни во многих случаях, например, в качестве аргументов функций. В этих случаях срок жизни будет выведен:

```
fn takes_slice(slice: &str) {
    println!("Got: {}", slice);
}
```

Как и векторные слайсы, строковые слайсы - это просто указатель плюс длина. Это означает, что они являются 'видом' ('представлением') уже размещенной в памяти строки, например, строковый литерал или `String`.

## `str`

Иногда вы можете встретить использование типа `str` без `&`. Хотя этот тип существует, это не то, что вам следует использовать самостоятельно. Иногда люди путают `str` и `String`, и написать так:

```rust
struct S {
    s: str,
}
```

Это приводит к неприятным ошибкам:

```text
error: the trait `core::marker::Sized` is not implemented for the type `str` [E0277]
note: `str` does not have a constant size known at compile-time
```

Вместо этого `struct` должна быть

```rust
struct S {
    s: String,
}
```

Итак, давайте поговорим о `String`.

# `String`

`String` - это размещенная в куче строка. Эта строка расширяема, а также гарантированно является UTF-8. `String` обычно создаются путем преобразования из строкового слайса при помощи метода `to_string`.

```
let mut s = "Hello".to_string();
println!("{}", s);

s.push_str(", world.");
println!("{}", s);
```

Ссылка на `String` будет автоматически приводятся к строковому слайсу:

```
fn takes_slice(slice: &str) {
    println!("Got: {}", slice);
}

fn main() {
    let s = "Hello".to_string();
    takes_slice(&s);
}
```

Вы также можете получить `&str` из размещенного в стеке массива байт:

```
use std::str;

let x: &[u8] = &[b'a', b'b'];
let stack_str: &str = str::from_utf8(x).unwrap();
```

# Лучшая практика

## `String` vs `&str`

В общем, следует отдавать предпочтение `String`, когда вам нужно право владения, и `&str`, когда вам нужно просто позаимствовать строку. Это очень похоже на использование `Vec<T>` vs `&[T]`, `T` vs `&T` в общем.

Это означает, начинать с:

```{rust,ignore}
fn foo(s: &str) {
```

и только затем изменять на:

```{rust,ignore}
fn foo(s: String) {
```

если у вас есть веские основания для этого. Забирать право собственности в тех случаях, где это не нужно, является плохой практикой. К тому же это может сделать сроки жизни более запутанными.

## Обобщенные функции

To write a function that's generic over types of strings, use `&str`.
Чтобы записать функцию, которая является обобщенной по типам строк, используйте `&str`.

```
fn some_string_length(x: &str) -> usize {
    x.len()
}

fn main() {
    let s = "Hello, world";

    println!("{}", some_string_length(s));

    let s = "Hello, world".to_string();

    println!("{}", some_string_length(&s));
}
```

Обе эти строки напечатают `12`.

## Индексация строк

Вы можете захотеть попробовать получить доступ к определенному символу `String`, например:

```{rust,ignore}
let s = "hello".to_string();

println!("{}", s[0]);
```

Этот код не компилируется. И это не случайно. В мире UTF-8, прямая индексация практически никогда не является тем, что вы хотите сделать. Причина в том, что каждый символ может состоять из переменного количества байт. Это означает, что для перебора вы в любом случае должны использовать символы, что является O(n) операцией.

Существует 3 основных уровня для unicode (и его кодировок):

- кодовые единицы (code units), базовый тип данных, используемый для хранения всего
- кодовые точки/скалярные значения unicode (code points/unicode scalar values) (символы)
- графемы (grapheme) (визуальные символы)

Rust предоставляет итераторы для каждого из этих уровней:

- `.bytes()` будет итерировать по нижележащим байтам (code units)
- `.chars()` будет итерировать по кодовым точкам (code points)
- `.graphemes()` будет итерировать по графемам (grapheme)

Как правило, метод `graphemes()` для `&str` - это именно то, что вы хотите:

```
# #![feature(unicode)]
let s = "u͔n͈̰̎i̙̮͚̦c͚̉o̼̩̰͗d͔̆̓ͥé";

for l in s.graphemes(true) {
    println!("{}", l);
}
```

Этот код напечатает:

```text
u͔
n͈̰̎
i̙̮͚̦
c͚̉
o̼̩̰͗
d͔̆̓ͥ
é
```

Следует отметить, что `l` здесь имеет тип `&str`, так как одна графема может состоять из нескольких кодовых точек, поэтому `char` тут не будет уместен.

Как и следовало ожидать, этот код будет печатать каждый отображаемый символ в порядке очереди: первым `u͔`, затем `n͈̰̎`, и т.д. Если вы хотите получить каждую кодовую точку каждой графемы отдельно, то можете использовать `.chars()`:

```
let s = "u͔n͈̰̎i̙̮͚̦c͚̉o̼̩̰͗d͔̆̓ͥé";

for l in s.chars() {
    println!("{}", l);
}
```

Этот код напечатает:

```text
u
͔
n
̎
͈
̰
i
̙
̮
͚
̦
c
̉
͚
o
͗
̼
̩
̰
d
̆
̓
ͥ
͔
e
́
```

Вы можете видеть, что некоторые из них являются комбинируемыми символами, и поэтому их отображение выглядит немного странным.

Если вы хотите получить представление каждого отдельного байта для каждой кодовой точки, то можете использовать `.bytes()`:

```
let s = "u͔n͈̰̎i̙̮͚̦c͚̉o̼̩̰͗d͔̆̓ͥé";

for l in s.bytes() {
    println!("{}", l);
}
```

Этот код напечатает:

```text
117
205
148
110
204
142
205
136
204
176
105
204
153
204
174
205
154
204
166
99
204
137
205
154
111
205
151
204
188
204
169
204
176
100
204
134
205
131
205
165
205
148
101
204
129
```

Количество байт намного больше, чем графем!

# `Deref` приведение

Ссылки на `String` автоматически приводятся к `&str`. Как показано в коде ниже:

```
fn hello(s: &str) {
   println!("Hello, {}!", s);
}

let slice = "Steve";
let string = "Steve".to_string();

hello(slice);
hello(&string);
```
