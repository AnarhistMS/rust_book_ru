% Замыкания

К этому моменту мы уже создали много функций в Rust, но мы дали им всем имена.
Rust также позволяет нам создавать анонимные функции. В Rust анонимные функции,
называются *замыкания*. Сами по себе замыкания не предсталяют большого интереса,
но, когда вы объединяете их с функциями, которые принимают замыкания в качестве
аргументов, то становится возможным создавать по-настоящему мощные вещи.

Давайте создадим замыкание:

```{rust}
let add_one = |x| { 1 + x };

println!("The sum of 5 plus 1 is {}.", add_one(5));
```

Мы создаем замыкание с помощью `|...| { ... }` синтаксиса, а затем связываем его
с именем, поэтому мы можем использовать его позже. Обратите внимание, что мы
вызываем функцию с помощью связанного имени и двух круглых скобок, точно так же,
как мы бы делали это для именонанной функции.

Давайте сравним синтаксис. Они довольно близки:

```{rust}
let add_one = |x: i32| -> i32 { 1 + x };
fn  add_one   (x: i32) -> i32 { 1 + x }
```

Как вы могли заметить, замыкание самостоятельно выводит типы аргументов и
возвращаемого значения, так что вам не обязательно объявлять один. Это отличает
их от именованных функций, которые по умолчанию возвращения блок (`()`).

Но есть одна большая разница между замыканием и именованной функцией, название
говорит само за себя: замыкание "замыкает в себе свое окружение." Что это
значит? Это означает следующее:

```{rust}
fn main() {
    let x: i32 = 5;

    let printer = || { println!("x is: {}", x); };

    printer(); // prints "x is: 5"
}
```

Синтаксис `||` означает, что это замыкание, которое не принимает никаких
аргументов. Без него мы бы просто получили блок кода, заключенный в `{}`.

Другими словами, замыкание имеет доступ к переменным в области определения, где
оно определено. Замыкание заимствует все переменные, которые оно использует, так
что это будет ошибка:

```{rust,ignore}
fn main() {
    let mut x: i32 = 5;

    let printer = || { println!("x is: {}", x); };

    x = 6; // error: cannot assign to `x` because it is borrowed
}
```

## Перемещающие замыкания

В Rust есть второй тип замыканий, называемых *перемещающие замыкания*.
Перемещающие замыкания определяются с помощью ключевого слова `move` (например,
`move || x * x`). Разница между перемещающим и обычным замыканиями в том, что
перемещающее замыкание становится владельцем всех переменных, которые оно
использует. Обычное замыкание, напротив, просто создает ссылку в замыкнутом
кадре стека. Перемещающие замыкания являются наиболее полезными в сочетании с
особенностями параллелизма Rust, и поэтому мы просто оставим эту тему сейчас. Мы
поговорим о них более подробно в главе "параллелизм" этой книги.

## Передача замыканий в качестве аргументов

Замыкания являются наиболее полезными, если использовать их в качестве аргумента
другой функции. Вот пример:

```{rust}
fn twice<F: Fn(i32) -> i32>(x: i32, f: F) -> i32 {
    f(x) + f(x)
}

fn main() {
    let square = |x: i32| { x * x };

    twice(5, square); // evaluates to 50
}
```

Давайте разберем пример, начиная с `main`:

```{rust}
let square = |x: i32| { x * x };
```

Мы уже видели подобное раньше. Мы создаем замыкание, принимающее целое число, и
возвращающее квадрат этого числа.

```{rust}
# fn twice<F: Fn(i32) -> i32>(x: i32, f: F) -> i32 { f(x) + f(x) }
# let square = |x: i32| { x * x };
twice(5, square); // evaluates to 50
```

Эта строка более интересна. Здесь мы вызываем нашу функцию `twice`, и передаем
ей два аргумента: целое число, `5`, и наш замыкание, `square`. Это аналогично
передачи в функцию каких-либо двух других связанных переменных, но если вы
никогда не работали с замыканиями ранее, это может показаться немного сложным.
Подумайте только: "Я передаю две переменные: одна i32, а другая функция."

Далее, давайте посмотрим на то, как `twice` определяется:

```{rust,ignore}
fn twice<F: Fn(i32) -> i32>(x: i32, f: F) -> i32 {
```

`twice` принимает два аргумента, `x` и `f`. Вот почему мы вызывали ее с двумя
аргументами. `x` имеет тип `i32`, мы имели дело с этим много раз. `f` является
функцией, которая принимает `i32` и возвращает `i32`. Это то, о чем говорит что
требование `Fn(i32) -> i32` для параметра типа `F`. Теперь `F` представляет
собой *любую* функцию, которая принимает `i32` и возвращает `i32`.

Это самая сложная сигнатура функции из всех, которые мы видели до сих пор!
Прочтите это несколько раз, пока вы не осознаете, как это работает. Это
потребует немного практики. Хорошей новостью является то, что этот вид передачи
замыкания может быть очень эффективным. Со всеми типами, информация о которых
имеется во время компиляции, компилятор может творить чудеса.

Наконец, `twice` возвращает `i32`.

Хорошо, давайте посмотрим на тело функции `twice`:

```{rust}
fn twice<F: Fn(i32) -> i32>(x: i32, f: F) -> i32 {
  f(x) + f(x)
}
```

Так как наше замыкание имеет имя `f`, мы можем вызывать его так же, как мы
вызывали наши замыкания прежде, и мы передаем аргумент `x` в каждый из двух
вызовов, отсюда и название `twice`.

If you do the math, `(5 * 5) + (5 * 5) == 50`, so that's the output we get.
Если вы сравните, `(5 * 5) + (5 * 5) == 50`, то уви так что это выходе мы
получаем.

Поэкспериментируйте с этой концепцией, пока вы не чувствуете себя комфортно при
работе с ней. В стандартной библиотеке Rust постоянно используются замыкания,
где это уместно, так что вы часто будете сталкиваться с этой техникой.

Если мы не хотим присваивать имя `square`, мы могли бы просто определить его как
встроенное замыкание. Этот пример точно такой же, как и предыдущий:

```{rust}
fn twice<F: Fn(i32) -> i32>(x: i32, f: F) -> i32 {
    f(x) + f(x)
}

fn main() {
    twice(5, |x: i32| { x * x }); // evaluates to 50
}
```

Везде, где используется замыкание, можно использовать именованную функцию. Ниже
приведен другой способ написания предыдущего примера:

```{rust}
fn twice<F: Fn(i32) -> i32>(x: i32, f: F) -> i32 {
    f(x) + f(x)
}

fn square(x: i32) -> i32 { x * x }

fn main() {
    twice(5, square); // evaluates to 50
}
```

Это используется не особенно часто, но время от времени это бывает полезным.

Прежде чем мы перейдем дальше, давайте посмотрим на функцию, которая принимает
два замыкания.

```{rust}
fn compose<F, G>(x: i32, f: F, g: G) -> i32
    where F: Fn(i32) -> i32, G: Fn(i32) -> i32 {
    g(f(x))
}

fn main() {
    compose(5,
            |n: i32| { n + 42 },
            |n: i32| { n * 2 }); // evaluates to 94
}
```

Вы можете задаться вопросом: почему мы использовали два параметра типа `F` и `G`
здесь? Очевидно, что оба аргумента `f` и `g` имеют одинаковую сигнатуру:
`Fn(i32) -> i32`.

Это потому, что в Rust каждое замыкание имеет свой собственный уникальный тип.
Поэтому не только замыкания с разными сигнатурами имеют различные типы, но и
разные замыкания с *одинаковыми* сигнатурами также имеют *различные* типы!

Вы можете думать об этом так: поведение замыкания является частью его типа.
Таким образом, использование одного параметра типа для обоих замыканий будет
принято первым из них, но отвергнуто вторым. Отличный тип второго замыкания не
позволяет ему быть представленным тем же параметром типа, что и первое
замыкание. Мы осознаем это, и поэтому используем два разных параметра типа `F` и
`G`.

Этот пример также вводит статью `where`, что позволяет нам описать параметры
типов в более гибкой манере.

Это все, что вам нужно, чтобы работать с замыканиями! Замыкания могут показаться
немного странным на первый взгляд, но, как только вы привыкнете к ним, вам будет
не хватать их в на других языках. Передача функций в другие функции может быть
невероятно мощным, что вы увидите в следующей главе об итераторах.
