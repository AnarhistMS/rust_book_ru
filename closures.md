% Замыкания

Помимо именованных функций Rust предоставляет еще и анонимные функции. Анонимные
функции, которые имеют связанное окружение, называются 'замыкания'. Они так
называются потому что они замыкают свое окружение. Как мы увидим далее, Rust
имеет реально крутую реализацию замыканий.

# Синтаксис

Замыкания выглядят следующим образом:

```rust
let plus_one = |x: i32| x + 1;

assert_eq!(2, plus_one(1));
```

Мы создаем связывание, `plus_one`, и присваиваем ему замыкание. Аргументы
замыкания располагаются между двумя символами `|`, а телом замыкания является
выражение, в данном случае: `x + 1`. Помните, что `{ }` также является
выражением, поэтому тело замыкания может содержать много строк:

```rust
let plus_two = |x| {
    let mut result: i32 = x;

    result += 1;
    result += 1;

    result
};

assert_eq!(4, plus_two(2));
```

Обратите внимание, что есть несколько небольших различий между замыканиями и
обычными функциями, определенными с помощью `fn`. Первое отличие состоит в том,
что для замыкания мы не должны указывать ни типы аргументов, которые оно
принимает, ни тип возвращаемого им значения. Мы можем:

```rust
let plus_one = |x: i32| -> i32 { x + 1 };

assert_eq!(2, plus_one(1));
```

But we don't have to. Why is this? Basically, it was chosen for ergonomic reasons.
While specifying the full type for named functions is helpful with things like
documentation and type inference, the types of closures are rarely documented
since they’re anonymous, and they don’t cause the kinds of error-at-a-distance
that inferring named function types can.
Но мы не должны. Почему так? В основном, это было сделано из эргономических
соображений (соображений удобства). В то время как для именованных функций
указание полного типа является полезным для таких аспектов как документация и
вывод типа, типы замыканий редко документируют, поскольку они анонимны, и они не
вызывают виды ошибок на расстояния (отлрженных ошибок) (error-at-a-distance),
которое могут выдавать типы именованных функций.

Второе отличие - синтаксис очень похож, но все же немного отличается. Я добавил
пробелы здесь, чтобы было более наглядно:

```rust
fn  plus_one_v1 (  x: i32 ) -> i32 { x + 1 }
let plus_one_v2 = |x: i32 | -> i32 { x + 1 };
let plus_one_v3 = |x: i32 |          x + 1  ;
```

Есть небольшие различия, но принцип аналогичен.

# Замыкания и их окружение

Замыкания называются так потому, что они 'замыкают свое окружение.' Это выглядит
следующим образом:

```rust
let num = 5;
let plus_num = |x: i32| x + num;

assert_eq!(10, plus_num(5));
```

Это замыкание, `plus_num`, ссылается на связанную с помощью оператора `let`
переменную `num`, расположенную в своей области видимости. Если говорить более
конкретно, то оно заимствует связывание. Если мы сделаем что-то, что
противоречило бы связыванию, то получим ошибку. Например этот код:

```rust,ignore
let mut num = 5;
let plus_num = |x: i32| x + num;

let y = &mut num;
```

Который выдаст следующие ошибки:

```text
error: cannot borrow `num` as mutable because it is also borrowed as immutable
    let y = &mut num;
                 ^~~
note: previous borrow of `num` occurs here due to use in closure; the immutable
  borrow prevents subsequent moves or mutable borrows of `num` until the borrow
  ends
    let plus_num = |x| x + num;
                   ^~~~~~~~~~~
note: previous borrow ends here
fn main() {
    let mut num = 5;
    let plus_num = |x| x + num;
    
    let y = &mut num;
}
^
```

Подробные сообщения, но полезно ошибка! Как говорится в сообщении, мы не можем
получить изменяемый заем переменной `num` потому что замыкание уже заимствует
его. Если же мы обеспечим выход замыкания из области видимости, то мы сможем:

```rust
let mut num = 5;
{
    let plus_num = |x: i32| x + num;

} // plus_num goes out of scope, borrow of num ends

let y = &mut num;
```

Однако, Rust также может забирать право владения и перемещать свое окружение,
если этого требует замыкание:

```rust,ignore
let nums = vec![1, 2, 3];

let takes_nums = || nums;

println!("{:?}", nums);
```

Этот код выдаст:

```text
note: `nums` moved into closure environment here because it has type
  `[closure(()) -> collections::vec::Vec<i32>]`, which is non-copyable
let takes_nums = || nums;
                    ^~~~~~~
```

`Vec<T>` обладает правом собственности на свое содержимое, и поэтому, когда мы
ссылаемся на него в нашем замыкании, мы должны забрать право собственности на
`nums`. Это тоже самое, как если бы мы передавали `nums` в функцию, которая
забирала бы право собственности на него.

## `move` замыкания

Мы можем заставить наше замыкание забирать право собственности из его окружения
с помошью ключевого слова `move`:

```rust
let num = 5;

let owns_num = move |x: i32| x + num;
```

Now, even though the keyword is `move`, the variables follow normal move semantics.
In this case, `5` implements `Copy`, and so `owns_num` takes ownership of a copy
of `num`. So what's the difference?
Теперь, когда указано ключевое слово `move`, переменные следуют нормальной
семантике перемещения. В данном примере, `5` реализует `Copy`, поэтому
`owns_num` становится владельцем копии `num`. Так в чем же разница?

```rust
let mut num = 5;

{ 
    let mut add_num = |x: i32| num += x;

    add_num(5);
}

assert_eq!(10, num);
```

Таким образом, в этом примере наше замыкание принимает изменяемую ссылку на
`num`. Затем, когда мы вызываем замыкание `add_num`, то, как мы и ожидали, оно
изменяет значение внутри. Нам также необходимо объявить `owns_num` как `mut`,
потому что оно изменяет свое окружение.

Мы также должны были объявить `add_num` как `mut`, так как оно будет изменять
свое окружение.

Если же мы изменим на `move` замыкание, то получим следующие отличия:

```rust
let mut num = 5;

{ 
    let mut add_num = move |x: i32| num += x;

    add_num(5);
}

assert_eq!(5, num);
```

Мы всего лишь получаем `5`. Вместо того, чтобы получать изменяемый заем на
`num`, мы получаем право собственности на копию.

Вот еще один способ думать о `move` замыканиях: они предоставляют замыкание со
своим собственным фреймом стека. Без `move`, замыкание может быть связано с
фреймом стека, который его создал, в то время как `move` замыкание содержит свой
собственный фрейм стека. Это означает, например, что вы не можете вернуть не
`move` замыкание из функции.

Но прежде чем говорить о получении в качестве аргумента и возвращении замыкания,
мы должны поговорить о том, как реализуются замыкания. Как системный язык
программирования, Rust дает вам кучу контроля над тем, что делает ваш код, и
замыкания не являются исключением.

# Реализация замыканий

Реализация замыканий в Rust немного отличается от других языков. Фактически, она
представляет из себя просто синтаксисический сахар для трейтов. Перед тем как
читать дальше, настоятельно рекомендуем прочитать главу [Трейты][traits], а
также главу о [статической и динамической диспетчеризации][dispatch], в которой
говорится об трейт объектах.

[traits]: traits.html
[dispatch]: static-and-dynamic-dispatch.html

Прочитали? Хорошо.

The key to understanding how closures work under the hood is something a bit
strange: Using `()` to call a function, like `foo()`, is an overloadable
operator. From this, everything else clicks into place. In Rust, we use the
trait system to overload operators. Calling functions is no different. We have
three separate traits to overload with:
Ключ к пониманию того, как замыкания работают изнутри звучит немного странно:
использование `()` для вызова функции, как например `foo()`, представляет собой
перегрузку оператора. Исходя из этого, все остальное встанет на свои места. В
Rust мы используем трейт систему для перегрузки операторов. Вызов функций не
является исключением. Существуют три отдельных трейта для перегрузки:

```rust
# mod foo {
pub trait Fn<Args> : FnMut<Args> {
    extern "rust-call" fn call(&self, args: Args) -> Self::Output;
}

pub trait FnMut<Args> : FnOnce<Args> {
    extern "rust-call" fn call_mut(&mut self, args: Args) -> Self::Output;
}

pub trait FnOnce<Args> {
    type Output;

    extern "rust-call" fn call_once(self, args: Args) -> Self::Output;
}
# }
```

Вы можете заметить некоторые различия между этими трейтами, но есть одно главное
различие - `self`: `Fn` принимает `&self`, `FnMut` принимает `&mut self`,
`FnOnce` принимает `self`. Это покрывает все три вида `self` с помощью обычного
синтаксиса вызова методов. Мы разделили их на три трейта, вместо того, чтобы
иметь один. Это дает нам большее количество контроля над тем, какого вида
замыкания мы можем принять.

Использование `|| {}` при создании замыканий является синтаксическим сахаром для
этих трех трейтов. Rust будет генерировать структуру для окружения, реализующую
(`impl`) соответствующий трейт, а затем использовать его.

# Передача замыканий в качестве аргументов

Теперь, когда мы знаем, что замыкания являются трейтами, получается, что мы уже
знаем, как принимать и возвращать замыкания: как и любой другой трейт!

Это также означает, что мы можем выбирать между статической и динамической
диспетчеризацией. Во-первых, давайте напишем функцию, которая принимает что-то
вызываемое, вызывает его и возвращает результат:

```rust
fn call_with_one<F>(some_closure: F) -> i32
    where F : Fn(i32) -> i32 {

    some_closure(1)
}

let answer = call_with_one(|x| x + 2);

assert_eq!(3, answer);
```

Мы передаем наше замыкание, `|x| x + 2`, в функцию `call_with_one`. Она же
делает то, что написано у нее в названии: вызывает замыкание, передавая ему `1`
в качестве аргумента.

Давайте рассмотрим сигнатуру функции `call_with_one` более подробно:

```rust
fn call_with_one<F>(some_closure: F) -> i32
#    where F : Fn(i32) -> i32 {
#    some_closure(1) }
```

Мы принимаем один параметр, который имеет тип `F`. Мы также возвращаем `i32`.
Эта часть не интересна. Следующим важным моментом является:

```rust
# fn call_with_one<F>(some_closure: F) -> i32
    where F : Fn(i32) -> i32 {
#   some_closure(1) }
```

Так как `Fn` является трейтом, мы можем связать с ним наш дженерик (обобщенный)
параметр. В этом примере, замыкание принимает `i32` в качестве аргумента и
возвращает `i32`, поэтому дженерик привязка, которую мы используем, выглядит:
`Fn(i32) -> i32`.

Здесь есть еще один ключевой момент: так как мы ограничиваем дженерик параметр с
помощью трейта, то будет применена мономорфизация, и поэтому в замыкании будет
использоваться статическая диспетчеризация. Это довольно лаконично (аккуратно).
Во многих языках для замыканий по существу используется выделение памяти в куче,
и поэтому всегда будет использоваться динамическая диспетчеризация. В Rust мы
можем выделить память для окружения замыкания в стеке и использовать статическую
диспетчеризацию вызова. Это случается довольно часто с итераторами и их
адаптерами, которые нередко принимают замыкания в качестве аргументов.

Конечно, если нам нужна динамическая диспетчеризация, мы также можем
использовать и ее. Обычно для этого случая используется трейт объект:

```rust
fn call_with_one(some_closure: &Fn(i32) -> i32) -> i32 {
    some_closure(1)
}

let answer = call_with_one(&|x| x + 2);

assert_eq!(3, answer);
```

Теперь наша функция в качетве аргумента принимает трейт объект, `&Fn`. Поэтому
мы должны создать ссылку на замыкание а затем передать ее в функцию
`call_with_one`, для этого мы используем `&||`.

# Возврат замыканий

Что очень характерно для кода в функциональном стиле - возвращать замыкания в
различных ситуациях. Если вы попытаетесь вернуть замыкание, то можете
столкнуться с ошибкой. Сперва это может показаться странным, но мы с этим
разберемся. Вот как вы, наверное, попытаетесь вернуть замыкание из функции:

```rust,ignore
fn factory() -> (Fn(i32) -> Vec<i32>) {
    let vec = vec![1, 2, 3];

    |n| vec.push(n)
}

let f = factory();

let answer = f(4);
assert_eq!(vec![1, 2, 3, 4], answer);
```

Это выдаст следующие длинные, взаимосвязанные ошибки:

```text
error: the trait `core::marker::Sized` is not implemented for the type
`core::ops::Fn(i32) -> collections::vec::Vec<i32>` [E0277]
f = factory();
^
note: `core::ops::Fn(i32) -> collections::vec::Vec<i32>` does not have a
constant size known at compile-time
f = factory();
^
error: the trait `core::marker::Sized` is not implemented for the type
`core::ops::Fn(i32) -> collections::vec::Vec<i32>` [E0277]
factory() -> (Fn(i32) -> Vec<i32>) {
             ^~~~~~~~~~~~~~~~~~~~~
note: `core::ops::Fn(i32) -> collections::vec::Vec<i32>` does not have a constant size known at compile-time
fa ctory() -> (Fn(i32) -> Vec<i32>) {
              ^~~~~~~~~~~~~~~~~~~~~

```

Для того чтобы вернуть что-то из функции, Rust должен знать, какой размер имеет
тип возвращаемого значения. Но так как `Fn` является трейтом, то в качестве него
могут выступать совершенно разные объекты, с разными размерами: много различных
типов могут реализовать `Fn`. Самый простой способ передать что-то
неопределенного размера - получить ссылку на это что-то, так как ссылки имеют
известный размер. Таким образом, следовало бы написать так:

```rust,ignore
fn factory() -> &(Fn(i32) -> Vec<i32>) {
    let vec = vec![1, 2, 3];

    |n| vec.push(n)
}

let f = factory();

let answer = f(4);
assert_eq!(vec![1, 2, 3, 4], answer);
```

Но тогда мы получим другую ошибку:

```text
error: missing lifetime specifier [E0106]
fn factory() -> &(Fn(i32) -> i32) {
                ^~~~~~~~~~~~~~~~~
```

Верно. Так как у нас используется ссылка, то мы должны задать ее срок жизни. Так
наша функция `factory()` не принимает никаких аргументов, то элизия (сокрытие)
здесь не уместна. Какой срок жизни мы должны выбрать? `'static`:

```rust,ignore
fn factory() -> &'static (Fn(i32) -> i32) {
    let num = 5;

    |x| x + num
}

let f = factory();

let answer = f(1);
assert_eq!(6, answer);
```

Но мы получим еще ошибку:

```text
error: mismatched types:
 expected `&'static core::ops::Fn(i32) -> i32`,
    found `[closure <anon>:7:9: 7:20]`
(expected &-ptr,
    found closure) [E0308]
         |x| x + num
         ^~~~~~~~~~~

```

Эта ошибка сообщает нам, что ожидается использование `&'static Fn(i32) -> i32`,
а у используется `[closure <anon>:7:9: 7:20]`. Подождите, что?

Because each closure generates its own environment `struct` and implementation
of `Fn` and friends, these types are anonymous. They exist just solely for
this closure. So Rust shows them as `closure <anon>`, rather than some
autogenerated name.
Поскольку каждое замыкание (в индивидуальном порядке) генерирует свою
собственную `struct` для окружения и реализует `Fn` и друзей, то эти типы
являются анонимными. Они существуют исключительно для этого замыкания. Поэтому
Rust показывает их как `closure <anon>`, а не в виде какого-то сгенерированного
имени.

Но почему же наше замыкание не реализует `&'static Fn`? Как мы обсуждали ранее,
замыкание занимает свое окружение. И в этом случае, наше окружение представляет
собой выделеную в стеке память, содержащую значени связанной переменной `num` -
`5`. Из-за этого заем имеет срок жизни кадра стека. Так что, когда мы вернем это
замыкание, то вызов функции будет завершен, а кадр стека уйдет, и наше замыкание
захватит окружение, содержащее в памяти мусор!

Так что же делать? Этот код _почти_ работает:

```rust,ignore
fn factory() -> Box<Fn(i32) -> i32> {
    let num = 5;

    Box::new(|x| x + num)
}
# fn main() {
let f = factory();

let answer = f(1);
assert_eq!(6, answer);
# }
```

Мы используем трейт объект, представляющий собой упакованный (`Box`) трейт `Fn`.
И остаётся только одна, последняя проблема:

```text
error: `num` does not live long enough
Box::new(|x| x + num)
         ^~~~~~~~~~~
```

Но мы все еще по-прежнему ссылаемся на родительский фрейм стека. С этии
последним исправлением мы сможем наконец сделать эту работу:

```rust
fn factory() -> Box<Fn(i32) -> i32> {
    let num = 5;

    Box::new(move |x| x + num)
}
# fn main() {
let f = factory();

let answer = f(1);
assert_eq!(6, answer);
# }
```

By making the inner closure a `move Fn`, we create a new stack frame for our
closure. By `Box`ing it up, we've given it a known size, and allowing it to
escape our stack frame.
Благодаря изменению внутреннего замыкания на `move Fn` будет создаваться новый
кадр стека для нашего замыкания. А благодаря его упаковке (`Box`),
обеспечивается известный размер возвращаемого значения, и позволяет ему избежать
нашей стека.
