% Владение

Это руководство описывает систему владения ресурсами Rust. Она представляет
собой наиболее уникальную и привлекательную особенность Rust, о которой
разработчики на Rust должны иметь полное представление. Владение - это то, как
Rust достигает своей главной цели - безопасности памяти. Система владения несет
в себе следующие основные концепции: *владение* (*ownership*), *заимствование*
(*borrowing*), и *срок жизни* (*lifetimes*). Мы поговорим о каждой из них в
дальнейшем.

# Мета

Прежде чем перейти к деталям, отметитм два важных нюанса о системе владения.

Rust сфокусирован на безопасности и скорости. Это достигается за счет абстракций
с нулевой стоимостью (*zero-cost abstractions*), что означает, что в Rust
стоимость абстракций должна быть настолько минимальной, насколько это возможно,
без ущерба для работоспособности. Система владения ресурсами - это яркий пример
абстракции с нулевой стоимостью. Весь анализ, о котором мы будем говорить в этом
руководстве, происходит _во время компиляции_. Вы не платите хоть сколько-нибудь
времени рантайма за какую-либо из фич.

Тем не менее, эта система все же имеет определенную стоимость: кривая обучения.
Многие новые пользователи Rust испытыват то, что мы называем "борьба с проверкой
заимствования", когда компилятор Rust отказывается компилировать программу,
которая по мнению автора является абсолютно правильной. Это часто происходит
потому, что мысленное представление программиста о том, как должно работать
владение, не совпадает с реальными правилами, которыми оперирует Rust. Вы,
наверное, также будете испытывать подобные трудности поначалу. Однако существует
и хорошая новость: более опытные разработчики на Rust сообщают, что чем больше
они работают с правилами системы владения, тем меньше они борются с проверкой
заимствования.

Имея это в виду, давайте перейдем к изучению систему владения.

# Владение

По своей сути, владение применяется к *ресурсам*. В подавляющем большинстве, для
данного руководства, мы будем говорить о конкретном ресурсе: памяти. Вообще, эта
концепция обобщает понятие ресурса, то есть в качестве ресурса может выступать и
дескриптор файла. Но, чтобы оперировать более конкретными понятиями, мы
сосредоточимся на памяти.

Когда ваша программа выделяет некоторый объем памяти, то она также должна каким-
то образом освобождать эту память. Представьте себе функцию `foo`, которая
выделяет четыре байта памяти, а затем никогда не освобождает эту память. Мы
называем это проблемой *утечки* (*leaking*) памяти, потому что каждый раз, когда
мы называем `foo`, мы снова и снова выделяем четыре байта. В конце концов, при
достаточном количестве вызовов `foo`, мы получим системную ошибку, сообщающую о
нехватке памяти (out of memory). Это плохо. Так что мы должны каким-то образом
освобождать этих четыре байта при вызове `foo`. Важно также, чтобы память не
была освобождена слишком много раз. Не вдаваясь в детали, скажем, что попытка
освободить память более одного раза может привести к проблемам. Другими словами,
выделяя некоторый объем памяти, мы должны убедиться в дальнейшем, что мы
освободили эту память и освободили ее лишь один раз. Много - плохо, мало - тоже
плохо. Счетчики должны совпадать.

Вот еще одна важная деталь в отношении выделения памяти. Всякий раз, когда мы
выделяем некоторое количество памяти, мы получаем ручку (handle) для
взаимодействия с этой памятью. Эта ручка (часто называемая *указателем*
(*pointer*), если мы ссылаемся на память) необходима для взаимодействия с
выделенной памятью. До тех пор пока у нас есть ручка, мы можем делать с памятью
все что угодно. После того как мы закончили работать с ручкой, мы также
заканчиваем работать с и памятью, так как мы не сможем сделать что-либо полезное
без ручки.

Исторически сложилось так, что системные языки программирования требуют от
разработчика самостоятельно отслеживать и обрабатывать выделение и освобождение
ресурсов. Например, если мы хотим выделить немного памяти из кучи в языке, таком
как C, мы делаем следующее:

```c
{
    int *x = malloc(sizeof(int));

    // we can now do stuff with our handle x
    *x = 5;

    free(x);
}
```

Вызов `malloc` выделяет память. Тут же производится рассчет необходимого
количества памяти. Вызов `free` освобождает выделенную память.

Rust объединяет эти два аспекта выделения памяти (и других ресурсов) в концепции
под названием *владение*. Всякий раз, когда мы запрашиваем некоторую память, то
мы получаем ручку, которая называется *ручкой, владеющей ресурсом*. Всякий раз,
когда эта ручка выходит из области видимости, Rust знает, что мы больше ничего
не можем делать с этой памятью, и освобождает память за нас. Вот эквивалентный
пример в Rust:

```rust
{
    let x = Box::new(5);
}
```

Функция `Box::new` создает `Box<T>` (в данном конкретньм случае - `Box<i32>`)
путем выделения небольшого сегмента памяти в куче, достаточного для хранения
`i32`. Но где же в коде освобождается бокс? Мы говорили, что для каждого
выделения памяти должно быть соответствующее освобождение памяти. Rust
освобождает память за нас. Он знает, что наша ручка, `x`, является владельцем
ссылки на бокс. Также Rust знает, что область определения `x` завершается в
конце блока, и поэтому он вставляет вызов, освобождающий память, после
завершения области определения. Так как компилятор делает это за нас, невозможно
забыть освободить память. У нас всегда есть ровно одно освобождение памяти в
паре с каждым выделением памяти.

Это довольно просто, но что будет, если мы передадим наш бокс в функцию? Давайте
посмотрим на код:

```rust
fn main() {
    let x = Box::new(5);

    add_one(x);
}

fn add_one(mut num: Box<i32>) {
    *num += 1;
}
```

Этот код работает, но он не идеален. Давайте добавим еще одну строку кода,
которая выводит значение `x`:

```{rust,ignore}
fn main() {
    let x = Box::new(5);

    add_one(x);

    println!("{}", x);
}

fn add_one(mut num: Box<i32>) {
    *num += 1;
}
```

Этот код не скомпилируется и выведет ошибку:

```text
error: use of moved value: `x`
   println!("{}", x);
                  ^
```

Помните, что у нас должно быть лишь одно освобождение памяти для
соответствующего выделения памяти. Если мы попытаемся передать наш бокс в
`add_one`, то мы получим две ручки для управления памятью: `x` в `main`, и `num`
в `add_one`. Так как Rust освобождает память каждый раз, когда ручка выходит за
пределы области определения, то у нас получилось бы два освобождения и одно
выделение памяти, что неправильно. Поэтому, когда мы вызываем `add_one`, Rust
назначает ручку `num` владельцем. После того как мы передали право владения
`num`, `x` становится недействительным. Значение `x` "перемещается" из `x` в
`num`. Отсюда ошибка: использование перемещенного значения `x`.

Чтобы исправить это, мы можем переписать функцию `add_one`, чтобы она возвращала
право владения обратно, когда закончит работать с боксом:

```rust
fn main() {
    let x = Box::new(5);

    let y = add_one(x);

    println!("{}", y);
}

fn add_one(mut num: Box<i32>) -> Box<i32> {
    *num += 1;

    num
}
```

Этот код будет скомпилирован и будет работать нормально. Теперь мы возвращаем
`box`, и поэтому право собственности возвращается обратно к `y` в функцию
`main`. Право собственности передается в функцию лишь на время, а затем
возвращается обратно. Этот паттерн является очень распространенным, и поэтому
Rust вводит понятие для описания ручки, которая временно ссылается на другую
ручку, владеющую правом собственности. Оно называется *заимствованием*, и
делается оно с использованием *ссылок*, которые обозначаются символом `&`.

# Заимствование

Вот текущее состояние нашей функции `add_one`:

```rust
fn add_one(mut num: Box<i32>) -> Box<i32> {
    *num += 1;

    num
}
```

Эта функция принимает право владения, потому что она принимает `Box`, который
владеет своим содержимым. Но затем мы возвращаем право владения обратно.

В физическом мире, вы можете передать какое-либо ваше имущество кому-то на
короткий период времени. Вы все еще будете владельцем переданного имущества, вы
просто позволите кому-то использовать его некоторое время. Это называется
*одолжить* что-то кому-то, или, если рассматривать это с другого ракурса,
*занять* что-то у кого-то.

Система владения Rust также позволяет владельцу одолжить ручку на определенный
период времени. Это также называется *заимствование*. Вот версия `add_one`,
которая заимствует свой аргумент, а не забирает право владения:

```rust
fn add_one(num: &mut i32) {
    *num += 1;
}
```

Эта функция заимствует `i32` у вызвавшей ее функции, а затем увеличивает его.
Когда функция заканчивается, и `num` выходит из области определения, то заем
также заканчивается.

Мы должны немного изменить нашу функцию `main`:

```rust
fn main() {
    let mut x = 5;

    add_one(&mut x);

    println!("{}", x);
}

fn add_one(num: &mut i32) {
    *num += 1;
}
```

Нам больше не нужно присваивать результат `add_one()` какой-либо переменной,
потому что она больше ничего не возвращает. Это потому, что мы не возвращаем
право владения обратно, так как мы использовали заимствование, а не забирали
себе право владения.

# Срок жизни

Одалживание ссылки на ресурс, которым кто-то владеет может быть довольно
сложным. Например, представьте себе следующую последовательность операций:

1. Я получаю ручку на какой-то ресурс.
2. Я одалживаю вам ссылку на это ресурс.
3. Я решаю, что ресурс мне больше не требуется, и освобождаю его, в то время как
   у вас все еще есть на него ссылка.
4. Вы решаете использовать этот ресурс.

Ой-ой! Ваша ссылка указывает на недопустимый ресурс. Это называется *висячий
указатель* или "использование после освобождения", когда ресурсом является
память.

Чтобы исправить это, мы должны убедиться, что четвертый шаг никогда не
произойдет после третьего. Система владения в Rust делает это через концепцию
под названием *срок жизни*, которая описывает область определения, на протяжении
которой ссылка будет действительна.

Помните функцию, которая заимствовала `i32`? Давайте посмотрим на нее еще раз.

```rust
fn add_one(num: &mut i32) {
    *num += 1;
}
```

У Rust есть фича под названием *элизия срока жизни* (*lifetime elision*),
которая позволяет не писать аннотации срока жизни в определенных случаях. Это
один из них. Другие мы рассмотрим позже. Без элизии срока жизни, `add_one`
выглядит следующим образом:

```rust
fn add_one<'a>(num: &'a mut i32) {
    *num += 1;
}
```

`'a` называется *сроком жизни*. В большинстве случаев использование коротких
имен для обозначения срока жизни, как например `'a`, `'b` и `'c`, является
наиболее правильным, но довольно часто бывает полезно использовать и более
говорящие имена. Давайте углубимся в синтаксис более подробно:

```{rust,ignore}
fn add_one<'a>(...)
```

Эта часть _объявляет_ срок жизни. Это говорит о том, что `add_one` имеет один
срок жизни, `'a`. Если у нас было бы два срока жизни, то это выглядело бы так:

```{rust,ignore}
fn add_two<'a, 'b>(...)
```

Затем в списке параметров, мы используем заданный срок жизни:

```{rust,ignore}
...(num: &'a mut i32)
```

Если вы сравните `&mut i32` с `&'a mut i32`, то увидите, что они отличаются
только определением срока жизни `'a`, написанным между `&` и `mut i32`. `&mut
i32` читается как "изменяемая ссылка на i32", а `&'a mut i32` - как "изменяемая
ссылка на i32 со сроком жизни 'a".

Почему срок жизни имеет значение? Например, вот некоторый код:

```rust
struct Foo<'a> {
    x: &'a i32,
}

fn main() {
    let y = &5; // this is the same as `let _y = 5; let y = &_y;`
    let f = Foo { x: y };

    println!("{}", f.x);
}
```

Как вы можете заметить, структуры, `struct`, также могут иметь сроки жизни. Так
же как и функции

```{rust}
struct Foo<'a> {
# x: &'a i32,
# }
```

определяют срок жизни и

```rust
# struct Foo<'a> {
x: &'a i32,
# }
```

используют его. Почему же мы должны определять срок жизни здесь? Мы должны
убедиться, что ссылка на `Foo` не может жить дольше, чем ссылка на `i32`,
содержащаяся в нем.

## Область определения

Один из способов понять, что же такое срок жизни, это визуализировать область, в
которой ссылка является действительной. Например:

```rust
fn main() {
    let y = &5;     // -+ y goes into scope
                    //  |
    // stuff        //  |
                    //  |
}                   // -+ y goes out of scope
```

Добавим нашу структуру `Foo`:

```rust
struct Foo<'a> {
    x: &'a i32,
}

fn main() {
    let y = &5;           // -+ y goes into scope
    let f = Foo { x: y }; // -+ f goes into scope
    // stuff              //  |
                          //  |
}                         // -+ f and y go out of scope
```

Наша `f` живет в области определения `y`, поэтому все работает. Что же будет,
если это не так? Этот код не будет работать:

```{rust,ignore}
struct Foo<'a> {
    x: &'a i32,
}

fn main() {
    let x;                    // -+ x goes into scope
                              //  |
    {                         //  |
        let y = &5;           // ---+ y goes into scope
        let f = Foo { x: y }; // ---+ f goes into scope
        x = &f.x;             //  | | error here
    }                         // ---+ f and y go out of scope
                              //  |
    println!("{}", x);        //  |
}                             // -+ x goes out of scope
```

Вот так! Как вы можете видеть здесь, области определения `f` и `y` меньше, чем
область определения `x`. Но когда мы выполняем `x = &f.x`, мы присваиваем `x`
ссылку на что-то, что вот-вот выйдет из области определения.

Присвоение имени сроку жизни - это способ задать имя его области определения.
Задание имени является первым шагом, чтобы иметь возможность оперировать этим
именованным понятием.

## 'static

Срок жизни с именем *static* является специальным. Он обозначает, что что-то
имеет срок жизни равный сроку жизни всей программы. Большинство Rust
программистов впервые столкиваются с `'static`, когда имеют дело со строками:

```rust
let x: &'static str = "Hello, world.";
```

Строковые литералы имеют тип `&'static str`, потому что ссылка должна быть
действительна на протяжении работы всей программы: они располагаются в сегменте
данных конечного двоичного файла. Другой пример - глобальные переменные:

```rust
static FOO: i32 = 5;
let x: &'static i32 = &FOO;
```

В этом примере `i32` добавляется в сегмент данных двоичного файла, а `x`
ссылается на него.

# Распределенное владение

Во всех примерах, которые мы рассматривали до сих пор, мы предполагали, что
каждая ручка имеет лишь одного владельца. Но иногда, это не работает. Рассмотрим
автомобиль. Автомобили имеют четыре колеса. Мы бы хотели, чтобы колесо обладало
информацией, к какому автомобилю он было присоединено. Однако это не будет
работать:

```{rust,ignore}
struct Car {
    name: String,
}

struct Wheel {
    size: i32,
    owner: Car,
}

fn main() {
    let car = Car { name: "DeLorean".to_string() };

    for _ in 0..4 {
        Wheel { size: 360, owner: car };
    }
}
```

Попробуем создать четыре колеса, `Wheel`, каждое из которых содержит автомобиль,
`Car`, к которому оно присоединено. Но компилятор сообщит, что на второй
итерации цикла есть проблема:

```text
error: use of moved value: `car`
    Wheel { size: 360, owner: car };
                              ^~~
note: `car` moved here because it has type `Car`, which is non-copyable
    Wheel { size: 360, owner: car };
                              ^~~
```

Нам нужно, чтобы на наш автомобиль, `Car`, ссылалось каждое из колес, `Wheel`.
Мы не в состоянии реализовать это с помощью `Box<T>`, потому что он может иметь
лишь одного владельца. Вместо этого, мы можем реализовать это с помощью `Rc<T>`:

```rust
use std::rc::Rc;

struct Car {
    name: String,
}

struct Wheel {
    size: i32,
    owner: Rc<Car>,
}

fn main() {
    let car = Car { name: "DeLorean".to_string() };

    let car_owner = Rc::new(car);

    for _ in 0..4 {
        Wheel { size: 360, owner: car_owner.clone() };
    }
}
```

Мы обернули наш автомобиль, `Car`, в `Rc<T>`, получив при этом `Rc<Car>`, а
затем использовали метод `clone()`, чтобы создавать новые ссылки. Мы также
изменили наше колесо, `Wheel`, чтобы оно содержало `Rc<Car>`, а не просто `Car`.

Это простейший вид множественного владения из возможных. Например, есть также
`Arc<T>`, который использует более дорогие атомарные инструкции и является
потоко-безопасным аналогом `Rc<T>`.

## Элизия срока жизни

Ранее мы уже упоминали об элизии срока жизни, особенности Rust, которая
позволяет не задавать явно аннотации срока жизни в определенных случаях. Все
ссылки имеют свой срок жизни, и поэтому, если вы не зададите срок жизни явно
(как например `&T` вместо `&'a T`), Rust будет делать три вещи, чтобы
определить, каким этот срок жизни должен быть.

Когда речь идет о неявном сроке жизни, мы используем термины *входной срок
жизни* (*input lifetime*) и *выходной срок жизни* (*output lifetime*). *Входной
срок жизни* связан с передаваемыми в функцию параметрами, а *выходной срок
жизни* связан с возвращаемым функцией значением. Например, эта функция имеет
входной срок жизни:

```{rust,ignore}
fn foo<'a>(bar: &'a str)
```

А эта имеет выходной срок жизни:

```{rust,ignore}
fn foo<'a>() -> &'a str
```

Эта же имеет как входной, так и выходной сроки жизни:

```{rust,ignore}
fn foo<'a>(bar: &'a str) -> &'a str
```

Ниже представлены три правила:

* Каждый неявный срок жизни в аргументах функции становится индивидуальным
  сроком жизни.

* Если есть ровно один входной срок жизни, явный или неявный, то этот срок жизни
  присваивается всем неявным выходным срокам жизни.

* Если есть несколько входных сроков жизней, но один из них это `&self` или
  `&mut self`, то всем неявным выходным срокам жизни назначается срок жизни
  `self`.

В противном случае, неявное задание выходного срока жизни является ошибкой.

### Примеры

Вот некоторые примеры функций, представленные в 2 видах: с явно (развернутая
форма) и неявно заданным сроком жизни:

```{rust,ignore}
fn print(s: &str); // elided
fn print<'a>(s: &'a str); // expanded

fn debug(lvl: u32, s: &str); // elided
fn debug<'a>(lvl: u32, s: &'a str); // expanded

// In the preceding example, `lvl` doesn't need a lifetime because it's not a
// reference (`&`). Only things relating to references (such as a `struct`
// which contains a reference) need lifetimes.

fn substr(s: &str, until: u32) -> &str; // elided
fn substr<'a>(s: &'a str, until: u32) -> &'a str; // expanded

fn get_str() -> &str; // ILLEGAL, no inputs

fn frob(s: &str, t: &str) -> &str; // ILLEGAL, two inputs
fn frob<'a, 'b>(s: &'a str, t: &'b str) -> &str; // Expanded: Output lifetime is unclear

fn get_mut(&mut self) -> &mut T; // elided
fn get_mut<'a>(&'a mut self) -> &'a mut T; // expanded

fn args<T:ToCStr>(&mut self, args: &[T]) -> &mut Command // elided
fn args<'a, 'b, T:ToCStr>(&'a mut self, args: &'b [T]) -> &'a mut Command // expanded

fn new(buf: &mut [u8]) -> BufWriter; // elided
fn new<'a>(buf: &'a mut [u8]) -> BufWriter<'a> // expanded
```

# Related Resources

Coming Soon.
